// Pattern matching tests for Phase 7 Milestone 5

// =====================================================
// Simple Enum Matching - Color type
// =====================================================

type Color = Red | Green | Blue

// Multi-line match expression (testing multi-line syntax support)
(match Red with
    | Red -> 1
    | Green -> 2
    | Blue -> 3) = 1

// Multi-line with closing paren on separate line
(match Green with
    | Red -> 100
    | Green -> 200
    | Blue -> 300
) = 200

// Match on simple enum - first variant
match Red with | Red -> 1 | Green -> 2 | Blue -> 3 = 1

// Match on simple enum - second variant
match Green with | Red -> 1 | Green -> 2 | Blue -> 3 = 2

// Match on simple enum - third variant
match Blue with | Red -> 1 | Green -> 2 | Blue -> 3 = 3

// Wildcard pattern matches anything
match Green with | Red -> 1 | _ -> 99 = 99

// Wildcard at end is catch-all
match Blue with | Red -> 1 | Green -> 2 | _ -> 100 = 100

// Match on enum stored in variable
let c = Green in match c with | Red -> 10 | Green -> 20 | Blue -> 30 = 20

// Match with arithmetic in case body
match Red with | Red -> 5 + 10 | _ -> 0 = 15

// Match with complex body expressions
match Red with | Red -> 2 + 3 | Green -> 10 - 5 | Blue -> 1 * 1 = 5

// =====================================================
// Other Simple Enums
// =====================================================

// Two variant type (shadowing built-in Bool for testing)
type Bool = True | False

let b = True in match b with | True -> 100 | False -> 0 = 100
match False with | True -> 1 | False -> 0 = 0

// Four variant type
type Dir = North | East | South | West

match South with | North -> 0 | East -> 1 | South -> 2 | West -> 3 = 2

// === Milestone 6: Payload Extraction ===

type MyOption = MyNone | MySome of Int64

// Extract payload from MySome variant
match MySome(42) with | MySome(x) -> x | MyNone -> 0 = 42

// Extract and use payload in arithmetic
match MySome(10) with | MySome(x) -> x + 5 | MyNone -> 0 = 15

// Match MyNone case (no extraction)
match MyNone with | MySome(x) -> x | MyNone -> 99 = 99

// Extract and multiply
match MySome(6) with | MySome(x) -> x * 7 | MyNone -> 0 = 42

// Extract with wildcard fallback
match MySome(123) with | MySome(n) -> n | _ -> 0 = 123

// Variable binding on whole scrutinee (uses Color from above)
match Green with | x -> 1 = 1

// Extract payload with different variant order
type MyResult = MyOk of Int64 | MyErr

match MyOk(100) with | MyOk(v) -> v | MyErr -> 0 = 100
match MyErr with | MyOk(v) -> v | MyErr -> 1 = 1

// Multiple payload variants
type Either = Left of Int64 | Right of Int64

match Left(5) with | Left(x) -> x | Right(y) -> y = 5
match Right(7) with | Left(x) -> x | Right(y) -> y = 7

// === Integer Literal Patterns ===

// Match on integer literal - first case
match 42 with | 42 -> 1 | _ -> 0 = 1

// Match on integer literal - fallback
match 99 with | 42 -> 1 | _ -> 0 = 0

// Multiple integer cases
match 2 with | 1 -> 10 | 2 -> 20 | 3 -> 30 | _ -> 0 = 20

// Integer match with variable binding
match 7 with | 7 -> 100 | x -> x = 100

// Match on computed integer
let x = 3 + 2 in match x with | 5 -> 1 | _ -> 0 = 1

// Large integer literal
match 1000000 with | 1000000 -> 1 | _ -> 0 = 1

// Zero matching
match 0 with | 0 -> 42 | _ -> 0 = 42

// Negative number matching
match 0 - 5 with | 0 -> 1 | x -> x + 10 = 5

// === Boolean Patterns ===

// Match on true literal
match true with | true -> 1 | false -> 0 = 1

// Match on false literal
match false with | true -> 1 | false -> 0 = 0

// Boolean from comparison
match 5 > 3 with | true -> 100 | false -> 0 = 100

// Boolean from equality
match 5 == 5 with | true -> 1 | false -> 0 = 1

// Boolean in variable
let b = true in match b with | true -> 42 | false -> 0 = 42

// Inverted boolean match
match false with | false -> 99 | true -> 1 = 99

// === Tuple Patterns ===

// Simple 2-tuple extraction
match (1, 2) with | (a, b) -> a + b = 3

// 3-tuple extraction
match (10, 20, 30) with | (a, b, c) -> a + b + c = 60

// 4-tuple extraction
match (1, 2, 3, 4) with | (a, b, c, d) -> a + b + c + d = 10

// Tuple with wildcard elements
match (100, 200) with | (x, _) -> x = 100

// Tuple with second element wildcard
match (100, 200) with | (_, y) -> y = 200

// Nested arithmetic in tuple
match (5 + 5, 3 * 4) with | (a, b) -> a * b = 120

// Tuple from variable
let t = (7, 8) in match t with | (x, y) -> x * y = 56

// Tuple with all wildcards (just structure match)
match (1, 2, 3) with | (_, _, _) -> 42 = 42

// Mix of binding and wildcard
match (1, 2, 3, 4, 5) with | (a, _, c, _, e) -> a + c + e = 9

// === Record Patterns ===

type Point = { x: Int64, y: Int64 }

// Simple record extraction
match Point { x = 10, y = 20 } with | Point { x = a, y = b } -> a + b = 30

// Record with one field extracted
match Point { x = 5, y = 10 } with | Point { x = n, y = _ } -> n = 5

// Record second field only
match Point { x = 5, y = 15 } with | Point { x = _, y = m } -> m = 15

// Record from variable
let p = Point { x = 3, y = 4 } in match p with | Point { x = a, y = b } -> a * a + b * b = 25

// Three-field record
type Vec3 = { x: Int64, y: Int64, z: Int64 }

match Vec3 { x = 1, y = 2, z = 3 } with | Vec3 { x = a, y = b, z = c } -> a + b + c = 6

// === Nested ADT Patterns ===

// Nested - testing Wrap type (MyOption already defined above)
type Nested = Empty | Wrap of Int64

match Wrap(42) with | Wrap(x) -> x | Empty -> 0 = 42

// Deeply extract from nested variant
type Box = Empty | Full of Int64

match Full(99) with | Full(n) -> n * 2 | Empty -> 0 = 198

// === Complex Combinations ===
// Note: Uses MyOption and Point defined above

// Tuple inside match case body
match MySome(5) with | MySome(x) -> let t = (x, x * 2) in match t with | (a, b) -> a + b | MyNone -> 0 = 15

// Record access in match body
match MySome(1) with | MySome(_) -> let p = Point { x = 10, y = 20 } in p.x + p.y | MyNone -> 0 = 30

// Match on tuple element
match (1, 2) with | (a, _) -> match a with | 1 -> 100 | _ -> 0 = 100

// Chained matches (uses Color from above)
match Red with | Red -> match true with | true -> 42 | false -> 0 | _ -> 0 = 42

// Match with arithmetic in result (avoid match-in-atom-position)
match 5 with | 5 -> 100 + 1 | _ -> 0 = 101

// Nested matches (avoid let x = match ... in ...)
match 1 with | 1 -> match 2 with | 2 -> 10 + 20 | _ -> 0 | _ -> 0 = 30

// Arithmetic on extracted values
type Pair = MkPair of Int64

match MkPair(7) with | MkPair(n) -> n * n + n = 56

// Boolean from comparison used in match
let x = 42 in match x == 42 with | true -> 1 | false -> 0 = 1

// Tuple with computed elements
let x = 5 in let y = 10 in match (x * 2, y / 2) with | (a, b) -> a + b = 15

// === Edge Cases ===

// Single element match (just variable)
match 42 with | x -> x = 42

// Empty-ish patterns with just wildcards
match 999 with | _ -> 1 = 1

// Order of patterns matters
match 1 with | 1 -> 100 | 2 -> 200 | _ -> 0 = 100

// Last pattern is fallback
match 99 with | 1 -> 100 | 2 -> 200 | n -> n = 99

// Multiple wildcards in different positions
type Triple = T of Int64

match T(5) with | T(x) -> x + 1 = 6

// Combine enum and payload extraction
type MaybeInt = Nothing | Just of Int64

match Just(10) with | Nothing -> 0 | Just(n) -> n + n = 20

// Mix patterns in same match
match 2 with | 1 -> 10 | 2 -> 20 | x -> x * 100 = 20

// Fallback captures value
match 7 with | 1 -> 10 | 2 -> 20 | x -> x * 100 = 700

// === Tuple-Returning Functions ===

// Function that returns tuple, matched
let t = (1 + 2, 3 + 4) in match t with | (a, b) -> a * b = 21

// Tuple of booleans
match (true, false) with | (a, _) -> match a with | true -> 1 | false -> 0 = 1

// === Records with Complex Bodies ===
// Note: Point already defined above

// Complex arithmetic with record fields
let p = Point { x = 3, y = 4 } in match p with | Point { x = a, y = b } -> (a + b) * (a - b) = -7

// Manhattan distance style
match Point { x = 3, y = 4 } with | Point { x = a, y = b } -> if a > b then a else b = 4

// === Wild Nested Combinations ===

// Tuple in ADT payload then extracted
type BoxPair = EmptyPair | Pair of Int64

match Pair(42) with | Pair(n) -> let t = (n, n + 1) in match t with | (a, b) -> a + b | EmptyPair -> 0 = 85

// ADT in tuple (via let)
type Maybe = No | Yes of Int64

let m = Yes(5) in let t = (m, 10) in match t with | (_, y) -> y = 10

// Deeply nested match cascade
match 1 with | 1 -> match 2 with | 2 -> match 3 with | 3 -> 42 | _ -> 0 | _ -> 0 | _ -> 0 = 42

// Match that returns different types of numbers
match true with | true -> 99 | false -> 0 - 1 = 99

// Compare result in match
let x = 5 in let y = 5 in match x == y with | true -> 1000 | false -> 0 = 1000

// Boolean arithmetic in match
match (5 > 3) && (2 < 4) with | true -> 1 | false -> 0 = 1

// Or in match condition
match (1 > 10) || (10 > 1) with | true -> 42 | false -> 0 = 42

// === Non-exhaustive pattern match test ===
// A 3-element list matched against [a, b] pattern with no wildcard is non-exhaustive
// This should produce a compile error
match [1, 2, 3] with | [a, b] -> a + b = error="Non-exhaustive"

// === Unsupported nested pattern tests ===
// These test that we properly reject patterns that aren't yet supported,
// rather than silently generating incorrect code.

// Nested literal pattern in record field
type Point = { x: Int64, y: Int64 } match Point { x = 5, y = 10 } with | Point { x = 5, y = n } -> n = error="Nested pattern in record field not yet supported"

// Nested tuple pattern in record field
type PointPair = { a: (Int64, Int64), b: Int64 } match PointPair { a = (1, 2), b = 3 } with | PointPair { a = (x, y), b = z } -> x + y + z = error="Nested pattern in record field not yet supported"

// Nested constructor pattern in list element
type MyOpt = MyNone | MySome of Int64 match [MySome(1)] with | [MySome(x)] -> x | _ -> 0 = error="Nested pattern in list element not yet supported"

// Nested literal pattern inside tuple inside list
match [(1, 2)] with | [(1, x)] -> x | _ -> 0 = error="Nested pattern in tuple element not yet supported"

// Nested constructor pattern in list cons head
type MyOpt = MyNone | MySome of Int64 match [MySome(1), MySome(2)] with | [MySome(x), ...rest] -> x | _ -> 0 = error="Nested pattern in list cons element not yet supported"

// Nested literal pattern inside tuple inside list cons
match [(1, 2), (3, 4)] with | [(1, x), ...rest] -> x | _ -> 0 = error="Nested pattern in tuple element not yet supported"

// === Literal patterns in lists (now supported) ===
// These test that literal patterns in list elements work correctly

// Literal pattern in list - match
match [1, 2, 3] with | [1, x, 3] -> x | _ -> 0 = 2

// Literal pattern in list - no match (wrong literal)
match [1, 2, 4] with | [1, x, 3] -> x | _ -> 0 = 0

// Literal pattern in list cons - match
match [1, 2, 3] with | [1, ...rest] -> 42 | _ -> 0 = 42

// Literal pattern in list cons - no match
match [2, 2, 3] with | [1, ...rest] -> 42 | _ -> 0 = 0

// Single literal pattern
match [13] with | [13] -> 1 | _ -> 0 = 1

// Single literal pattern - no match
match [14] with | [13] -> 1 | _ -> 0 = 0

// === Nested Bool patterns in constructors (regression tests) ===
// These test that Option<Bool> with literal patterns work correctly

// Some(false) should NOT match Some(true)
match Some(false) with | Some(true) -> 100 | Some(false) -> 0 | None -> -1 = 0

// Some(true) should match Some(true)
match Some(true) with | Some(true) -> 100 | Some(false) -> 0 | None -> -1 = 100

// Order of patterns doesn't matter for correctness
match Some(false) with | Some(false) -> 0 | Some(true) -> 100 | None -> -1 = 0

// Wildcard should work as fallback
match Some(false) with | Some(true) -> 100 | _ -> 0 = 0

// Variable binding in Some still works
match Some(true) with | Some(x) -> match x with | true -> 42 | false -> 0 | None -> -1 = 42

