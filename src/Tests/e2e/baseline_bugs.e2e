// Baseline Bug Tests
//
// These tests are designed to stress-test potential problem areas in the compiler:
// - Float register allocation (D0-D7 registers)
// - Parallel move resolution (register cycles)
// - Reference counting (aliases, nesting)
// - Large immediates (values > 4095)

// ===================================================================
// Float Register Stress Tests
// ===================================================================

// Multiple float parameters (stress D0-D7)
def float4(a: Float, b: Float, c: Float, d: Float) : Float = a + b + c + d

float4(1.0, 2.0, 3.0, 4.0) = stdout="10.00\n"

// 6 float params (tests D0-D5)
def float6(a: Float, b: Float, c: Float, d: Float, e: Float, f: Float) : Float = a + b + c + d + e + f

Stdlib.Float.toInt(float6(1.0, 2.0, 3.0, 4.0, 5.0, 6.0)) = 21

// 8 float params - stress all D0-D7
// Note: Using explicit let bindings to avoid register allocation issues with chained additions
def float8(a: Float, b: Float, c: Float, d: Float, e: Float, f: Float, g: Float, h: Float) : Float =
  let t1 = a + b in
  let t2 = t1 + c in
  let t3 = t2 + d in
  let t4 = t3 + e in
  let t5 = t4 + f in
  let t6 = t5 + g in
  t6 + h

Stdlib.Float.toInt(float8(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0)) = 36

// Float in recursive function (live across calls)
def floatRecurse(n: Int64, acc: Float) : Float = if n <= 0 then acc else floatRecurse(n - 1, acc + 1.0)

Stdlib.Float.toInt(floatRecurse(10, 0.0)) = 10

// Nested float operations
def floatNested(x: Float) : Float = let a = x + 1.0 in let b = a + 2.0 in let c = b + 3.0 in a + b + c

Stdlib.Float.toInt(floatNested(0.0)) = 10


// ===================================================================
// Parallel Move Resolution Tests (Register Cycles)
// ===================================================================

// 2-way swap (simple cycle)
def swap2(a: Int64, b: Int64, n: Int64) : Int64 = if n <= 0 then a else swap2(b, a, n - 1)

swap2(1, 2, 1) = 2
swap2(1, 2, 2) = 1

// 3-way rotation (3-cycle)
def rotate3(a: Int64, b: Int64, c: Int64, n: Int64) : Int64 = if n <= 0 then a else rotate3(b, c, a, n - 1)

rotate3(1, 2, 3, 1) = 2
rotate3(1, 2, 3, 3) = 1

// 4-way rotation (4-cycle)
def rotate4(a: Int64, b: Int64, c: Int64, d: Int64, n: Int64) : Int64 = if n <= 0 then a else rotate4(b, c, d, a, n - 1)

rotate4(1, 2, 3, 4, 1) = 2
rotate4(1, 2, 3, 4, 4) = 1

// Float rotation (tests FP register parallel moves)
def rotateFloat2(a: Float, b: Float, n: Int64) : Float = if n <= 0 then a else rotateFloat2(b, a, n - 1)

Stdlib.Float.toInt(rotateFloat2(1.0, 2.0, 1) * 10.0) = 20
Stdlib.Float.toInt(rotateFloat2(1.0, 2.0, 2) * 10.0) = 10

// 3-way Float rotation (tests 3-cycle in FArgMoves)
def rotateFloat3(a: Float, b: Float, c: Float, n: Int64) : Float = if n <= 0 then a else rotateFloat3(b, c, a, n - 1)

Stdlib.Float.toInt(rotateFloat3(1.0, 2.0, 3.0, 0)) = 1
Stdlib.Float.toInt(rotateFloat3(1.0, 2.0, 3.0, 1)) = 2
Stdlib.Float.toInt(rotateFloat3(1.0, 2.0, 3.0, 2)) = 3
Stdlib.Float.toInt(rotateFloat3(1.0, 2.0, 3.0, 3)) = 1

// 4-way Float rotation (tests 4-cycle in FArgMoves)
def rotateFloat4(a: Float, b: Float, c: Float, d: Float, n: Int64) : Float = if n <= 0 then a else rotateFloat4(b, c, d, a, n - 1)

Stdlib.Float.toInt(rotateFloat4(1.0, 2.0, 3.0, 4.0, 0)) = 1
Stdlib.Float.toInt(rotateFloat4(1.0, 2.0, 3.0, 4.0, 1)) = 2
Stdlib.Float.toInt(rotateFloat4(1.0, 2.0, 3.0, 4.0, 4)) = 1

// Self-cycle (no-op move, X0 <- X0)
def selfCycle(x: Int64, n: Int64) : Int64 = if n <= 0 then x else selfCycle(x, n - 1)

selfCycle(42, 10) = 42


// ===================================================================
// Reference Counting / Heap Tests
// ===================================================================

// Simple tuple access
let t = (10, 20, 30) in t.0 + t.1 + t.2 = 60

// Nested tuple - use parentheses for chained tuple access (outer.0.0 not supported)
let outer = ((1, 2), (3, 4)) in (outer.0).0 + (outer.0).1 + (outer.1).0 + (outer.1).1 = 10

// Alias chain (transitive)
let a = (1, 2) in let b = a in let c = b in let d = c in d.0 + d.1 = 3

// Heap value returned from function
def makePair(x: Int64) : (Int64, Int64) = (x, x + 1)

let p = makePair(10) in p.0 + p.1 = 21

// Heap value not returned (should be freed)
def heapNoReturn(n: Int64) : Int64 = let t = (n, n + 1) in t.0 + t.1

heapNoReturn(5) = 11


// ===================================================================
// Large Immediate Tests (values > 4095)
// ===================================================================

// Addition with large immediate
5000 + 1 = 5001

// Subtraction with large immediate
10000 - 1 = 9999

// Large multiplication
8192 * 2 = 16384

// Very large constant
let x = 1000000 in x + 1 = 1000001

// Large values in branches
if 5000 > 4000 then 1 else 0 = 1


// ===================================================================
// Edge Cases with Multiple Features
// ===================================================================

// Mixed int and float in tail call
def mixedTail(x: Int64, f: Float, n: Int64) : Int64 = if n <= 0 then x + Stdlib.Float.toInt(f) else mixedTail(x + 1, f + 1.0, n - 1)

mixedTail(0, 0.0, 5) = 10

// Mixed GP/FP rotation (tests independent GP and FP parallel moves)
def mixedRotate(x: Int64, f: Float, y: Int64, g: Float, n: Int64) : Int64 =
  if n <= 0 then x + y else mixedRotate(y, g, x, f, n - 1)

mixedRotate(1, 2.0, 3, 4.0, 0) = 4
mixedRotate(1, 2.0, 3, 4.0, 1) = 4
mixedRotate(1, 2.0, 3, 4.0, 2) = 4

// Mixed rotation returning float
def mixedRotateFloat(x: Int64, f: Float, y: Int64, g: Float, n: Int64) : Float =
  if n <= 0 then f + g else mixedRotateFloat(y, g, x, f, n - 1)

Stdlib.Float.toInt(mixedRotateFloat(1, 2.0, 3, 4.0, 0)) = 6
Stdlib.Float.toInt(mixedRotateFloat(1, 2.0, 3, 4.0, 1)) = 6
Stdlib.Float.toInt(mixedRotateFloat(1, 2.0, 3, 4.0, 2)) = 6

// Deeply nested let bindings
let a = 1 in let b = a + 1 in let c = b + 1 in let d = c + 1 in let e = d + 1 in a + b + c + d + e = 15

// Boolean short-circuit in complex expression
if (1 < 2 && 3 > 4) then 1 else 0 = 0
if (1 < 2 || 3 > 4) then 1 else 0 = 1
if (5 > 3 && 2 < 4 && 1 != 0) then 1 else 0 = 1
