// E2E tests for function definitions and calls (Phase 4)

// =====================================================
// Function Definitions (Milestone 3)
// =====================================================

// Test 1: Simplest function - no parameters, return constant
def main() : int = 42 = 42

// Test 2: Function with arithmetic
def main() : int = 10 + 32 = 42

// Test 3: Function with let binding
def main() : int = let x = 10 in let y = 32 in x + y = 42

// Test 4: Function with negation
def main() : int = -42 = -42

// Test 5: Function with if expression (true branch)
def main() : int = if 5 > 3 then 42 else 0 = 42

// Test 6: Function with if expression (false branch)
def main() : int = if 1 > 10 then 0 else 42 = 42

// Test 7: Function with multiplication
def main() : int = let a = 6 in let b = 7 in a * b = 42

// Test 8: Function with comparison
def main() : int = if 10 == 10 then 1 else 0 = 1

// Test 9: Function with boolean and
def main() : int = if true && false then 0 else 42 = 42

// Test 10: Function with nested if
def main() : int = if true then if false then 0 else 42 else 0 = 42

// =====================================================
// Function Calls (Milestone 4)
// =====================================================

// Test 11: Simple function call - double
def double(x: int) : int = x + x def main() : int = double(21) = 42

// Test 12: Function with two parameters
def add(a: int, b: int) : int = a + b def main() : int = add(20, 22) = 42

// Test 13: Function with three parameters
def sum3(a: int, b: int, c: int) : int = a + b + c def main() : int = sum3(10, 12, 20) = 42

// Test 14: Function with let binding in body
def compute(x: int, y: int) : int = let sum = x + y in sum * 2 def main() : int = compute(10, 11) = 42

// Test 15: Function with if expression
def max(a: int, b: int) : int = if a > b then a else b def main() : int = max(42, 10) = 42

// Test 16: Multiple function calls in expression
def inc(x: int) : int = x + 1 def main() : int = inc(inc(40)) = 42

// Test 17: Function with complex body
def calculate(x: int, y: int, z: int) : int = let sum = x + y in let product = sum * z in product - 1 def main() : int = calculate(2, 3, 9) = 44

// Test 18: Function returning comparison result as int
def isPositive(x: int) : int = if x > 0 then 1 else 0 def main() : int = isPositive(42) = 1

// Test 19: Calling function multiple times
def triple(x: int) : int = x * 3 def main() : int = triple(7) + triple(7) = 42

// Test 20: Four parameter function
def sum4(a: int, b: int, c: int, d: int) : int = a + b + c + d def main() : int = sum4(10, 11, 12, 9) = 42

// =====================================================
// Recursive Functions (Milestone 5)
// =====================================================

// Test 21: Factorial - classic recursion
def factorial(n: int) : int = if n <= 1 then 1 else n * factorial(n - 1) def main() : int = factorial(5) = 120

// Test 22: Fibonacci - double recursion
def fib(n: int) : int = if n <= 1 then n else fib(n - 1) + fib(n - 2) def main() : int = fib(10) = 55

// Test 23: GCD - two parameter recursion
def gcd(a: int, b: int) : int = if b == 0 then a else gcd(b, a - (a / b) * b) def main() : int = gcd(48, 18) = 6

// Test 24: Sum from 1 to N
def sumTo(n: int) : int = if n <= 0 then 0 else n + sumTo(n - 1) def main() : int = sumTo(10) = 55

// Test 25: Power function (x^n)
def power(x: int, n: int) : int = if n == 0 then 1 else x * power(x, n - 1) def main() : int = power(2, 6) = 64

// Test 26: Countdown (tests deep recursion with simple function)
def countdown(n: int) : int = if n <= 0 then 0 else countdown(n - 1) def main() : int = countdown(100) = 0

// Test 27: Even check via recursion
def isEven(n: int) : int = if n == 0 then 1 else if n == 1 then 0 else isEven(n - 2) def main() : int = isEven(42) = 1

// Test 28: Factorial of 6
def fact(n: int) : int = if n <= 1 then 1 else n * fact(n - 1) def main() : int = fact(6) = 720

// Test 29: Recursive with let binding
def recWithLet(n: int) : int = if n <= 0 then 0 else let prev = recWithLet(n - 1) in n + prev def main() : int = recWithLet(5) = 15

// Test 30: Ackermann-like (simplified)
def ack(m: int, n: int) : int = if m == 0 then n + 1 else if n == 0 then ack(m - 1, 1) else ack(m - 1, ack(m, n - 1)) def main() : int = ack(2, 3) = 9

// =====================================================
// Multiple Function Calls in Single Expression
// =====================================================
// These tests exercise the bug where 3+ function calls
// in a single expression produce wrong results due to
// SaveRegs/RestoreRegs stack offset corruption.

// Test 31: Three function calls - direct sum
def f(x: int) : int = x * 2 def main() : int = f(1) + f(2) + f(3) = 12

// Test 32: Four function calls
def g(x: int) : int = x + 1 def main() : int = g(1) + g(2) + g(3) + g(4) = 14

// Test 33: Tribonacci - triple recursive call
def trib(n: int) : int = if n <= 0 then 0 else if n == 1 then 1 else if n == 2 then 1 else trib(n - 1) + trib(n - 2) + trib(n - 3) def main() : int = trib(7) = 24

// Test 34: Three calls with different functions
def add1(x: int) : int = x + 1 def add2(x: int) : int = x + 2 def add3(x: int) : int = x + 3 def main() : int = add1(10) + add2(10) + add3(10) = 36

// Test 35: Three calls using let bindings (workaround - should work)
def h(x: int) : int = x * 2 def main() : int = let a = h(1) in let b = h(2) in let c = h(3) in a + b + c = 12
