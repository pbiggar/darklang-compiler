// E2E tests for closures (anonymous functions with captured environment)

// =====================================================
// Immediate Lambda Application (no captures)
// =====================================================

// Simple lambda with one parameter
((x: Int64) => x + 1)(5) = 6

// Lambda with two parameters
((x: Int64, y: Int64) => x + y)(10, 20) = 30

// Lambda with multiplication
((x: Int64, y: Int64) => x * y)(6, 7) = 42

// Lambda returning parameter directly
((x: Int64) => x)(42) = 42

// Lambda with three parameters
((a: Int64, b: Int64, c: Int64) => a + b + c)(1, 2, 3) = 6

// Lambda with subtraction
((x: Int64, y: Int64) => x - y)(50, 8) = 42

// Lambda with division
((x: Int64, y: Int64) => x / y)(84, 2) = 42

// Lambda with complex expression
((x: Int64) => x * 2 + x)(14) = 42

// =====================================================
// Lambda with Captured Variables
// =====================================================

// Capture single variable
let y = 10 in ((x: Int64) => x + y)(5) = 15

// Capture in multiplication
let factor = 7 in ((x: Int64) => x * factor)(6) = 42

// Capture multiple variables
let a = 1 in let b = 2 in ((x: Int64) => a + b + x)(39) = 42

// Capture and use in subtraction
let offset = 8 in ((x: Int64) => x - offset)(50) = 42

// Nested let with capture
let outer = 10 in let inner = 20 in ((x: Int64) => outer + inner + x)(12) = 42

// Capture computed value
let base = 20 in let bonus = base * 2 in ((x: Int64) => x + bonus)(2) = 42

// =====================================================
// Lambda with Booleans
// =====================================================

// Lambda returning bool
((x: Int64) => x > 0)(5) = true

// Lambda with comparison
((x: Int64, y: Int64) => x == y)(42, 42) = true

// Lambda with captured comparison
let threshold = 10 in ((x: Int64) => x >= threshold)(42) = true

// =====================================================
// Lambda in Expression Context
// =====================================================

// Lambda result in arithmetic
((x: Int64) => x * 2)(20) + 2 = 42

// Lambda as operand
1 + ((x: Int64) => x)(41) = 42

// Multiple lambda applications
((x: Int64) => x + 1)(20) + ((y: Int64) => y)(21) = 42

// Lambda in conditional test
if ((x: Int64) => x > 0)(5) then 42 else 0 = 42

// Lambda in let binding value
let result = ((x: Int64) => x * 2)(21) in result = 42

// =====================================================
// Nested Lambdas
// =====================================================

// Outer captures, inner uses
let y = 10 in ((x: Int64) => ((z: Int64) => x + y + z)(2))(30) = 42

// Chain of immediate applications
((x: Int64) => ((y: Int64) => x + y)(10))(32) = 42

// =====================================================
// Edge Cases
// =====================================================

// Lambda with zero (identity-ish)
((x: Int64) => x + 0)(42) = 42

// Lambda with one parameter used multiple times
((x: Int64) => x + x + x)(14) = 42

// Capture shadowed by parameter
let x = 100 in ((x: Int64) => x + 2)(40) = 42

// =====================================================
// First-Class Functions (stored in variables)
// =====================================================

// Simple lambda stored in variable
let f = (x: Int64) => x + 1 in f(5) = 6

// Two-parameter lambda in variable
let add = (x: Int64, y: Int64) => x + y in add(10, 32) = 42

// Lambda with capture stored in variable
let factor = 6 in let mul = (x: Int64) => x * factor in mul(7) = 42

// Multiple calls to same stored lambda
let double = (x: Int64) => x * 2 in double(10) + double(11) = 42

// Stored lambda with subtraction
let sub = (x: Int64, y: Int64) => x - y in sub(50, 8) = 42

// Lambda stored then used with captured values
let base = 10 in let addBase = (x: Int64) => x + base in addBase(32) = 42

// Multiple lambdas stored in separate variables
let inc = (x: Int64) => x + 1 in let dec = (x: Int64) => x - 1 in inc(20) + dec(22) = 42

// Nested captures with stored lambda
let a = 5 in let b = 10 in let sum = (x: Int64) => a + b + x in sum(27) = 42

// Stored lambda returning bool
let isPositive = (x: Int64) => x > 0 in isPositive(42) = true

// Lambda used in conditional after storage
let check = (x: Int64) => x > 0 in if check(5) then 42 else 0 = 42

// Multiple uses of same lambda with different args
let triple = (x: Int64) => x * 3 in triple(10) + triple(4) = 42

// Lambda in arithmetic context after storage
let sq = (x: Int64) => x * x in sq(6) + 6 = 42

// =====================================================
// Closures Capturing Float Values
// =====================================================

// Capture float in arithmetic
let f = 3.14 in ((x: Float) => f + x)(1.0) = 4.14

// Capture multiple floats
let a = 1.5 in let b = 2.5 in ((x: Float) => a + b + x)(1.0) = 5.00

// Capture float, use in multiplication
let scale = 2.0 in ((x: Float) => x * scale)(3.5) = 7.00

// =====================================================
// Closures Capturing String Values
// =====================================================

// Capture string for concatenation
let prefix = "Hello" in ((s: String) => prefix ++ " " ++ s)("World") = "Hello World"

// Capture multiple strings
let a = "one" in let b = "two" in ((x: String) => a ++ " " ++ b ++ " " ++ x)("three") = one two three

// =====================================================
// Closures Capturing Tuples
// =====================================================

// Capture tuple, access elements
let t = (10, 20) in ((x: Int64) => t.0 + t.1 + x)(5) = 35

// Capture 3-tuple
let t = (1, 2, 3) in ((x: Int64) => t.0 + t.1 + t.2 + x)(4) = 10

// Capture tuple, use in arithmetic
let pair = (5, 3) in ((x: Int64) => (pair.0 - pair.1) * x)(7) = 14

// =====================================================
// Closures Capturing Records
// =====================================================

// Capture record, access field
type Point = { x: Int64, y: Int64 }
let p = Point { x = 3, y = 4 } in ((n: Int64) => p.x + p.y + n)(3) = 10

// Capture record, use both fields
type Vec = { dx: Int64, dy: Int64 }
let v = Vec { dx = 5, dy = 10 } in ((scale: Int64) => v.dx * scale + v.dy)(2) = 20

// =====================================================
// Closures Capturing Sum Types
// =====================================================

// Capture Option-like value
type Opt = None2 | Some2 of Int64
let opt = Some2(42) in ((x: Int64) => match opt with | Some2(v) -> v + x | None2 -> 0)(8) = 50
let opt = None2 in ((x: Int64) => match opt with | Some2(v) -> v + x | None2 -> x)(8) = 8

// =====================================================
// Many Captures (Testing Capture Slot Limits)
// =====================================================

// 5 captures
let a = 1 in let b = 2 in let c = 3 in let d = 4 in let e = 5 in ((x: Int64) => a + b + c + d + e + x)(5) = 20

// 6 captures
let a = 1 in let b = 2 in let c = 3 in let d = 4 in let e = 5 in let f = 6 in ((x: Int64) => a + b + c + d + e + f + x)(4) = 25

// 7 captures
let a = 1 in let b = 2 in let c = 3 in let d = 4 in let e = 5 in let f = 6 in let g = 7 in ((x: Int64) => a + b + c + d + e + f + g + x)(8) = 36

// 8 captures
let a = 1 in let b = 2 in let c = 3 in let d = 4 in let e = 5 in let f = 6 in let g = 7 in let h = 8 in ((x: Int64) => a + b + c + d + e + f + g + h + x)(1) = 37

// =====================================================
// Mixed Type Captures
// =====================================================

// Capture int and float
let i = 10 in let f = 2.5 in ((x: Int64) => Stdlib.Int64.toFloat(i + x) + f)(5) = 17.50

// Capture bool and int
let flag = true in let n = 42 in ((x: Int64) => if flag then n + x else 0)(8) = 50
