// E2E tests for closures (anonymous functions with captured environment)

// =====================================================
// Immediate Lambda Application (no captures)
// =====================================================

// Simple lambda with one parameter
((x: Int64) => x + 1)(5) = 6

// Lambda with two parameters
((x: Int64, y: Int64) => x + y)(10, 20) = 30

// Lambda with multiplication
((x: Int64, y: Int64) => x * y)(6, 7) = 42

// Lambda returning parameter directly
((x: Int64) => x)(42) = 42

// Lambda with three parameters
((a: Int64, b: Int64, c: Int64) => a + b + c)(1, 2, 3) = 6

// Lambda with subtraction
((x: Int64, y: Int64) => x - y)(50, 8) = 42

// Lambda with division
((x: Int64, y: Int64) => x / y)(84, 2) = 42

// Lambda with complex expression
((x: Int64) => x * 2 + x)(14) = 42

// =====================================================
// Lambda with Captured Variables
// =====================================================

// Capture single variable
let y = 10 in ((x: Int64) => x + y)(5) = 15

// Capture in multiplication
let factor = 7 in ((x: Int64) => x * factor)(6) = 42

// Capture multiple variables
let a = 1 in let b = 2 in ((x: Int64) => a + b + x)(39) = 42

// Capture and use in subtraction
let offset = 8 in ((x: Int64) => x - offset)(50) = 42

// Nested let with capture
let outer = 10 in let inner = 20 in ((x: Int64) => outer + inner + x)(12) = 42

// Capture computed value
let base = 20 in let bonus = base * 2 in ((x: Int64) => x + bonus)(2) = 42

// =====================================================
// Lambda with Booleans
// =====================================================

// Lambda returning bool
((x: Int64) => x > 0)(5) = stdout="true\n"

// Lambda with comparison
((x: Int64, y: Int64) => x == y)(42, 42) = stdout="true\n"

// Lambda with captured comparison
let threshold = 10 in ((x: Int64) => x >= threshold)(42) = stdout="true\n"

// =====================================================
// Lambda in Expression Context
// =====================================================

// Lambda result in arithmetic
((x: Int64) => x * 2)(20) + 2 = 42

// Lambda as operand
1 + ((x: Int64) => x)(41) = 42

// Multiple lambda applications
((x: Int64) => x + 1)(20) + ((y: Int64) => y)(21) = 42

// Lambda in conditional test
if ((x: Int64) => x > 0)(5) then 42 else 0 = 42

// Lambda in let binding value
let result = ((x: Int64) => x * 2)(21) in result = 42

// =====================================================
// Nested Lambdas
// =====================================================

// Outer captures, inner uses
let y = 10 in ((x: Int64) => ((z: Int64) => x + y + z)(2))(30) = 42

// Chain of immediate applications
((x: Int64) => ((y: Int64) => x + y)(10))(32) = 42

// =====================================================
// Edge Cases
// =====================================================

// Lambda with zero (identity-ish)
((x: Int64) => x + 0)(42) = 42

// Lambda with one parameter used multiple times
((x: Int64) => x + x + x)(14) = 42

// Capture shadowed by parameter
let x = 100 in ((x: Int64) => x + 2)(40) = 42

// =====================================================
// First-Class Functions (stored in variables)
// =====================================================

// Simple lambda stored in variable
let f = (x: Int64) => x + 1 in f(5) = 6

// Two-parameter lambda in variable
let add = (x: Int64, y: Int64) => x + y in add(10, 32) = 42

// Lambda with capture stored in variable
let factor = 6 in let mul = (x: Int64) => x * factor in mul(7) = 42

// Multiple calls to same stored lambda
let double = (x: Int64) => x * 2 in double(10) + double(11) = 42

// Stored lambda with subtraction
let sub = (x: Int64, y: Int64) => x - y in sub(50, 8) = 42

// Lambda stored then used with captured values
let base = 10 in let addBase = (x: Int64) => x + base in addBase(32) = 42

// Multiple lambdas stored in separate variables
let inc = (x: Int64) => x + 1 in let dec = (x: Int64) => x - 1 in inc(20) + dec(22) = 42

// Nested captures with stored lambda
let a = 5 in let b = 10 in let sum = (x: Int64) => a + b + x in sum(27) = 42

// Stored lambda returning bool
let isPositive = (x: Int64) => x > 0 in isPositive(42) = stdout="true\n"

// Lambda used in conditional after storage
let check = (x: Int64) => x > 0 in if check(5) then 42 else 0 = 42

// Multiple uses of same lambda with different args
let triple = (x: Int64) => x * 3 in triple(10) + triple(4) = 42

// Lambda in arithmetic context after storage
let sq = (x: Int64) => x * x in sq(6) + 6 = 42
