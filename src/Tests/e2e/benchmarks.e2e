// Benchmark E2E Tests
//
// These tests verify that the benchmark implementations work correctly
// using very small inputs. The goal is correctness testing, not performance.
//
// This file uses the multi-line definition feature: function definitions
// accumulate and are prepended to all subsequent test expressions.


// ===================================================================
// Fibonacci (fib)
// ===================================================================

def fib(n: Int64) : Int64 =
    if n <= 1 then n
    else fib(n - 1) + fib(n - 2)

fib(0) = 0
fib(1) = 1
fib(5) = 5
fib(10) = 55


// ===================================================================
// Factorial (factorial)
// ===================================================================

def factorial(n: Int64) : Int64 =
    if n <= 1 then 1
    else n * factorial(n - 1)

factorial(0) = 1
factorial(1) = 1
factorial(5) = 120
factorial(6) = 720


// ===================================================================
// Sum to N (sum_to_n) - tail recursive accumulator version
// ===================================================================

def sumTo(n: Int64, acc: Int64) : Int64 =
    if n <= 0 then acc
    else sumTo(n - 1, acc + n)

sumTo(1, 0) = 1
sumTo(5, 0) = 15
sumTo(10, 0) = 55
sumTo(100, 0) = 5050


// ===================================================================
// Ackermann (ackermann)
// ===================================================================

def ackermann(m: Int64, n: Int64) : Int64 =
    if m == 0 then n + 1
    else if n == 0 then ackermann(m - 1, 1)
    else ackermann(m - 1, ackermann(m, n - 1))

ackermann(0, 0) = 1
ackermann(0, 5) = 6
ackermann(1, 0) = 2
ackermann(1, 5) = 7
ackermann(2, 3) = 9
ackermann(3, 3) = 61


// ===================================================================
// Binary Trees (binary_trees) - count nodes in complete binary tree
// ===================================================================

def countTree(depth: Int64) : Int64 =
    if depth <= 0 then 1
    else 1 + countTree(depth - 1) + countTree(depth - 1)

countTree(0) = 1
countTree(1) = 3
countTree(2) = 7
countTree(3) = 15
countTree(4) = 31


// ===================================================================
// Collatz (collatz) - count steps in Collatz sequence
// ===================================================================

def collatzSteps(n: Int64, steps: Int64) : Int64 =
    if n == 1 then steps
    else if n % 2 == 0 then collatzSteps(n / 2, steps + 1)
    else collatzSteps(3 * n + 1, steps + 1)

collatzSteps(1, 0) = 0
collatzSteps(2, 0) = 1
collatzSteps(4, 0) = 2
collatzSteps(6, 0) = 8
collatzSteps(7, 0) = 16

// Sum of Collatz steps for range 1..n
def sumCollatzRange(i: Int64, limit: Int64, total: Int64) : Int64 =
    if i > limit then total
    else sumCollatzRange(i + 1, limit, total + collatzSteps(i, 0))

sumCollatzRange(1, 5, 0) = 15


// ===================================================================
// Primes (primes) - count primes up to n using trial division
// ===================================================================

def isqrt(n: Int64, guess: Int64) : Int64 =
    if guess * guess > n then guess - 1
    else if (guess + 1) * (guess + 1) > n then guess
    else isqrt(n, guess + 1)

def isDivisible(n: Int64, d: Int64, limit: Int64) : Bool =
    if d > limit then false
    else if n - (n / d) * d == 0 then true
    else isDivisible(n, d + 1, limit)

def isPrime(n: Int64) : Bool =
    if n < 2 then false
    else if n == 2 then true
    else if n - (n / 2) * 2 == 0 then false
    else
        let limit = isqrt(n, 1) in
        if isDivisible(n, 3, limit) then false else true

def countPrimes(n: Int64, count: Int64) : Int64 =
    if n <= 1 then count
    else if isPrime(n) then countPrimes(n - 1, count + 1)
    else countPrimes(n - 1, count)

countPrimes(2, 0) = 1
countPrimes(10, 0) = 4
countPrimes(20, 0) = 8


// ===================================================================
// Tak (tak) - Takeuchi function
// ===================================================================

def tak(x: Int64, y: Int64, z: Int64) : Int64 =
    if x <= y then z
    else tak(tak(x - 1, y, z), tak(y - 1, z, x), tak(z - 1, x, y))

tak(1, 1, 1) = 1
tak(3, 2, 1) = 2
tak(6, 4, 2) = 3
tak(7, 4, 2) = 4


// ===================================================================
// Leibniz Pi (leibniz) - compute pi using Leibniz formula
// ===================================================================

def leibnizLoop(i: Int64, n: Int64, sum: Float, sign: Float) : Float =
    if i >= n then sum * 4.0
    else
        let term = sign / Stdlib.Int64.toFloat(2 * i + 1) in
        leibnizLoop(i + 1, n, sum + term, Stdlib.Float.negate(sign))

def leibnizPi(n: Int64) : Float =
    leibnizLoop(0, n, 0.0, 1.0)

Stdlib.Float.toInt(leibnizPi(100) * 100.0) = 313
Stdlib.Float.toInt(leibnizPi(1000) * 1000.0) = 3140


// ===================================================================
// Pi Sum (pisum) - partial sum of 1/k^2 series
// ===================================================================

def innerSum(k: Int64, n: Int64, acc: Float) : Float =
    if k > n then acc
    else
        let kf = Stdlib.Int64.toFloat(k) in
        innerSum(k + 1, n, acc + 1.0 / (kf * kf))

def pisum(rounds: Int64, n: Int64, lastResult: Float) : Float =
    if rounds <= 0 then lastResult
    else pisum(rounds - 1, n, innerSum(1, n, 0.0))

Stdlib.Float.toInt(pisum(1, 10, 0.0) * 1000000.0) = 1549767


// ===================================================================
// N-Queens (nqueen) - count solutions using bit manipulation
// ===================================================================

// Solve N-Queens using bitmasks for columns and diagonals
// avail: bitmask of available positions to try in current row
// count: accumulated solution count
def nqueenSolve(allOnes: Int64, cols: Int64, diag1: Int64, diag2: Int64, avail: Int64, count: Int64) : Int64 =
    if avail == 0 then count
    else
        let pos = avail & (0 - avail) in
        let newAvail = avail - pos in
        let newCols = Int64.bitwiseOr(cols, pos) in
        let subCount =
            if newCols == allOnes then 1
            else
                let newDiag1 = (Int64.bitwiseOr(diag1, pos)) << 1 in
                let newDiag2 = (Int64.bitwiseOr(diag2, pos)) >> 1 in
                let blocked = Int64.bitwiseOr(Int64.bitwiseOr(newCols, newDiag1), newDiag2) in
                let nextRowAvail = allOnes & (~~~blocked) in
                nqueenSolve(allOnes, newCols, newDiag1, newDiag2, nextRowAvail, 0) in
        nqueenSolve(allOnes, cols, diag1, diag2, newAvail, count + subCount)

def nqueen(n: Int64) : Int64 =
    let allOnes = (1 << n) - 1 in
    nqueenSolve(allOnes, 0, 0, 0, allOnes, 0)

nqueen(1) = 1
nqueen(4) = 2
nqueen(5) = 10
nqueen(6) = 4
nqueen(7) = 40
nqueen(8) = 92


// ===================================================================
// Hello World (helloworld) - simplest benchmark
// ===================================================================

42 = 42


// ===================================================================
// BLOCKED BENCHMARKS - require compiler bug fixes
// ===================================================================
//
// The following benchmarks cannot be implemented due to compiler bugs:
//
// 1. nsieve - Requires List.repeat + List.setAt which has memory corruption bug
//    Bug: Setting index 6 then 10 on a List.repeat<Bool> list causes index 13
//    to become corrupted.
//
// 2. spectral_norm - Requires List.getAt<Float> which returns wrong values
//    Bug: Extracting Float from Option<Float> via pattern match returns 0
//    instead of the actual value.
//
// 3. matmul - Blocked by same issues as nsieve (needs List.setAt for 2D arrays)
//
// Additional bug found:
// - Pattern matching on Option<Bool> with literal patterns (Some(true), Some(false))
//   doesn't work correctly - Some(false) matches the Some(true) pattern.
