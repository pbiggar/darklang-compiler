// Tests imported from Dark language test suite
// Source: https://github.com/darklang/dark/blob/main/backend/testfiles/execution/language/custom-data/enums.dark
//
// ALL TESTS INCLUDED - no filtering or removal
// Tests may fail if features are not yet implemented

// ===================================================================
// Simple Enums (No Payload)
// NOTE: Commented out - requires enum equality support
// ===================================================================

// Basic enum definition and equality
// type Color = Red | Green | Blue Red == Red = stdout="true\n"
// type Color = Red | Green | Blue Green == Green = stdout="true\n"
// type Color = Red | Green | Blue Blue == Blue = stdout="true\n"

// Different variants are not equal
// type Color = Red | Green | Blue Red == Green = stdout="false\n"
// type Color = Red | Green | Blue Red == Blue = stdout="false\n"
// type Color = Red | Green | Blue Green == Blue = stdout="false\n"

// Inequality
// type Color = Red | Green | Blue Red != Green = stdout="true\n"
// type Color = Red | Green | Blue Red != Red = stdout="false\n"

// ===================================================================
// Enum Pattern Matching
// ===================================================================

// Match on simple enum
type Color = Red | Green | Blue match Red with | Red -> 1 | Green -> 2 | Blue -> 3 = 1
type Color = Red | Green | Blue match Green with | Red -> 1 | Green -> 2 | Blue -> 3 = 2
type Color = Red | Green | Blue match Blue with | Red -> 1 | Green -> 2 | Blue -> 3 = 3

// Wildcard fallback
type Color = Red | Green | Blue match Green with | Red -> 1 | _ -> 99 = 99
type Color = Red | Green | Blue match Blue with | Red -> 1 | Green -> 2 | _ -> 100 = 100

// ===================================================================
// Enums with Single Payload
// NOTE: Equality tests commented out - requires enum equality support
// ===================================================================

// Option-like type
// type MyOption = MyNone | MySome of Int64 MySome(42) == MySome(42) = stdout="true\n"
// type MyOption = MyNone | MySome of Int64 MySome(42) == MySome(43) = stdout="false\n"
// type MyOption = MyNone | MySome of Int64 MyNone == MyNone = stdout="true\n"
// type MyOption = MyNone | MySome of Int64 MySome(42) == MyNone = stdout="false\n"

// Extract payload
type MyOption = MyNone | MySome of Int64 match MySome(42) with | MySome(x) -> x | MyNone -> 0 = 42
type MyOption = MyNone | MySome of Int64 match MyNone with | MySome(x) -> x | MyNone -> 99 = 99

// Use extracted payload in expression
type MyOption = MyNone | MySome of Int64 match MySome(10) with | MySome(x) -> x * 2 | MyNone -> 0 = 20
type MyOption = MyNone | MySome of Int64 match MySome(5) with | MySome(x) -> x + 10 | MyNone -> 0 = 15

// ===================================================================
// Result-like Type
// NOTE: Equality tests commented out - requires enum equality support
// ===================================================================

// type MyResult = MyOk of Int64 | MyErr of Int64 MyOk(42) == MyOk(42) = stdout="true\n"
// type MyResult = MyOk of Int64 | MyErr of Int64 MyOk(42) == MyOk(43) = stdout="false\n"
// type MyResult = MyOk of Int64 | MyErr of Int64 MyOk(42) == MyErr(42) = stdout="false\n"
// type MyResult = MyOk of Int64 | MyErr of Int64 MyErr(1) == MyErr(1) = stdout="true\n"

// Match on MyResult
type MyResult = MyOk of Int64 | MyErr of Int64 match MyOk(100) with | MyOk(v) -> v | MyErr(e) -> 0 - e = 100
type MyResult = MyOk of Int64 | MyErr of Int64 match MyErr(5) with | MyOk(v) -> v | MyErr(e) -> 0 - e = -5

// ===================================================================
// Either Type (Two Payload Variants)
// NOTE: Equality tests commented out - requires enum equality support
// ===================================================================

// type Either = Left of Int64 | Right of Int64 Left(5) == Left(5) = stdout="true\n"
// type Either = Left of Int64 | Right of Int64 Right(5) == Right(5) = stdout="true\n"
// type Either = Left of Int64 | Right of Int64 Left(5) == Right(5) = stdout="false\n"

// Pattern match Either
type Either = Left of Int64 | Right of Int64 match Left(10) with | Left(x) -> x | Right(y) -> y * 2 = 10
type Either = Left of Int64 | Right of Int64 match Right(10) with | Left(x) -> x | Right(y) -> y * 2 = 20

// ===================================================================
// Enums in Variables
// ===================================================================

// Store in variable
type Color = Red | Green | Blue let c = Red in match c with | Red -> 1 | _ -> 0 = 1
type MyOption = MyNone | MySome of Int64 let opt = MySome(42) in match opt with | MySome(x) -> x | MyNone -> 0 = 42

// Return from if
type Color = Red | Green | Blue let c = if true then Red else Blue in match c with | Red -> 1 | Blue -> 2 | _ -> 0 = 1
type Color = Red | Green | Blue let c = if false then Red else Blue in match c with | Red -> 1 | Blue -> 2 | _ -> 0 = 2

// ===================================================================
// Nested Pattern Matching with Enums
// ===================================================================

// Nested match
type MyOption = MyNone | MySome of Int64 match MySome(5) with | MySome(x) -> match x with | 5 -> 100 | _ -> 0 | MyNone -> 0 = 100

// Enum in if body
type MyOption = MyNone | MySome of Int64 match MySome(10) with | MySome(x) -> if x > 5 then x * 2 else x | MyNone -> 0 = 20

// ===================================================================
// Multiple Variants (More than 2 or 3)
// ===================================================================

type Direction = North | East | South | West match North with | North -> 0 | East -> 90 | South -> 180 | West -> 270 = 0
type Direction = North | East | South | West match East with | North -> 0 | East -> 90 | South -> 180 | West -> 270 = 90
type Direction = North | East | South | West match South with | North -> 0 | East -> 90 | South -> 180 | West -> 270 = 180
type Direction = North | East | South | West match West with | North -> 0 | East -> 90 | South -> 180 | West -> 270 = 270

// ===================================================================
// Enum with Let in Body
// ===================================================================

type MyOption = MyNone | MySome of Int64 match MySome(5) with | MySome(x) -> let y = x * 2 in y + 1 | MyNone -> 0 = 11
type MyResult = MyOk of Int64 | MyErr of Int64 match MyOk(10) with | MyOk(v) -> let doubled = v * 2 in doubled | MyErr(_) -> 0 = 20

// ===================================================================
// Enum Construction in Expressions
// ===================================================================

// Construct with computed value
type MyOption = MyNone | MySome of Int64 let x = 20 in let opt = MySome(x + 22) in match opt with | MySome(v) -> v | MyNone -> 0 = 42

// Conditional construction
type MyOption = MyNone | MySome of Int64 let x = 5 in let opt = if x > 0 then MySome(x) else MyNone in match opt with | MySome(v) -> v | MyNone -> 0 = 5
type MyOption = MyNone | MySome of Int64 let x = 0 - 5 in let opt = if x > 0 then MySome(x) else MyNone in match opt with | MySome(v) -> v | MyNone -> 99 = 99

// ===================================================================
// Complex Enum Usage
// NOTE: Printing tests commented out - requires enum printing support
// ===================================================================

// Enum printing (pretty-printing of ADT values)
// type MyOption = MyNone | MySome of Int64 MySome(20) = stdout="MySome(20)\n"
// type MyOption = MyNone | MySome of Int64 MyNone = stdout="MyNone\n"
// type Color = Red | Green | Blue Red = stdout="Red\n"
// type Color = Red | Green | Blue Green = stdout="Green\n"

// Map-like behavior (manual)
type MyOption = MyNone | MySome of Int64 let opt = MySome(10) in match opt with | MySome(x) -> match MySome(x * 2) with | MySome(v) -> v | MyNone -> 0 | MyNone -> 0 = 20

// Chained matching
type MyOption = MyNone | MySome of Int64 let opt1 = MySome(5) in match opt1 with | MySome(x) -> match MySome(x + 5) with | MySome(y) -> y | MyNone -> 0 | MyNone -> 0 = 10

// ===================================================================
// Edge Cases
// NOTE: Equality test commented out - requires enum equality support
// ===================================================================

// Zero payload
// type MyOption = MyNone | MySome of Int64 MySome(0) == MySome(0) = stdout="true\n"
type MyOption = MyNone | MySome of Int64 match MySome(0) with | MySome(x) -> x + 1 | MyNone -> 0 = 1

// Negative payload (via subtraction)
type MyOption = MyNone | MySome of Int64 match MySome(0 - 5) with | MySome(x) -> x | MyNone -> 0 = -5

// Large payload
type MyOption = MyNone | MySome of Int64 match MySome(1000000) with | MySome(x) -> x | MyNone -> 0 = 1000000

// ===================================================================
// Dark Enum Tests (from enums.dark)
// NOTE: Commented out - requires Stdlib, Builtin.testRuntimeError, and module syntax support
// ===================================================================

// Stdlib.Option type
// Stdlib.Option.Option.None = stdout="Stdlib.Option.Option.None\n"
// ((Stdlib.List.head []) == Stdlib.Option.Option.None) = stdout="true\n"
// (Stdlib.List.head []) = stdout="Stdlib.Option.Option.None\n"

// ===================================================================
// Error Propagation in Enums
// NOTE: Commented out - requires Builtin.testRuntimeError support
// ===================================================================

// Stdlib.Result.Result.Ok(Builtin.testRuntimeError "err") = Builtin.testDerrorMessage "Uncaught exception: err"
// Stdlib.Option.Option.Some(Builtin.testRuntimeError "err") = Builtin.testDerrorMessage "Uncaught exception: err"
// Stdlib.Result.Result.Error(Builtin.testRuntimeError "err") = Builtin.testDerrorMessage "Uncaught exception: err"

// ===================================================================
// Enum Field Count Errors
// NOTE: Commented out - requires Builtin.testDerrorMessage support
// ===================================================================

// Stdlib.Option.Option.None 5 = Builtin.testDerrorMessage "Expected 0 fields in Darklang.Stdlib.Option.Option.`None`, but got 1"
// Stdlib.Option.Option.Some(5, 6) = Builtin.testDerrorMessage "Expected 1 fields in Darklang.Stdlib.Option.Option.`Some`, but got 2"

// ===================================================================
// User-Defined Enum Errors
// NOTE: Commented out - requires module syntax and Builtin.testDerrorMessage support
// ===================================================================

// type MyEnum = A | B | C of String

// MyEnum.D = Builtin.testDerrorMessage "There is no case named `D` in Errors.User.MyEnum"
// MyEnum.C = Builtin.testDerrorMessage "Expected 1 fields in Errors.User.MyEnum.`C`, but got 0"
// MyEnum.B 5L = Builtin.testDerrorMessage "Expected 0 fields in Errors.User.MyEnum.`B`, but got 1"

// ===================================================================
// Enum Pattern Matching with Field Extraction
// NOTE: Commented out - requires module syntax
// ===================================================================

// (match MyEnum.C "test" with | C v -> v) = "test"
// (match MyEnum.C "test" with | 5 -> "unmatched because it's not an int" | C v -> v) = "test"
// (match MyEnum.C "test" with | C -> "unmatched because we didn't provide a space for the field") = Builtin.testDerrorMessage "No matching case found for value Errors.User.MyEnum.C(\"test\") in match expression"
// (match MyEnum.C "test" with | D -> "unmatched because case name does not exist" | C _ -> 2) = 2
// (MyEnum.C 5L) = Builtin.testDerrorMessage "Failed to create enum. Expected String for field 0 in `C`, but got Int64 (5)"

// ===================================================================
// Enum Equality Tests
// NOTE: Commented out - requires module syntax
// ===================================================================

// type AorB = A | B

// (let a = AorB.A let b = AorB.B a == b) = stdout="false\n"
// (let a1 = AorB.A let a2 = AorB.A a1 == a2) = stdout="true\n"
// (AorB.A == AorB.A) = stdout="true\n"
// (AorB.A == AorB.B) = stdout="false\n"

// ===================================================================
// Stdlib.List.unique with Enums
// NOTE: Commented out - requires Stdlib support
// ===================================================================

// Stdlib.List.unique_v0 [ AorB.A; AorB.B; AorB.A; AorB.A; AorB.B ] = stdout="[AorB.A, AorB.B]\n"

// ===================================================================
// Nested Enum Types
// NOTE: Commented out - requires module syntax and Int64 suffix
// ===================================================================

// type CorD = C of Int64 | D of AorB

// (CorD.C 5L != CorD.D AorB.B) = stdout="true\n"
// (CorD.D AorB.A == CorD.D AorB.A) = stdout="true\n"

// ===================================================================
// Mixed Case Enums (some with payloads, some without)
// NOTE: Commented out - requires module syntax and error testing
// ===================================================================

// type EnumOfMixedCases = W | X of String | Y of Int64 | Z of String * Int64

// (EnumOfMixedCases.W == (EnumOfMixedCases.Y 1L)) = stdout="false\n"
// (EnumOfMixedCases.Y 1L == EnumOfMixedCases.Y 1L) = stdout="true\n"
// EnumOfMixedCases.X 1L = Builtin.testDerrorMessage "Failed to create enum. Expected String for field 0 in `X`, but got Int64 (1)"
// EnumOfMixedCases.Y "test" = Builtin.testDerrorMessage "Failed to create enum. Expected Int64 for field 0 in `Y`, but got String (\"test\")"
// EnumOfMixedCases.Z 1L = Builtin.testDerrorMessage "Expected 2 fields in MixedCases.EnumOfMixedCases.`Z`, but got 1"
// EnumOfMixedCases.Z(Builtin.testRuntimeError "1", Builtin.testRuntimeError "2") = Builtin.testDerrorMessage "Uncaught exception: 1"

// ===================================================================
// Tuple-like Enum vs Tuple Field Enums
// NOTE: Commented out - requires module syntax and error testing
// ===================================================================

// type Tuples = NotTuple of String * Int64 | Tuple of (String * Int64)

// (match Tuples.NotTuple("printer broke", 7L) with | NotTuple(reason, 7L) -> reason) = "printer broke"
// (Tuples.NotTuple(("printer broke", 7L))) = Builtin.testDerrorMessage "Expected 2 fields in TuplesVsNonTuples.Tuples.`NotTuple`, but got 1"
// (match Tuples.Tuple(("printer broke", 7L)) with | Tuple((reason, 7L)) -> reason) = "printer broke"
// Tuples.Tuple("printer broke", 7L) = Builtin.testDerrorMessage "Expected 1 fields in TuplesVsNonTuples.Tuples.`Tuple`, but got 2"

// ===================================================================
// Recursive Enum Types (Tree)
// NOTE: Commented out - requires module syntax
// ===================================================================

// type Tree = Leaf | Node of Tree * Tree

// Tree.Node(Tree.Leaf, Tree.Leaf) = stdout="Tree.Node(Tree.Leaf, Tree.Leaf)\n"
// (Tree.Node(Tree.Leaf, Tree.Leaf) == Tree.Node(Tree.Leaf, Tree.Node(Tree.Leaf, Tree.Leaf))) = stdout="false\n"
