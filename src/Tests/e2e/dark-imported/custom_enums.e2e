// Tests imported from Dark language test suite
// Source: https://github.com/darklang/dark/blob/main/backend/testfiles/execution/language/custom-data/enums.dark
//
// ALL TESTS INCLUDED - no filtering or removal
// Tests may fail if features are not yet implemented

// ===================================================================
// Simple Enums (No Payload)
// NOTE: Commented out - requires enum equality support
// ===================================================================

// Basic enum definition and equality
// type Color = Red | Green | Blue Red == Red = stdout="true\n"
// type Color = Red | Green | Blue Green == Green = stdout="true\n"
// type Color = Red | Green | Blue Blue == Blue = stdout="true\n"

// Different variants are not equal
// type Color = Red | Green | Blue Red == Green = stdout="false\n"
// type Color = Red | Green | Blue Red == Blue = stdout="false\n"
// type Color = Red | Green | Blue Green == Blue = stdout="false\n"

// Inequality
// type Color = Red | Green | Blue Red != Green = stdout="true\n"
// type Color = Red | Green | Blue Red != Red = stdout="false\n"

// ===================================================================
// Enum Pattern Matching
// ===================================================================

// Match on simple enum
type Color = Red | Green | Blue match Red with | Red -> 1 | Green -> 2 | Blue -> 3 = 1
type Color = Red | Green | Blue match Green with | Red -> 1 | Green -> 2 | Blue -> 3 = 2
type Color = Red | Green | Blue match Blue with | Red -> 1 | Green -> 2 | Blue -> 3 = 3

// Wildcard fallback
type Color = Red | Green | Blue match Green with | Red -> 1 | _ -> 99 = 99
type Color = Red | Green | Blue match Blue with | Red -> 1 | Green -> 2 | _ -> 100 = 100

// ===================================================================
// Enums with Single Payload
// NOTE: Equality tests commented out - requires enum equality support
// ===================================================================

// Option-like type
// type Option = None | Some of Int64 Some(42) == Some(42) = stdout="true\n"
// type Option = None | Some of Int64 Some(42) == Some(43) = stdout="false\n"
// type Option = None | Some of Int64 None == None = stdout="true\n"
// type Option = None | Some of Int64 Some(42) == None = stdout="false\n"

// Extract payload
type Option = None | Some of Int64 match Some(42) with | Some(x) -> x | None -> 0 = 42
type Option = None | Some of Int64 match None with | Some(x) -> x | None -> 99 = 99

// Use extracted payload in expression
type Option = None | Some of Int64 match Some(10) with | Some(x) -> x * 2 | None -> 0 = 20
type Option = None | Some of Int64 match Some(5) with | Some(x) -> x + 10 | None -> 0 = 15

// ===================================================================
// Result-like Type
// NOTE: Equality tests commented out - requires enum equality support
// ===================================================================

// type Result = Ok of Int64 | Err of Int64 Ok(42) == Ok(42) = stdout="true\n"
// type Result = Ok of Int64 | Err of Int64 Ok(42) == Ok(43) = stdout="false\n"
// type Result = Ok of Int64 | Err of Int64 Ok(42) == Err(42) = stdout="false\n"
// type Result = Ok of Int64 | Err of Int64 Err(1) == Err(1) = stdout="true\n"

// Match on Result
type Result = Ok of Int64 | Err of Int64 match Ok(100) with | Ok(v) -> v | Err(e) -> 0 - e = 100
type Result = Ok of Int64 | Err of Int64 match Err(5) with | Ok(v) -> v | Err(e) -> 0 - e = -5

// ===================================================================
// Either Type (Two Payload Variants)
// NOTE: Equality tests commented out - requires enum equality support
// ===================================================================

// type Either = Left of Int64 | Right of Int64 Left(5) == Left(5) = stdout="true\n"
// type Either = Left of Int64 | Right of Int64 Right(5) == Right(5) = stdout="true\n"
// type Either = Left of Int64 | Right of Int64 Left(5) == Right(5) = stdout="false\n"

// Pattern match Either
type Either = Left of Int64 | Right of Int64 match Left(10) with | Left(x) -> x | Right(y) -> y * 2 = 10
type Either = Left of Int64 | Right of Int64 match Right(10) with | Left(x) -> x | Right(y) -> y * 2 = 20

// ===================================================================
// Enums in Variables
// ===================================================================

// Store in variable
type Color = Red | Green | Blue let c = Red in match c with | Red -> 1 | _ -> 0 = 1
type Option = None | Some of Int64 let opt = Some(42) in match opt with | Some(x) -> x | None -> 0 = 42

// Return from if
type Color = Red | Green | Blue let c = if true then Red else Blue in match c with | Red -> 1 | Blue -> 2 | _ -> 0 = 1
type Color = Red | Green | Blue let c = if false then Red else Blue in match c with | Red -> 1 | Blue -> 2 | _ -> 0 = 2

// ===================================================================
// Nested Pattern Matching with Enums
// ===================================================================

// Nested match
type Option = None | Some of Int64 match Some(5) with | Some(x) -> match x with | 5 -> 100 | _ -> 0 | None -> 0 = 100

// Enum in if body
type Option = None | Some of Int64 match Some(10) with | Some(x) -> if x > 5 then x * 2 else x | None -> 0 = 20

// ===================================================================
// Multiple Variants (More than 2 or 3)
// ===================================================================

type Direction = North | East | South | West match North with | North -> 0 | East -> 90 | South -> 180 | West -> 270 = 0
type Direction = North | East | South | West match East with | North -> 0 | East -> 90 | South -> 180 | West -> 270 = 90
type Direction = North | East | South | West match South with | North -> 0 | East -> 90 | South -> 180 | West -> 270 = 180
type Direction = North | East | South | West match West with | North -> 0 | East -> 90 | South -> 180 | West -> 270 = 270

// ===================================================================
// Enum with Let in Body
// ===================================================================

type Option = None | Some of Int64 match Some(5) with | Some(x) -> let y = x * 2 in y + 1 | None -> 0 = 11
type Result = Ok of Int64 | Err of Int64 match Ok(10) with | Ok(v) -> let doubled = v * 2 in doubled | Err(_) -> 0 = 20

// ===================================================================
// Enum Construction in Expressions
// ===================================================================

// Construct with computed value
type Option = None | Some of Int64 let x = 20 in let opt = Some(x + 22) in match opt with | Some(v) -> v | None -> 0 = 42

// Conditional construction
type Option = None | Some of Int64 let x = 5 in let opt = if x > 0 then Some(x) else None in match opt with | Some(v) -> v | None -> 0 = 5
type Option = None | Some of Int64 let x = 0 - 5 in let opt = if x > 0 then Some(x) else None in match opt with | Some(v) -> v | None -> 99 = 99

// ===================================================================
// Complex Enum Usage
// NOTE: Printing tests commented out - requires enum printing support
// ===================================================================

// Enum printing (pretty-printing of ADT values)
// type Option = None | Some of Int64 Some(20) = stdout="Some(20)\n"
// type Option = None | Some of Int64 None = stdout="None\n"
// type Color = Red | Green | Blue Red = stdout="Red\n"
// type Color = Red | Green | Blue Green = stdout="Green\n"

// Map-like behavior (manual)
type Option = None | Some of Int64 let opt = Some(10) in match opt with | Some(x) -> match Some(x * 2) with | Some(v) -> v | None -> 0 | None -> 0 = 20

// Chained matching
type Option = None | Some of Int64 let opt1 = Some(5) in match opt1 with | Some(x) -> match Some(x + 5) with | Some(y) -> y | None -> 0 | None -> 0 = 10

// ===================================================================
// Edge Cases
// NOTE: Equality test commented out - requires enum equality support
// ===================================================================

// Zero payload
// type Option = None | Some of Int64 Some(0) == Some(0) = stdout="true\n"
type Option = None | Some of Int64 match Some(0) with | Some(x) -> x + 1 | None -> 0 = 1

// Negative payload (via subtraction)
type Option = None | Some of Int64 match Some(0 - 5) with | Some(x) -> x | None -> 0 = -5

// Large payload
type Option = None | Some of Int64 match Some(1000000) with | Some(x) -> x | None -> 0 = 1000000

// ===================================================================
// Dark Enum Tests (from enums.dark)
// NOTE: Commented out - requires Stdlib, Builtin.testRuntimeError, and module syntax support
// ===================================================================

// Stdlib.Option type
// Stdlib.Option.Option.None = stdout="Stdlib.Option.Option.None\n"
// ((Stdlib.List.head []) == Stdlib.Option.Option.None) = stdout="true\n"
// (Stdlib.List.head []) = stdout="Stdlib.Option.Option.None\n"

// ===================================================================
// Error Propagation in Enums
// NOTE: Commented out - requires Builtin.testRuntimeError support
// ===================================================================

// Stdlib.Result.Result.Ok(Builtin.testRuntimeError "err") = Builtin.testDerrorMessage "Uncaught exception: err"
// Stdlib.Option.Option.Some(Builtin.testRuntimeError "err") = Builtin.testDerrorMessage "Uncaught exception: err"
// Stdlib.Result.Result.Error(Builtin.testRuntimeError "err") = Builtin.testDerrorMessage "Uncaught exception: err"

// ===================================================================
// Enum Field Count Errors
// NOTE: Commented out - requires Builtin.testDerrorMessage support
// ===================================================================

// Stdlib.Option.Option.None 5 = Builtin.testDerrorMessage "Expected 0 fields in Darklang.Stdlib.Option.Option.`None`, but got 1"
// Stdlib.Option.Option.Some(5, 6) = Builtin.testDerrorMessage "Expected 1 fields in Darklang.Stdlib.Option.Option.`Some`, but got 2"

// ===================================================================
// User-Defined Enum Errors
// NOTE: Commented out - requires module syntax and Builtin.testDerrorMessage support
// ===================================================================

// type MyEnum = A | B | C of String

// MyEnum.D = Builtin.testDerrorMessage "There is no case named `D` in Errors.User.MyEnum"
// MyEnum.C = Builtin.testDerrorMessage "Expected 1 fields in Errors.User.MyEnum.`C`, but got 0"
// MyEnum.B 5L = Builtin.testDerrorMessage "Expected 0 fields in Errors.User.MyEnum.`B`, but got 1"

// ===================================================================
// Enum Pattern Matching with Field Extraction
// NOTE: Commented out - requires module syntax
// ===================================================================

// (match MyEnum.C "test" with | C v -> v) = "test"
// (match MyEnum.C "test" with | 5 -> "unmatched because it's not an int" | C v -> v) = "test"
// (match MyEnum.C "test" with | C -> "unmatched because we didn't provide a space for the field") = Builtin.testDerrorMessage "No matching case found for value Errors.User.MyEnum.C(\"test\") in match expression"
// (match MyEnum.C "test" with | D -> "unmatched because case name does not exist" | C _ -> 2) = 2
// (MyEnum.C 5L) = Builtin.testDerrorMessage "Failed to create enum. Expected String for field 0 in `C`, but got Int64 (5)"

// ===================================================================
// Enum Equality Tests
// NOTE: Commented out - requires module syntax
// ===================================================================

// type AorB = A | B

// (let a = AorB.A let b = AorB.B a == b) = stdout="false\n"
// (let a1 = AorB.A let a2 = AorB.A a1 == a2) = stdout="true\n"
// (AorB.A == AorB.A) = stdout="true\n"
// (AorB.A == AorB.B) = stdout="false\n"

// ===================================================================
// Stdlib.List.unique with Enums
// NOTE: Commented out - requires Stdlib support
// ===================================================================

// Stdlib.List.unique_v0 [ AorB.A; AorB.B; AorB.A; AorB.A; AorB.B ] = stdout="[AorB.A, AorB.B]\n"

// ===================================================================
// Nested Enum Types
// NOTE: Commented out - requires module syntax and Int64 suffix
// ===================================================================

// type CorD = C of Int64 | D of AorB

// (CorD.C 5L != CorD.D AorB.B) = stdout="true\n"
// (CorD.D AorB.A == CorD.D AorB.A) = stdout="true\n"

// ===================================================================
// Mixed Case Enums (some with payloads, some without)
// NOTE: Commented out - requires module syntax and error testing
// ===================================================================

// type EnumOfMixedCases = W | X of String | Y of Int64 | Z of String * Int64

// (EnumOfMixedCases.W == (EnumOfMixedCases.Y 1L)) = stdout="false\n"
// (EnumOfMixedCases.Y 1L == EnumOfMixedCases.Y 1L) = stdout="true\n"
// EnumOfMixedCases.X 1L = Builtin.testDerrorMessage "Failed to create enum. Expected String for field 0 in `X`, but got Int64 (1)"
// EnumOfMixedCases.Y "test" = Builtin.testDerrorMessage "Failed to create enum. Expected Int64 for field 0 in `Y`, but got String (\"test\")"
// EnumOfMixedCases.Z 1L = Builtin.testDerrorMessage "Expected 2 fields in MixedCases.EnumOfMixedCases.`Z`, but got 1"
// EnumOfMixedCases.Z(Builtin.testRuntimeError "1", Builtin.testRuntimeError "2") = Builtin.testDerrorMessage "Uncaught exception: 1"

// ===================================================================
// Tuple-like Enum vs Tuple Field Enums
// NOTE: Commented out - requires module syntax and error testing
// ===================================================================

// type Tuples = NotTuple of String * Int64 | Tuple of (String * Int64)

// (match Tuples.NotTuple("printer broke", 7L) with | NotTuple(reason, 7L) -> reason) = "printer broke"
// (Tuples.NotTuple(("printer broke", 7L))) = Builtin.testDerrorMessage "Expected 2 fields in TuplesVsNonTuples.Tuples.`NotTuple`, but got 1"
// (match Tuples.Tuple(("printer broke", 7L)) with | Tuple((reason, 7L)) -> reason) = "printer broke"
// Tuples.Tuple("printer broke", 7L) = Builtin.testDerrorMessage "Expected 1 fields in TuplesVsNonTuples.Tuples.`Tuple`, but got 2"

// ===================================================================
// Recursive Enum Types (Tree)
// NOTE: Commented out - requires module syntax
// ===================================================================

// type Tree = Leaf | Node of Tree * Tree

// Tree.Node(Tree.Leaf, Tree.Leaf) = stdout="Tree.Node(Tree.Leaf, Tree.Leaf)\n"
// (Tree.Node(Tree.Leaf, Tree.Leaf) == Tree.Node(Tree.Leaf, Tree.Node(Tree.Leaf, Tree.Leaf))) = stdout="false\n"
