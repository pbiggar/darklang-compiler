// Tests imported from Dark language test suite
// Source: https://github.com/darklang/dark/blob/main/backend/testfiles/execution/language/elambda.dark
//
// ALL TESTS INCLUDED - no filtering or removal
// Tests may fail if features are not yet implemented
// Note: Our lambda syntax uses `fn x -> body` instead of `fun x -> body`

// ===================================================================
// Basic Lambda Expressions
// NOTE: Commented out - requires `fn` lambda syntax support
// Our parser only supports arrow function syntax: (x: int) => body
// ===================================================================

// Identity lambda
// (fn x -> x)(42) = 42
// (fn x -> x)(0) = 0
// (fn x -> x)(100) = 100

// Lambda with arithmetic
// (fn x -> x + 1)(5) = 6
// (fn x -> x * 2)(21) = 42
// (fn x -> x - 1)(10) = 9
// (fn x -> x + x)(5) = 10

// Lambda with multiple operations
// (fn x -> x * x)(6) = 36
// (fn x -> x * x + x)(5) = 30
// (fn x -> x + x + x)(7) = 21

// ===================================================================
// Multi-Parameter Lambdas
// NOTE: Commented out - requires `fn` lambda syntax support
// ===================================================================

// Two parameters
// (fn x, y -> x + y)(10, 32) = 42
// (fn x, y -> x * y)(6, 7) = 42
// (fn x, y -> x - y)(50, 8) = 42

// Three parameters
// (fn x, y, z -> x + y + z)(10, 20, 30) = 60
// (fn x, y, z -> x * y * z)(2, 3, 4) = 24

// Four parameters
// (fn a, b, c, d -> a + b + c + d)(1, 2, 3, 4) = 10

// ===================================================================
// Lambda with Let Bindings
// NOTE: Commented out - requires `fn` lambda syntax support
// ===================================================================

// Let in lambda body
// (fn x -> let y = x * 2 in y)(5) = 10
// (fn x -> let y = x + 1 in let z = y * 2 in z)(5) = 12

// Use parameter multiple times
// (fn x -> let y = x in y + x)(10) = 20

// ===================================================================
// Lambda with Conditionals
// NOTE: Commented out - requires `fn` lambda syntax support
// ===================================================================

// If in lambda body
// (fn x -> if x > 0 then x else 0)(5) = 5
// (fn x -> if x > 0 then x else 0)(0 - 5) = 0
// (fn x -> if x > 10 then 1 else 0)(15) = 1
// (fn x -> if x > 10 then 1 else 0)(5) = 0

// Two parameter conditional
// (fn x, y -> if x > y then x else y)(10, 5) = 10
// (fn x, y -> if x > y then x else y)(5, 10) = 10

// ===================================================================
// Lambda with Pattern Matching
// NOTE: Commented out - requires `fn` lambda syntax support
// ===================================================================

// Match in lambda body
// (fn x -> match x with | 0 -> 100 | _ -> x)(0) = 100
// (fn x -> match x with | 0 -> 100 | _ -> x)(42) = 42

// Match on tuple parameter
// (fn t -> match t with | (a, b) -> a + b)((10, 20)) = 30

// ===================================================================
// Closures - Capturing Variables
// NOTE: Commented out - requires `fn` lambda syntax support
// ===================================================================

// Capture outer variable
// let x = 10 in (fn y -> x + y)(5) = 15
// let x = 100 in (fn y -> x * y)(2) = 200

// Capture multiple variables
// let x = 5 in let y = 10 in (fn z -> x + y + z)(15) = 30

// Nested capture
// let x = 1 in let f = fn y -> x + y in f(10) = 11

// Capture and shadow
// let x = 100 in (fn x -> x + 1)(5) = 6

// ===================================================================
// Lambda Stored in Variable
// NOTE: Commented out - requires `fn` lambda syntax support
// ===================================================================

// Store and apply
// let f = fn x -> x + 1 in f(5) = 6
// let f = fn x -> x * 2 in f(21) = 42

// Store multi-param lambda
// let f = fn x, y -> x + y in f(10, 20) = 30
// let add = fn a, b -> a + b in add(100, 200) = 300

// ===================================================================
// Lambda with Functions
// NOTE: Commented out - requires `fn` lambda syntax support
// ===================================================================

// Call function inside lambda
// def double(x: int): int = x * 2 (fn x -> double(x))(21) = 42
// def add(a: int, b: int): int = a + b (fn x, y -> add(x, y))(10, 32) = 42

// Lambda using function result
// def inc(x: int): int = x + 1 let f = fn x -> inc(inc(x)) in f(5) = 7

// ===================================================================
// Nested Lambdas
// NOTE: Commented out - requires `fn` lambda syntax support
// ===================================================================

// Lambda returning lambda (currying)
// let add = fn x -> fn y -> x + y in add(10)(32) = 42

// Apply nested lambda
// let f = fn x -> fn y -> fn z -> x + y + z in f(1)(2)(3) = 6

// ===================================================================
// Lambda with Tuples
// NOTE: Commented out - requires `fn` lambda syntax support
// ===================================================================

// Return tuple (printing)
// (fn x -> (x, x + 1))(5) = stdout="(5, 6)\n"
// (fn x, y -> (x + y, x * y))(3, 4) = stdout="(7, 12)\n"

// Return tuple - verify via pattern match extraction
// (fn x -> match (x, x + 1) with | (a, b) -> a + b)(5) = 11

// Accept and return tuple - verify via extraction
// (fn t -> match t with | (a, b) -> match (b, a) with | (x, y) -> x + y)((1, 2)) = 3

// ===================================================================
// Lambda with Boolean Operations
// NOTE: Commented out - requires `fn` lambda syntax support
// ===================================================================

// Boolean result
// (fn x -> x > 10)(15) = stdout="true\n"
// (fn x -> x > 10)(5) = stdout="false\n"
// (fn x, y -> x == y)(5, 5) = stdout="true\n"
// (fn x, y -> x == y)(5, 6) = stdout="false\n"

// Boolean operations
// (fn x, y -> x && y)(true, true) = stdout="true\n"
// (fn x, y -> x && y)(true, false) = stdout="false\n"
// (fn x, y -> x || y)(false, true) = stdout="true\n"

// ===================================================================
// Complex Lambda Expressions
// NOTE: Commented out - requires `fn` lambda syntax support
// ===================================================================

// Multiple operations with conditionals
// (fn x -> if x > 0 then x * 2 else 0 - x)(5) = 10
// (fn x -> if x > 0 then x * 2 else 0 - x)(0 - 5) = 5

// Nested conditionals
// (fn x -> if x > 10 then 2 else if x > 5 then 1 else 0)(15) = 2
// (fn x -> if x > 10 then 2 else if x > 5 then 1 else 0)(7) = 1
// (fn x -> if x > 10 then 2 else if x > 5 then 1 else 0)(3) = 0

// ===================================================================
// Edge Cases
// NOTE: Commented out - requires `fn` lambda syntax support
// ===================================================================

// Zero parameter (unit)
// (Note: true zero-param lambdas may not be supported; use dummy param)
// (fn _ -> 42)(0) = 42

// Wildcard parameter
// (fn _ -> 100)(999) = 100
// (fn x, _ -> x)(42, 0) = 42
// (fn _, y -> y)(0, 42) = 42

// Large results
// (fn x -> x * 1000)(1000) = 1000000

// Negative results
// (fn x -> 0 - x)(5) = -5
// (fn x, y -> x - y)(5, 10) = -5

// ===================================================================
// Dark Lambda Tests (from elambda.dark)
// NOTE: Commented out - requires Dark-specific syntax support
// ===================================================================

// (let y = (fun x ___ -> x + 1L) Stdlib.List.map_v0 [ 1L; 2L; 3L; 4L ] y) = stdout="[2, 3, 4, 5]\n"
// (let y = (fun x -> x + 1L) Stdlib.List.map_v0 [ 1L; 2L; 3L; 4L ] y) = stdout="[2, 3, 4, 5]\n"
// (let y = (fun a b -> a + b) in y 2L 3L) = 5
// (let y = (fun (a, b) -> a + b) in y (2L, 3L)) = 5

// ===================================================================
// Stdlib.List.map with Lambdas
// NOTE: Commented out - requires Builtin.testRuntimeError support
// ===================================================================

// (let y = (fun msg -> Builtin.testRuntimeError msg) Stdlib.List.map_v0 [ "1"; "2"; "3"; "4" ] y) = Builtin.testDerrorMessage "Uncaught exception: 1"
// (let y = (fun msg -> Builtin.testRuntimeError msg) in Stdlib.List.map_v0 [] y) = stdout="[]\n"

// ===================================================================
// Stdlib.List.fold with Lambdas
// NOTE: Commented out - requires Stdlib support
// ===================================================================

// (let y = (fun a b -> a * b) in Stdlib.List.fold_v0 [ 1L; 2L; 3L; 4L ] 1L y) = 24
// (Stdlib.List.fold_v0 [ 4L ] 1L (Builtin.testRuntimeError "test")) = Builtin.testDerrorMessage "Uncaught exception: test"

// ===================================================================
// Pipe Operator with Lambdas
// NOTE: Commented out - requires pipe operator and Stdlib support
// ===================================================================

// (let x = 5L let y = (fun c -> x + c) let x = 6L [ 1L; 2L; 3L; 4L ] |> Stdlib.List.map_v0 y) = stdout="[6, 7, 8, 9]\n"
// (let y = (fun c -> if c > 2L then Builtin.testRuntimeError "err" else 18L) [ 1L; 2L; 3L; 4L ] |> Stdlib.List.map_v0 y) = Builtin.testDerrorMessage "Uncaught exception: err"
// (let y = (fun c -> if c > 2L then Builtin.testRuntimeError "err" else 18L) [ 1L; 2L ] |> Stdlib.List.map_v0 y) = stdout="[18, 18]\n"

// ===================================================================
// String Operations with Lambdas
// NOTE: Commented out - requires Stdlib support
// ===================================================================

// (Stdlib.String.join_v0 (Stdlib.List.map_v0 (Stdlib.String.toList "some string") (fun var -> Stdlib.String.toUppercase (Stdlib.String.fromChar var))) "") = "SOME STRING"

// ===================================================================
// Stdlib.List.all with Lambdas
// NOTE: Commented out - requires Stdlib support
// ===================================================================

// (let t = true in Stdlib.List.all [ 1L; 2L ] (fun _ -> t)) = stdout="true\n"
// (let f = false in Stdlib.List.all [ 1L; 2L ] (fun _ -> f)) = stdout="false\n"

// ===================================================================
// Closure Capture Order Tests
// NOTE: Commented out - requires Stdlib support
// ===================================================================

// (let x = 1L let f = fun _ -> x let x = 2L Stdlib.List.map [ 1L; 2L; 3L ] f) = stdout="[1, 1, 1]\n"

// ===================================================================
// Tuple Destructuring in Lambdas
// NOTE: Commented out - requires Stdlib and string interpolation support
// ===================================================================

// (let pairs = [ (1L, "one"); (2L, "two"); (3L, "three") ] let transformer = fun (num, str) -> $"{Stdlib.Int64.toString num}:{str}" Stdlib.List.map_v0 pairs transformer) = stdout="[\"1:one\", \"2:two\", \"3:three\"]\n"

// (let triplets = [ (1L, "one", true); (2L, "two", false) ] let transformer = fun (num, str, flag) -> if flag then $"{Stdlib.Int64.toString num}:{str}:TRUE" else $"{Stdlib.Int64.toString num}:{str}:FALSE" Stdlib.List.map_v0 triplets transformer) = stdout="[\"1:one:TRUE\", \"2:two:FALSE\"]\n"

// (let sing = [ (("1"), "2"); (("3"), "4") ] let transformer = fun ((str1), str2) -> str1 ++ str2 Stdlib.List.map_v0 sing transformer) = stdout="[\"12\", \"34\"]\n"

// (let triplets = [ (1L, "one", true); (2L, "two", false) ] let transformer = fun (num, str) -> $"{Stdlib.Int64.toString num}:{str}" Stdlib.List.map_v0 triplets transformer) = Builtin.testDerrorMessage "Could not deconstruct value (1, \"one\", true) into pattern ([variable], [variable])"

// ===================================================================
// Dict Operations with Lambdas
// NOTE: Commented out - requires Dict and Stdlib support
// ===================================================================

// Stdlib.Dict.map_v0 (Dict { key1 = ("val11", "val12") key2 = ("val21", "val22") }) (fun x (y, z) -> x ++ y ++ z) = stdout="Dict { key2 = \"key2val21val22\"; key1 = \"key1val11val12\" }\n"
// (Stdlib.Dict.map_v0 (Dict { key1 = ("val11", "val12"); key2 = ("val21", "val22") }) (fun x (_, z) -> x ++ z)) = stdout="Dict { key2 = \"key2val22\"; key1 = \"key1val12\" }\n"
