// Tests imported from Dark language test suite
// Source: https://raw.githubusercontent.com/darklang/dark/main/backend/testfiles/execution/language/custom-data/aliases.dark
//
// ALL TESTS INCLUDED - no filtering or removal
// Tests may fail if features are not yet implemented

// ===================================================================
// Working type alias tests (Int64 fields)
// ===================================================================

type PointBase = { x: Int64, y: Int64 }
type MyPoint = PointBase
type AliasedPoint = PointBase
type Alias1 = PointBase
type Alias2 = PointBase

// Simple record alias
MyPoint { x = 1, y = 2 }.x = 1
MyPoint { x = 1, y = 2 }.y = 2

// Aliased record field access
let p = AliasedPoint { x = 10, y = 20 } in p.x = 10
let p = AliasedPoint { x = 10, y = 20 } in p.y = 20

// Aliased record with computed fields
AliasedPoint { x = 3 * 2, y = 4 + 1 }.x = 6
AliasedPoint { x = 3 * 2, y = 4 + 1 }.y = 5

// Aliased records are structurally equal to base type
PointBase { x = 5, y = 6 } == AliasedPoint { x = 5, y = 6 } = stdout="true\n"
AliasedPoint { x = 5, y = 6 } == PointBase { x = 5, y = 6 } = stdout="true\n"

// Multiple aliases to same type
Alias1 { x = 1, y = 2 } == Alias2 { x = 1, y = 2 } = stdout="true\n"

// Record update through alias
let p = AliasedPoint { x = 1, y = 2 } in { p with x = 100 }.x = 100

// Function with aliased parameter and return types
type Point = { x: Int64, y: Int64 }
type Vec = Point

def addVecs(a: Vec, b: Vec): Vec =
    Vec { x = a.x + b.x, y = a.y + b.y }

def makeVec(x: Int64, y: Int64): Vec =
    Vec { x = x, y = y }

addVecs(Vec { x = 1, y = 2 }, Vec { x = 3, y = 4 }) = stdout="Vec { x = 4, y = 6 }\n"
makeVec(10, 20) = stdout="Vec { x = 10, y = 20 }\n"

// ===================================================================
// Simple alias
// NOTE: All tests commented out - requires type aliases, String literals,
// Int64 suffix, generic type parameters, Stdlib, and Builtin support
// ===================================================================

// type Id = String

// type Something = { ID: Id; Data: String }

// Something { ID = "2"; Data = "test" } = stdout="Something { ID = \"2\"; Data = \"test\" }\n"

// Type error with alias
// Something { ID = 2L; Data = "test" } = Builtin.testDerrorMessage "Failed to create record. Expected String for field `ID`, but got 2 (an Int64)"

// ===================================================================
// SimpleRecordAlias module
// NOTE: Commented out - requires type aliases and String literals
// ===================================================================

// type Person = { name: String }
// type MyPerson = Person
// type MyPerson2 = Person

// (MyPerson { name = "test" } == Person { name = "test" }) = stdout="true\n"
// (MyPerson { name = "test" } == MyPerson2 { name = "test" }) = stdout="true\n"

// def getName (p: MyPerson) : String = p.name
// getName (MyPerson { name = "test" }) = "test"

// ===================================================================
// SimpleEnumAlias module
// ===================================================================

type UserRole = Admin | User | Guest
type AdminRole = UserRole
type GuestRole = UserRole

(GuestRole.Guest == AdminRole.Guest) = stdout="true\n"

// ===================================================================
// Generic type aliases (aliasing generic types like List<Int64>)
// ===================================================================

// Alias for List<Int64> - variable with alias type passed to stdlib function
type IntList = List<Int64>

def getLength(xs: IntList): Int64 =
    Stdlib.List.length(xs)

getLength([1, 2, 3]) = 3

// Alias for tuple with type parameter
type Pair<a> = (a, a)

def makePair(x: Int64): Pair<Int64> =
    (x, x + 1)

def fstPair(p: Pair<Int64>): Int64 =
    match p with | (a, b) -> a

match makePair(5) with | (a, b) -> a + b = 11
fstPair((10, 20)) = 10

// ===================================================================
// NestedAlias module
// NOTE: Commented out - requires type aliases, String, pipe operator, and Stdlib
// ===================================================================

// type UserCredential = (String * Id)
// type EmployeeCredential = UserCredential

// def getUserID (credential: UserCredential) : Id = credential |> Stdlib.Tuple2.second

// getUserID (("Alice", "EMP123")) = "EMP123"

// getUserID (("Alice", 123L)) = Builtin.testDerrorMessage "NestedAlias.getUserID's 1st parameter `credential` expects (String * String), but got (String * Int64) ((\"Alice\", 123))"

// type UserProfile = { credential: UserCredential; name: String }

// type EmployeeProfile = UserProfile
// def getEmployeeName (profile: EmployeeProfile) : String = profile.name

// (getEmployeeName (UserProfile { credential = ("Alice", "EMP123"); name = "Alice" })) = "Alice"

// ===================================================================
// ListAlias module
// NOTE: Commented out - requires type aliases, generic type parameters, and Stdlib
// ===================================================================

// type IntegerList = List<Int64>

// def isEmpty (il: IntegerList) : Bool = Stdlib.List.isEmpty_v0 il

// isEmpty ([]) = stdout="true\n"
// isEmpty ([ 1L; 2L; 3L ]) = stdout="false\n"

// ===================================================================
// ResultAlias module
// NOTE: Commented out - requires type aliases, generic type parameters, and Stdlib
// ===================================================================

// type IntResult = Stdlib.Result.Result<Int64, String>

// def getIntResultValue (ir: IntResult) : Int64 = Stdlib.Result.withDefault_v0 ir 0L

// getIntResultValue (Stdlib.Result.Result.Ok 5L) = 5
// getIntResultValue (Stdlib.Result.Result.Error "error") = 0

// ===================================================================
// RecordWithTypeArgs module
// NOTE: Commented out - requires type aliases, generic type parameters, and Stdlib
// ===================================================================

// type Inner<'a, 'b> = { a: 'a; b: 'b }

// type Outer1<'a> = Inner<'a, Int64>
// type Outer2<'b> = Inner<String, 'b>

// (Outer1 { a = "test"; b = 5L }) = stdout="Inner { a = \"test\"; b = 5 }\n"
// (Outer1 { a = "test"; b = 5L }) = (Outer2 { a = "test"; b = 5L })

// def getInnerField (x: Inner<'a, 'b>) : 'b = x.b
// getInnerField (Inner { a = "test"; b = 5L }) = 5
// getInnerField (Outer1 { a = "test"; b = 5L }) = 5
// getInnerField (Outer2 { a = "test"; b = 5L }) = 5

// Outer2 { a = 5L; b = 6L } = Builtin.testDerrorMessage "Failed to create record. Expected String for field `a`, but got 5 (an Int64)"

// Outer1 { a = "a"; b = "b" } = Builtin.testDerrorMessage "Failed to create record. Expected Int64 for field `b`, but got \"b\" (a String)"

// ===================================================================
// RecordWithTypeArgsDifferentName module
// NOTE: Commented out - requires type aliases and generic type parameters
// ===================================================================

// type LessInner<'b, 'a> = Inner<'a, 'b>
// type Outer<'x> = LessInner<'x, Int64>
// type Outest<'y> = Outer<'y>
// type MostOutest = Outest<String>

// MostOutest { a = 5L; b = "string" } = stdout="Inner { a = 5; b = \"string\" }\n"

// MostOutest { a = "not allowed"; b = "string" } = Builtin.testDerrorMessage "Failed to create record. Expected Int64 for field `a`, but got \"not allow... (a String)"

// MostOutest { a = 5L; b = 6L } = Builtin.testDerrorMessage "Failed to create record. Expected String for field `b`, but got 6 (an Int64)"

// ===================================================================
// RecordWithRecursiveTypeArgs module
// NOTE: Commented out - requires type aliases, recursive types, and Stdlib
// ===================================================================

// type RecInner<'a> = { a: 'a; b: Stdlib.Result.Result<RecAlias<'a>, String> }
// type RecAlias<'x> = RecInner<'x>

// RecInner { a = 5L; b = Stdlib.Result.Result.Ok(RecInner { a = 6L; b = Stdlib.Result.Result.Ok(RecInner { a = 7L; b = Stdlib.Result.Result.Error "test" }) }) } = (RecAlias { a = 5L; b = Stdlib.Result.Result.Ok(RecAlias { a = 6L; b = Stdlib.Result.Result.Ok(RecAlias { a = 7L; b = Stdlib.Result.Result.Error "test" }) }) })

// ===================================================================
// MultiNestedRecordAlias module
// NOTE: Commented out - requires type aliases and generic type parameters
// ===================================================================

// type Innest<'a, 'b, 'c> = { a: 'a; b: 'b; c: 'c }
// type Nest1<'a, 'b> = Innest<'a, 'b, Int64>
// type Nest2<'a> = Nest1<'a, String>
// type Nest3 = Nest2<Int64>

// Nest3 { a = 5L; b = "test"; c = 6L } = stdout="Innest { a = 5; b = \"test\"; c = 6 }\n"

// ===================================================================
// EnumWithTypeArgs module
// NOTE: Commented out - requires type aliases and generic type parameters
// ===================================================================

// type EnumInner<'a, 'b> = | A of 'a | B of 'b

// type EnumOuter1<'a> = EnumInner<'a, Int64>
// type EnumOuter2<'b> = EnumInner<String, 'b>

// def getEnumInnerField (x: EnumInner<'a, 'b>) (default': 'b) : 'b = match x with | A _ -> default' | B b -> b

// getEnumInnerField (EnumInner.A 5L) 6L = 6
// getEnumInnerField (EnumInner.B 5L) 6L = 5
// getEnumInnerField (EnumOuter1.A 5L) 6L = 6
// getEnumInnerField (EnumOuter1.B 5L) 6L = 5
// getEnumInnerField (EnumOuter2.A "str") "str2" = "str2"
// getEnumInnerField (EnumOuter2.B "str") "str2" = "str"

// EnumOuter1.A 5L = stdout="EnumInner.A(5)\n"
// EnumOuter1.B 5L = stdout="EnumInner.B(5)\n"

// EnumOuter2.A "str" = EnumOuter1.A "str"
// EnumOuter2.B 5L = EnumOuter1.B 5L

// EnumOuter2.A 5L = Builtin.testDerrorMessage "Failed to create enum. Expected String for field 0 in `A`, but got Int64 (5)"

// EnumOuter1.B "b" = Builtin.testDerrorMessage "Failed to create enum. Expected Int64 for field 0 in `B`, but got String (\"b\")"

// ===================================================================
// EnumWithTypeArgsDifferentName module
// NOTE: Commented out - requires type aliases and generic type parameters
// ===================================================================

// type EnumLessInner<'b, 'a> = EnumInner<'a, 'b>
// type EnumOuter<'x> = EnumLessInner<'x, Int64>
// type EnumOutest<'y> = EnumOuter<'y>
// type EnumMostOutest = EnumOutest<String>

// EnumMostOutest.A 5L = stdout="EnumInner.A(5)\n"
// EnumMostOutest.B "test" = stdout="EnumInner.B(\"test\")\n"

// EnumMostOutest.A "not allowed" = Builtin.testDerrorMessage "Failed to create enum. Expected Int64 for field 0 in `A`, but got String (\"not allowed\")"

// EnumMostOutest.B 6L = Builtin.testDerrorMessage "Failed to create enum. Expected String for field 0 in `B`, but got Int64 (6)"

// ===================================================================
// EnumWithRecursiveTypeArgs module
// NOTE: Commented out - requires type aliases, recursive types, and Stdlib
// ===================================================================

// type EnumRecInner<'a> = | A of a: 'a | B of b: Stdlib.Result.Result<EnumRecAlias<'a>, String>

// type EnumRecAlias<'x> = EnumRecInner<'x>

// EnumRecAlias.B(Stdlib.Result.Result.Ok(EnumRecAlias.A 5L)) = stdout="EnumRecInner.B(Stdlib.Result.Result.Ok(EnumRecInner.A(5)))\n"
