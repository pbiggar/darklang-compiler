// Tests imported from Dark language test suite
// Source: https://raw.githubusercontent.com/darklang/dark/main/backend/testfiles/execution/language/flow-control/epipe.dark
//
// ALL TESTS INCLUDED - no filtering or removal
// Tests may fail if features are not yet implemented

// ===================================================================
// Basic pipe operations (working tests with current syntax)
// ===================================================================

// Pipe with lambda (our syntax)
5 |> ((x: Int64) => x + 1) = 6
10 |> ((x: Int64) => x * 2) = 20

// Multiple pipes with lambdas
5 |> ((x: Int64) => x + 1) |> ((y: Int64) => y * 3) = 18

// Pipe with expression as input
(3 + 2) |> ((x: Int64) => x + 1) = 6
(10 - 5) |> ((x: Int64) => x * 2) = 10

// Pipe in let binding
let f = (x: Int64) => x + 1 in 5 |> f = 6
let f = (x: Int64) => x + 1 in let g = (x: Int64) => x * 2 in 5 |> f |> g = 12

// Pipe with bool result lambda (convert to int for testing)
5 |> ((x: Int64) => if x > 0 then 1 else 0) = 1
(0 - 5) |> ((x: Int64) => if x > 0 then 1 else 0) = 0

// Pipe with string lambda
"hello" |> ((s: String) => s ++ "!") = stdout="hello!\n"

// Nested pipe in expression
let f = (x: Int64) => x + 1 in let g = (x: Int64) => x * 2 in (5 |> f) + (10 |> g) = 26

// Pipe with named function (function defined inline)
def addOne(x: Int64): Int64 = x + 1 let result = 5 |> addOne in result = 6

// Pipe chain with named functions
def addOne(x: Int64): Int64 = x + 1 def double(x: Int64): Int64 = x * 2 let result = 5 |> addOne |> double in result = 12

// Pipe with tuple (using lambdas since function def + tuple expression is ambiguous)
(1, 2) |> ((t: (Int64, Int64)) => t.0) = 1
(1, 2) |> ((t: (Int64, Int64)) => t.1) = 2

// ===================================================================
// Original Dark tests (commented - require additional features)
// ===================================================================

// ===================================================================
// Basic pipe operations
// NOTE: All tests commented out - requires pipe operator, Int64 suffix, and Stdlib support
// ===================================================================

// Function with pipe
// let userFn () : Int64 = 6L
// (() |> userFn) = 6

// ([] |> Stdlib.List.push_v0 2L) = stdout="[2]\n"

// ===================================================================
// Nested function in pipe
// NOTE: Commented out - requires pipe operator and Stdlib support
// ===================================================================

// ([] |> Stdlib.List.push_v0 (Stdlib.Int64.add_v0 1L (Stdlib.Int64.add_v0 1L 3L))) = stdout="[5]\n"

// ([] |> Stdlib.List.push_v0 (Stdlib.Int64.add_v0 1L ((+) 1L 3L))) = stdout="[5]\n"

// ([] |> Stdlib.List.push_v0 (Builtin.testRuntimeError "err")) = Builtin.testDerrorMessage "Uncaught exception: err"

// ===================================================================
// General pipe usage
// NOTE: Commented out - requires pipe operator and Stdlib support
// ===================================================================

// (4L |> (-) 3L) = 1

// ([ 5L ] |> Stdlib.List.head |> Builtin.unwrap |> Stdlib.Int64.add_v0 1L |> (+) 3L |> (fun x -> if (x + 4L) > 1L then x else (1L + x))) = 9

// Lambda in variable
// (let x = fun a -> a + 1L in (5L |> x |> x |> (+) 3L)) = 10

// Only lambda might be placed into the variable used in the middle of the pipe
// (let x = 1L in (5L |> x |> (+) 3L)) = Builtin.testDerrorMessage "Expected something we could apply to, such as a lambda or function, but got an Int64 (1)"

// ===================================================================
// Pipe with records
// NOTE: Commented out - requires pipe operator, Int64 suffix, and generic type parameters
// ===================================================================

// type Z = { a: List<Int64> }
// type Y = { z: Z }
// type X = { y: Y }

// (let x = X { y = Y { z = Z { a = [ 1L; 2L; 3L; 4L; 5L ] } } } in (x.y.z.a |> Stdlib.List.length_v0)) = 5

// ===================================================================
// Pipe with enums
// NOTE: Commented out - requires pipe operator, Int64 suffix, and Stdlib support
// ===================================================================

// type MyEnum = A of Int64 * Int64 * Int64
// (33L |> MyEnum.A 21L 42L) = stdout="MyEnum.A(33, 21, 42)\n"
// (33L |> MyEnum.A(21L, 42L)) = stdout="MyEnum.A(33, 21, 42)\n"

// (3L |> Stdlib.Result.Result.Ok) = stdout="Stdlib.Result.Result.Ok(3)\n"

// (4L |> (+) 3L |> Stdlib.Option.Option.Some) = stdout="Stdlib.Option.Option.Some(7)\n"

// (Stdlib.Option.Option.None |> Stdlib.Option.Option.Some) = stdout="Stdlib.Option.Option.Some(Stdlib.Option.Option.None)\n"

// ===================================================================
// Pipe with Option/Result
// NOTE: Partially enabled - some tests require enum printing
// ===================================================================

// (let x = Stdlib.Option.Option.Some 3L in x |> Stdlib.Option.map (fun a -> a) |> Stdlib.Option.map (fun a -> a + 1L)) = stdout="Stdlib.Option.Option.Some(4)\n"

// (let x = fun x -> Stdlib.Option.map x (fun a -> a) in (Stdlib.Option.Option.Some 3L) |> x |> Stdlib.Option.map (fun a -> a + 1L)) = stdout="Stdlib.Option.Option.Some(4)\n"

// Pipe Option to withDefault then add (converted from Dark: (+) 3L)
Option.Some(3) |> Option.withDefault(0) |> ((x: Int64) => x + 3) = 6

// Pipe Result.Ok to withDefault then add
Result.Ok(3) |> Result.withDefault(0) |> ((x: Int64) => x + 3) = 6

// Pipe Result.Error to withDefault (uses default) then add
Result.Error(99) |> Result.withDefault(0) |> ((x: Int64) => x + 3) = 3

// (let x = fun a -> Stdlib.Result.withDefault_v0 a 1L in (Stdlib.Result.Result.Error "err") |> x |> (+) 3L) = 4

// (let x = fun x -> Stdlib.Option.andThen_v0 (Stdlib.Option.Option.Some x) (fun x -> Stdlib.Option.Option.Some(1L + x)) in 3L |> x) = stdout="Stdlib.Option.Option.Some(4)\n"

// (let x = fun x -> Stdlib.Option.andThen_v0 x (fun x -> Stdlib.Option.Option.Some(1L + x)) in 3L |> Stdlib.Option.Option.Some |> x) = stdout="Stdlib.Option.Option.Some(4)\n"

// (3L |> Stdlib.Option.Option.Some |> Stdlib.Result.fromOption "test") = stdout="Stdlib.Result.Result.Ok(3)\n"

// (Stdlib.Option.Option.None |> Stdlib.Result.fromOption "test") = stdout="Stdlib.Result.Result.Error(\"test\")\n"

// ===================================================================
// FnName module tests
// NOTE: Commented out - requires pipe operator, Int64 suffix, and Stdlib support
// ===================================================================

// (let fn = (fun x -> x + 1L) in 6L |> fn) = 7

// (let fn = Stdlib.Int64.add in 3L |> fn 4L) = 7

// (let fn = Stdlib.Int64.subtract in 11L |> fn 4L) = 7

// (let fn = Stdlib.Int64.max in 3L |> fn 7L) = 7
