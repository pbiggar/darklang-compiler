// Tests imported from Dark language test suite
// Source: https://raw.githubusercontent.com/darklang/dark/main/backend/testfiles/execution/language/flow-control/epipe.dark
//
// ALL TESTS INCLUDED - no filtering or removal
// Tests may fail if features are not yet implemented

// ===================================================================
// Basic pipe operations
// NOTE: All tests commented out - requires pipe operator, Int64 suffix, and Stdlib support
// ===================================================================

// Function with pipe
// let userFn () : Int64 = 6L
// (() |> userFn) = 6

// ([] |> Stdlib.List.push_v0 2L) = stdout="[2]\n"

// ===================================================================
// Nested function in pipe
// NOTE: Commented out - requires pipe operator and Stdlib support
// ===================================================================

// ([] |> Stdlib.List.push_v0 (Stdlib.Int64.add_v0 1L (Stdlib.Int64.add_v0 1L 3L))) = stdout="[5]\n"

// ([] |> Stdlib.List.push_v0 (Stdlib.Int64.add_v0 1L ((+) 1L 3L))) = stdout="[5]\n"

// ([] |> Stdlib.List.push_v0 (Builtin.testRuntimeError "err")) = Builtin.testDerrorMessage "Uncaught exception: err"

// ===================================================================
// General pipe usage
// NOTE: Commented out - requires pipe operator and Stdlib support
// ===================================================================

// (4L |> (-) 3L) = 1

// ([ 5L ] |> Stdlib.List.head |> Builtin.unwrap |> Stdlib.Int64.add_v0 1L |> (+) 3L |> (fun x -> if (x + 4L) > 1L then x else (1L + x))) = 9

// Lambda in variable
// (let x = fun a -> a + 1L in (5L |> x |> x |> (+) 3L)) = 10

// Only lambda might be placed into the variable used in the middle of the pipe
// (let x = 1L in (5L |> x |> (+) 3L)) = Builtin.testDerrorMessage "Expected something we could apply to, such as a lambda or function, but got an Int64 (1)"

// ===================================================================
// Pipe with records
// NOTE: Commented out - requires pipe operator, Int64 suffix, and generic type parameters
// ===================================================================

// type Z = { a: List<Int64> }
// type Y = { z: Z }
// type X = { y: Y }

// (let x = X { y = Y { z = Z { a = [ 1L; 2L; 3L; 4L; 5L ] } } } in (x.y.z.a |> Stdlib.List.length_v0)) = 5

// ===================================================================
// Pipe with enums
// NOTE: Commented out - requires pipe operator, Int64 suffix, and Stdlib support
// ===================================================================

// type MyEnum = A of Int64 * Int64 * Int64
// (33L |> MyEnum.A 21L 42L) = stdout="MyEnum.A(33, 21, 42)\n"
// (33L |> MyEnum.A(21L, 42L)) = stdout="MyEnum.A(33, 21, 42)\n"

// (3L |> Stdlib.Result.Result.Ok) = stdout="Stdlib.Result.Result.Ok(3)\n"

// (4L |> (+) 3L |> Stdlib.Option.Option.Some) = stdout="Stdlib.Option.Option.Some(7)\n"

// (Stdlib.Option.Option.None |> Stdlib.Option.Option.Some) = stdout="Stdlib.Option.Option.Some(Stdlib.Option.Option.None)\n"

// ===================================================================
// Pipe with Option/Result
// NOTE: Commented out - requires pipe operator, Int64 suffix, and Stdlib support
// ===================================================================

// (let x = Stdlib.Option.Option.Some 3L in x |> Stdlib.Option.map (fun a -> a) |> Stdlib.Option.map (fun a -> a + 1L)) = stdout="Stdlib.Option.Option.Some(4)\n"

// (let x = fun x -> Stdlib.Option.map x (fun a -> a) in (Stdlib.Option.Option.Some 3L) |> x |> Stdlib.Option.map (fun a -> a + 1L)) = stdout="Stdlib.Option.Option.Some(4)\n"

// ((Stdlib.Option.Option.Some 3L) |> Stdlib.Option.withDefault_v0 0L |> (+) 3L) = 6

// ((Stdlib.Result.Result.Ok 3L) |> Stdlib.Result.withDefault_v0 0L |> (+) 3L) = 6

// ((Stdlib.Result.Result.Error "err") |> Stdlib.Result.withDefault_v0 0L |> (+) 3L) = 3

// (let x = fun a -> Stdlib.Result.withDefault_v0 a 1L in (Stdlib.Result.Result.Error "err") |> x |> (+) 3L) = 4

// (let x = fun x -> Stdlib.Option.andThen_v0 (Stdlib.Option.Option.Some x) (fun x -> Stdlib.Option.Option.Some(1L + x)) in 3L |> x) = stdout="Stdlib.Option.Option.Some(4)\n"

// (let x = fun x -> Stdlib.Option.andThen_v0 x (fun x -> Stdlib.Option.Option.Some(1L + x)) in 3L |> Stdlib.Option.Option.Some |> x) = stdout="Stdlib.Option.Option.Some(4)\n"

// (3L |> Stdlib.Option.Option.Some |> Stdlib.Result.fromOption "test") = stdout="Stdlib.Result.Result.Ok(3)\n"

// (Stdlib.Option.Option.None |> Stdlib.Result.fromOption "test") = stdout="Stdlib.Result.Result.Error(\"test\")\n"

// ===================================================================
// FnName module tests
// NOTE: Commented out - requires pipe operator, Int64 suffix, and Stdlib support
// ===================================================================

// (let fn = (fun x -> x + 1L) in 6L |> fn) = 7

// (let fn = Stdlib.Int64.add in 3L |> fn 4L) = 7

// (let fn = Stdlib.Int64.subtract in 11L |> fn 4L) = 7

// (let fn = Stdlib.Int64.max in 3L |> fn 7L) = 7
