// Tests imported from Dark language test suite
// Source: https://raw.githubusercontent.com/darklang/dark/main/backend/testfiles/execution/language/basic/elet.dark
//
// ALL TESTS INCLUDED - no filtering or removal
// Tests may fail if features are not yet implemented

// ===================================================================
// Simple variables
// NOTE: Commented out - requires Int64 suffix support
// ===================================================================

(let x = 5 in x) = 5

// ===================================================================
// Unit type in let binding
// ===================================================================

(let () = Stdlib.Tuple2.first(((), 5)) in 5) = 5

// ===================================================================
// Stdlib.Tuple2 functions
// ===================================================================

Stdlib.Tuple2.first((1, 2)) = 1
Stdlib.Tuple2.second((1, 2)) = 2
(let t = (10, 20) in Stdlib.Tuple2.first(t) + Stdlib.Tuple2.second(t)) = 30

// ===================================================================
// Tuple destructuring (from Dark)
// ===================================================================

(let (a, b) = (1, 2) in 2) = 2
(let (a, b) = (1, 2) in b) = 2
(let (a, b) = (1, 2) in (b, a)) = stdout="(2, 1)\n"
(let (d, d) = (2, 1) in d) = 1
(let (_, _) = (1, 2) in 2) = 2

(let (a, b, c) = (1, 2, 3) in b) = 2
(let (a, b, c) = (1, 2, 3) in (b, a)) = stdout="(2, 1)\n"
(let (d, d, d) = (2, 1, 3) in d) = 3
(let (_, _, _) = (1, 2, 3) in 2) = 2

// Type error in tuple element is caught at compile time
(let (a, b, c) = (1, 2, true) in a + c) = error="Type mismatch in variable c: expected Int64, got Bool"

// Type error in first tuple element is caught at compile time
(let (a, b, c) = (true, 2, 3) in a + b) = error="Invalid operation '+' on types: Bool"

// Nested tuple destructuring
(let ((a, ((b, (c, d)), e)), f) = ((1, ((2, (3, 4)), 5)), 6) in c) = 3
(let ((a, ((b, (c, d)), e)), f) = ((1, ((2, (3, 4)), 5)), 6) in d) = 4
(let ((a, ((b, (c, d)), e)), f) = ((1, ((2, (3, 4)), 5)), 6) in a + b + c + d + e + f) = 21

// ===================================================================
// Nested let bindings
// ===================================================================

(let x = let y = 1 in let z = 2 in y + z in x) = 3

// ===================================================================
// Shadowing (from Dark)
// ===================================================================

(let x = 5 in let x = 6 in x) = 6

(let x = 35 in match 6 with | x -> x) = 6

// Shadowing with Result type (using generic Stdlib.Result.Result)
// Original Dark test: (let x = 35 in match Stdlib.Result.Result.Ok 6 with | Ok x -> x) = 6
(let x = 35 in match Stdlib.Result.Result.Ok(6) with | Ok(x) -> x | Error(e) -> 0) = 6

// NOTE: List.map tests - converted to use pattern matching for verification

// Variable shadowing in List.map callback (x shadows outer x)
// Dark: (let x = 35 in Stdlib.List.map [ 1; 2; 3; 4 ] (fun x -> x + 2)) = [3, 4, 5, 6]
let x = 35 in match Stdlib.List.map<Int64, Int64>([1, 2, 3, 4], (x: Int64) => x + 2) with | [a, b, c, d] -> a + b + c + d | _ -> 0 = 18

// Shadowing with Result inside List.map
// Dark: (Stdlib.List.map [ 1; 2; 3; 4 ] (fun x -> (let x = 35 in match Stdlib.Result.Result.Ok 6 with | Ok x -> x + 2))) = [8, 8, 8, 8]
match Stdlib.List.map<Int64, Int64>([1, 2, 3, 4], (x: Int64) => let x = 35 in match Stdlib.Result.Result.Ok(6) with | Ok(x) -> x + 2 | Error(e) -> 0) with | [a, b, c, d] -> a + b + c + d | _ -> 0 = 32

// Shadowing with let inside match inside List.map
// Dark: (Stdlib.List.map [ 1; 2; 3; 4 ] (fun x -> match Stdlib.Result.Result.Ok 6 with | Ok x -> let x = 9 in x + 2)) = [11, 11, 11, 11]
match Stdlib.List.map<Int64, Int64>([1, 2, 3, 4], (x: Int64) => match Stdlib.Result.Result.Ok(6) with | Ok(x) -> let x = 9 in x + 2 | Error(e) -> 0) with | [a, b, c, d] -> a + b + c + d | _ -> 0 = 44

// Nested Result matching with shadowing
// Dark: (Stdlib.List.map [ 1; 2; 3; 4 ] (fun x -> (match Stdlib.Result.Result.Ok(Stdlib.Result.Result.Ok 6) with | Ok(Ok x) -> let x = 9 in x + 2))) = [11, 11, 11, 11]
match Stdlib.List.map<Int64, Int64>([1, 2, 3, 4], (x: Int64) => match Stdlib.Result.Result.Ok(Stdlib.Result.Result.Ok(6)) with | Ok(Ok(x)) -> let x = 9 in x + 2 | Ok(Error(e)) -> 0 | Error(e) -> 0) with | [a, b, c, d] -> a + b + c + d | _ -> 0 = 44

// ===================================================================
// Destructuring errors
// ===================================================================

(let (a, _) = 1 in a) = error="Tuple pattern used on non-tuple type"
(let (a, _) = (1, 2, 3) in a) = error="Tuple pattern has 2 elements but type has 3"

// ===================================================================
// Additional tests (from our extended suite)
// ===================================================================

// Simple Variable Binding
(let x = 5 in x) = 5
(let x = 42 in x) = 42
(let x = 0 in x) = 0

// Binding with expression
(let x = 2 + 3 in x) = 5
(let x = 10 * 4 in x) = 40
(let x = 100 - 58 in x) = 42

// Nested Let Bindings
(let x = 5 in let y = 10 in x + y) = 15
(let a = 3 in let b = 4 in a * b) = 12
(let x = 1 in let y = 2 in let z = 3 in x + y + z) = 6

// Using outer binding in inner
(let x = 10 in let y = x + 5 in y) = 15
(let x = 5 in let y = x * 2 in let z = y + 1 in z) = 11

// Variable Shadowing
(let x = 5 in let x = 10 in x) = 10
(let x = 1 in let x = 2 in let x = 3 in x) = 3
(let x = 100 in let x = 1 in x + 1) = 2
(let x = 5 in let y = x in let x = 10 in y) = 5

// Shadowing in Match Expressions
(let x = 1 in match 2 with | x -> x) = 2
(let x = 100 in match 42 with | x -> x + 1) = 43

// Let with Arithmetic
(let x = 5 in x + x) = 10
(let x = 3 in x * x) = 9
(let x = 10 in x - 3) = 7
(let x = 20 in x / 4) = 5
(let x = 5 in let y = 3 in x * y + x) = 20
(let a = 2 in let b = 3 in let c = 4 in a * b * c) = 24

// Let with Comparisons
(let x = 5 in x > 3) = stdout="true\n"
(let x = 5 in x < 3) = stdout="false\n"
(let x = 5 in let y = 5 in x == y) = stdout="true\n"
(let x = 5 in let y = 6 in x != y) = stdout="true\n"

// Let with Boolean Operations
(let x = true in x && true) = stdout="true\n"
(let x = false in x || true) = stdout="true\n"
(let x = true in let y = false in x && y) = stdout="false\n"
(let x = true in let y = false in x || y) = stdout="true\n"

// Let in Control Flow
(let x = 5 in if x > 3 then 1 else 0) = 1
(let x = 2 in if x > 3 then 1 else 0) = 0
(let x = true in if x then 42 else 0) = 42
(if true then let x = 1 in x else let x = 2 in x) = 1
(if false then let x = 1 in x else let x = 2 in x) = 2

// Tuple Destructuring
(let (a, b) = (1, 2) in a + b) = 3
(let (x, y) = (10, 20) in x * y) = 200
(let (a, b, c) = (1, 2, 3) in a + b + c) = 6
(let (x, _) = (42, 99) in x) = 42
(let (_, y) = (99, 42) in y) = 42
(let (_, _, z) = (1, 2, 3) in z) = 3

// Let with Functions
// NOTE: Cannot use parens around let expression after function def due to parsing ambiguity
def double(x: Int64): Int64 = x * 2 let y = 5 in double(y) = 10
def add(a: Int64, b: Int64): Int64 = a + b let x = 3 in let y = 4 in add(x, y) = 7

// Complex Expressions
(let x = 5 in let y = x + 1 in let z = y * 2 in z) = 12
(let x = 42 in match x with | 42 -> 1 | _ -> 0) = 1
(let t = (1, 2) in match t with | (a, b) -> a + b) = 3

// Edge Cases
(let x = 0 in x) = 0
(let x = 0 - 5 in x) = -5
(let x = 1000000 in x) = 1000000
(let x = 1 in x) = 1
(let a = 1 in let b = 2 in let c = 3 in let d = 4 in let e = 5 in a + b + c + d + e) = 15
