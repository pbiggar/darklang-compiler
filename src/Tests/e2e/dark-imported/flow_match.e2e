// Tests imported from Dark language test suite
// Source: https://github.com/darklang/dark/blob/main/backend/testfiles/execution/language/flow-control/ematch.dark
//
// ALL TESTS INCLUDED - no filtering or removal
// Tests may fail if features are not yet implemented

// ===================================================================
// Integer Literal Patterns
// ===================================================================

// Basic integer matching
match 5 with | 5 -> 1 | _ -> 0 = 1
match 5 with | 4 -> 1 | _ -> 0 = 0
match 0 with | 0 -> 1 | _ -> 0 = 1
match 42 with | 42 -> 100 | _ -> 0 = 100

// Multiple integer cases
match 2 with | 1 -> 10 | 2 -> 20 | 3 -> 30 | _ -> 0 = 20
match 3 with | 1 -> 10 | 2 -> 20 | 3 -> 30 | _ -> 0 = 30
match 5 with | 1 -> 10 | 2 -> 20 | 3 -> 30 | _ -> 99 = 99

// Large integers
match 1000000 with | 1000000 -> 1 | _ -> 0 = 1
match 999999 with | 1000000 -> 1 | _ -> 0 = 0

// ===================================================================
// Boolean Patterns
// ===================================================================

match true with | true -> 1 | false -> 0 = 1
match false with | true -> 1 | false -> 0 = 0
match true with | false -> 0 | true -> 1 = 1
match false with | false -> 1 | true -> 0 = 1

// Boolean from expression
match (5 > 3) with | true -> 1 | false -> 0 = 1
match (3 > 5) with | true -> 1 | false -> 0 = 0
match (5 == 5) with | true -> 1 | false -> 0 = 1

// ===================================================================
// Variable Patterns
// ===================================================================

// Variable captures any value
match 42 with | x -> x = 42
match 100 with | n -> n + 1 = 101
match 5 with | x -> x * x = 25

// Variable after literal patterns (fallback)
match 7 with | 1 -> 10 | 2 -> 20 | x -> x * 100 = 700
match 2 with | 1 -> 10 | 2 -> 20 | x -> x * 100 = 20

// ===================================================================
// Wildcard Patterns
// ===================================================================

// Wildcard matches anything
match 42 with | _ -> 1 = 1
match 999 with | _ -> 100 = 100

// Wildcard as fallback
match 5 with | 1 -> 10 | 2 -> 20 | _ -> 99 = 99
match 1 with | 1 -> 10 | 2 -> 20 | _ -> 99 = 10

// ===================================================================
// Tuple Patterns
// ===================================================================

// Basic tuple extraction
match (1, 2) with | (a, b) -> a + b = 3
match (10, 20) with | (a, b) -> a * b = 200

// 3-tuple
match (1, 2, 3) with | (a, b, c) -> a + b + c = 6

// 4-tuple
match (1, 2, 3, 4) with | (a, b, c, d) -> a + b + c + d = 10

// 5-tuple
match (1, 2, 3, 4, 5) with | (a, b, c, d, e) -> a + b + c + d + e = 15

// Wildcards in tuple
match (1, 2) with | (x, _) -> x = 1
match (1, 2) with | (_, y) -> y = 2
match (1, 2, 3) with | (_, x, _) -> x = 2
match (1, 2, 3) with | (_, _, _) -> 100 = 100

// Computed tuple elements
match (5 + 5, 3 * 4) with | (a, b) -> a * b = 120
let x = 5 in match (x, x + 1) with | (a, b) -> a + b = 11

// ===================================================================
// List Patterns
// ===================================================================

// Empty list
match [] with | [] -> 1 | _ -> 0 = 1

// Single element
match [42] with | [x] -> x | _ -> 0 = 42
match [5] with | [x] -> x * 2 | _ -> 0 = 10

// Two elements
match [1, 2] with | [a, b] -> a + b | _ -> 0 = 3

// Three elements
match [1, 2, 3] with | [a, b, c] -> a + b + c | _ -> 0 = 6

// Length mismatch - falls through
match [1] with | [a, b] -> a + b | _ -> 99 = 99
match [1, 2] with | [a] -> a | _ -> 99 = 99
match [1, 2, 3] with | [a, b] -> a + b | _ -> 99 = 99

// Wildcards in list
match [1, 2, 3] with | [x, _, _] -> x | _ -> 0 = 1
match [1, 2, 3] with | [_, _, z] -> z | _ -> 0 = 3
match [1, 2, 3] with | [_, y, _] -> y | _ -> 0 = 2

// Cons patterns
match [1, 2, 3] with | [h, ...t] -> h | [] -> 0 = 1
match [] with | [h, ...t] -> h | [] -> 0 = 0
match [42] with | [h, ...t] -> h | [] -> 0 = 42

// ===================================================================
// ADT/Enum Patterns
// ===================================================================

// Simple enum
type Color = Red | Green | Blue match Red with | Red -> 1 | Green -> 2 | Blue -> 3 = 1
type Color = Red | Green | Blue match Green with | Red -> 1 | Green -> 2 | Blue -> 3 = 2
type Color = Red | Green | Blue match Blue with | Red -> 1 | Green -> 2 | Blue -> 3 = 3

// Wildcard with enum
type Color = Red | Green | Blue match Green with | Red -> 1 | _ -> 99 = 99

// Enum with payload
type MyOption = MyNone | MySome of Int64 match MySome(42) with | MySome(x) -> x | MyNone -> 0 = 42
type MyOption = MyNone | MySome of Int64 match MyNone with | MySome(x) -> x | MyNone -> 99 = 99

// Extract and use payload
type MyOption = MyNone | MySome of Int64 match MySome(10) with | MySome(x) -> x * 2 | MyNone -> 0 = 20

// Two payload variants
type Either = Left of Int64 | Right of Int64 match Left(5) with | Left(x) -> x | Right(y) -> y = 5
type Either = Left of Int64 | Right of Int64 match Right(7) with | Left(x) -> x | Right(y) -> y = 7

// ===================================================================
// Record Patterns
// ===================================================================

// Simple record
type Point = { x: Int64, y: Int64 } match Point { x = 10, y = 20 } with | Point { x = a, y = b } -> a + b = 30

// Extract one field
type Point = { x: Int64, y: Int64 } match Point { x = 5, y = 10 } with | Point { x = n, y = _ } -> n = 5
type Point = { x: Int64, y: Int64 } match Point { x = 5, y = 15 } with | Point { x = _, y = m } -> m = 15

// Three-field record
type Vec3 = { x: Int64, y: Int64, z: Int64 } match Vec3 { x = 1, y = 2, z = 3 } with | Vec3 { x = a, y = b, z = c } -> a + b + c = 6

// Record in variable
type Point = { x: Int64, y: Int64 } let p = Point { x = 3, y = 4 } in match p with | Point { x = a, y = b } -> a * a + b * b = 25

// ===================================================================
// Nested Patterns
// ===================================================================

// Match result of match
match 1 with | 1 -> match 2 with | 2 -> 100 | _ -> 0 | _ -> 0 = 100

// Deeply nested matches
match 1 with | 1 -> match 2 with | 2 -> match 3 with | 3 -> 42 | _ -> 0 | _ -> 0 | _ -> 0 = 42

// Tuple in ADT
type Box = Empty | Pair of Int64 match Pair(42) with | Pair(n) -> let t = (n, n + 1) in match t with | (a, b) -> a + b | Empty -> 0 = 85

// ===================================================================
// Match with Computations in Body
// ===================================================================

// Arithmetic in body
match 5 with | 5 -> 10 + 20 | _ -> 0 = 30
match 5 with | x -> x * x + x = 30

// Let in body
match 42 with | x -> let y = x + 1 in y = 43
match (3, 4) with | (a, b) -> let c = a * b in c + 1 = 13

// If in body
match (5, 10) with | (a, b) -> if a < b then b else a = 10

// Match in body (nested)
match 1 with | 1 -> match true with | true -> 42 | false -> 0 | _ -> 0 = 42

// ===================================================================
// Match with Variables
// ===================================================================

// Scrutinee from variable
let x = 42 in match x with | 42 -> 1 | _ -> 0 = 1
let x = 5 in let y = 10 in match x + y with | 15 -> 1 | _ -> 0 = 1

// Pattern variable shadows outer
let x = 1 in match 2 with | x -> x = 2
let x = 100 in match 42 with | x -> x + 1 = 43

// ===================================================================
// Complex Expression Tests
// ===================================================================

// Boolean operations in scrutinee
match (5 > 3) && (10 > 1) with | true -> 1 | false -> 0 = 1
match (1 > 10) || (10 > 1) with | true -> 42 | false -> 0 = 42

// Comparison result in body
let x = 5 in let y = 5 in match x == y with | true -> 1000 | false -> 0 = 1000

// ===================================================================
// Edge Cases
// ===================================================================

// Single pattern (must be exhaustive)
match 42 with | x -> x = 42
match 999 with | _ -> 1 = 1

// First matching pattern wins
match 1 with | 1 -> 100 | 2 -> 200 | _ -> 0 = 100
match 99 with | 1 -> 100 | 2 -> 200 | n -> n = 99

// Zero
match 0 with | 0 -> 1 | _ -> 0 = 1

// Negative (via subtraction)
let x = 0 - 5 in match x with | x -> x + 10 = 5

// ===================================================================
// Int64 Matching (from Dark ematch.dark)
// Converted: removed L suffix (Int64 is default)
// ===================================================================

(match 6 with | 5 -> "fail" | -6 -> "fail" | 6 -> "pass" | var -> "fail") = stdout="pass\n"
(match 6 with | 6 -> "pass" | 5 -> "fail" | var -> "fail") = stdout="pass\n"
(match 6 with | var -> "pass" | 6 -> "fail" | 5 -> "fail") = stdout="pass\n"
(match 999999999999999 with | 0 -> "fail" | 999999999999999 -> "pass") = stdout="pass\n"

// ===================================================================
// UInt64 Matching
// ===================================================================

(match 6UL with | 5UL -> "fail" | 6UL -> "pass" | var -> "fail") = stdout="pass\n"
(match 6UL with | 6UL -> "pass" | 5UL -> "fail" | var -> "fail") = stdout="pass\n"
(match 6UL with | var -> "pass" | 6UL -> "fail" | 5UL -> "fail") = stdout="pass\n"
// NOTE: 18446744073709551615UL exceeds Int64 range, skipping

// ===================================================================
// Int8 Matching
// ===================================================================

(match 6y with | 5y -> "fail" | -6y -> "fail" | 6y -> "pass" | var -> "fail") = stdout="pass\n"
(match 6y with | 6y -> "pass" | 5y -> "fail" | var -> "fail") = stdout="pass\n"
(match 6y with | var -> "pass" | 6y -> "fail" | 5y -> "fail") = stdout="pass\n"
(match 127y with | 0y -> "fail" | 127y -> "pass") = stdout="pass\n"

// ===================================================================
// UInt8 Matching
// ===================================================================

(match 6uy with | 5uy -> "fail" | 6uy -> "pass" | var -> "fail") = stdout="pass\n"
(match 6uy with | 6uy -> "pass" | 5uy -> "fail" | var -> "fail") = stdout="pass\n"
(match 6uy with | var -> "pass" | 6uy -> "fail" | 5uy -> "fail") = stdout="pass\n"
(match 255uy with | 0uy -> "fail" | 255uy -> "pass") = stdout="pass\n"

// ===================================================================
// Int16 Matching
// ===================================================================

(match 6s with | 5s -> "fail" | -6s -> "fail" | 6s -> "pass" | var -> "fail") = stdout="pass\n"
(match 6s with | 6s -> "pass" | 5s -> "fail" | var -> "fail") = stdout="pass\n"
(match 6s with | var -> "pass" | 6s -> "fail" | 5s -> "fail") = stdout="pass\n"
(match 32767s with | 0s -> "fail" | 32767s -> "pass") = stdout="pass\n"

// ===================================================================
// UInt16 Matching
// ===================================================================

(match 6us with | 5us -> "fail" | 6us -> "pass" | var -> "fail") = stdout="pass\n"
(match 6us with | 6us -> "pass" | 5us -> "fail" | var -> "fail") = stdout="pass\n"
(match 6us with | var -> "pass" | 6us -> "fail" | 5us -> "fail") = stdout="pass\n"
(match 65535us with | 0us -> "fail" | 65535us -> "pass") = stdout="pass\n"

// ===================================================================
// Int32 Matching
// ===================================================================

(match 6l with | 5l -> "fail" | -6l -> "fail" | 6l -> "pass" | var -> "fail") = stdout="pass\n"
(match 6l with | 6l -> "pass" | 5l -> "fail" | var -> "fail") = stdout="pass\n"
(match 6l with | var -> "pass" | 6l -> "fail" | 5l -> "fail") = stdout="pass\n"
(match 2147483647l with | 0l -> "fail" | 2147483647l -> "pass") = stdout="pass\n"

// ===================================================================
// UInt32 Matching
// ===================================================================

(match 6ul with | 5ul -> "fail" | 6ul -> "pass" | var -> "fail") = stdout="pass\n"
(match 6ul with | 6ul -> "pass" | 5ul -> "fail" | var -> "fail") = stdout="pass\n"
(match 6ul with | var -> "pass" | 6ul -> "fail" | 5ul -> "fail") = stdout="pass\n"
(match 4294967295ul with | 0ul -> "fail" | 4294967295ul -> "pass") = stdout="pass\n"

// ===================================================================
// Int128 Matching
// NOTE: Commented out - requires Int128 literal suffix support
// ===================================================================

// (match 6Q with | 5Q -> "fail" | -6Q -> "fail" | 6Q -> "pass" | var -> "fail") = "pass"
// (match 6Q with | 6Q -> "pass" | 5Q -> "fail" | var -> "fail") = "pass"
// (match 6Q with | var -> "pass" | 6Q -> "fail" | 5Q -> "fail") = "pass"
// (match 170141183460469231731687303715884105727Q with | 0Q -> "fail" | 170141183460469231731687303715884105727Q -> "pass") = "pass"

// ===================================================================
// UInt128 Matching
// NOTE: Commented out - requires UInt128 literal suffix support
// ===================================================================

// (match 6Z with | 5Z -> "fail" | 6Z -> "pass" | var -> "fail") = "pass"
// (match 6Z with | 6Z -> "pass" | 5Z -> "fail" | var -> "fail") = "pass"
// (match 6Z with | var -> "pass" | 6Z -> "fail" | 5Z -> "fail") = "pass"
// (match 340282366920938463463374607431768211455Z with | 0Z -> "fail" | 340282366920938463463374607431768211455Z -> "pass") = "pass"

// ===================================================================
// Float Matching
// NOTE: Negative float patterns not supported in parser
// ===================================================================

(match 6.5 with | 5.5 -> "fail" | 6.5 -> "pass" | var -> "fail") = stdout="pass\n"
(match 6.5 with | 6.5 -> "pass" | 5.5 -> "fail" | var -> "fail") = stdout="pass\n"
(match 6.5 with | var -> "pass" | 6.5 -> "fail" | 5.5 -> "fail") = stdout="pass\n"
(match 3.14 with | 3.14 -> "pass" | _ -> "fail") = stdout="pass\n"
(match 0.5 with | 0.5 -> "pass" | _ -> "fail") = stdout="pass\n"

// ===================================================================
// Char Matching
// NOTE: Commented out - requires Char literal support
// ===================================================================

// (match 'a' with | 'b' -> "fail" | 'a' -> "pass" | var -> "fail") = "pass"
// (match 'a' with | 'a' -> "pass" | 'b' -> "fail" | var -> "fail") = "pass"
// (match 'a' with | var -> $"pass: {Stdlib.Char.toString var}" | 'a' -> "fail" | 'b' -> "fail") = "pass: a"
// (match 'c' with | 'd' -> "fail" | 'c' -> "pass" | var -> "fail") = "pass"
// (match 'c' with | var -> $"pass" | 'c' -> "fail" | 'd' -> "fail") = "pass"

// ===================================================================
// Guard Clauses (when expressions)
// ===================================================================

// Basic guard clause tests (without L suffix since Int64 is default)
match 5 with | x when x > 0 -> 1 | _ -> 0 = 1
match 0 - 5 with | x when x > 0 -> 1 | _ -> 0 = 0
match 10 with | x when x > 5 -> 100 | _ -> 0 = 100
match 3 with | x when x > 5 -> 100 | _ -> 0 = 0

// Guard with variable pattern that falls through
match 5 with | x when x < 0 -> 1 | y -> y + 10 = 15
match 0 - 10 with | x when x < 0 -> 1 | y -> y + 10 = 1

// Multiple guards
match 5 with | x when x > 10 -> 1 | x when x > 0 -> 2 | _ -> 3 = 2
match 15 with | x when x > 10 -> 1 | x when x > 0 -> 2 | _ -> 3 = 1
match 0 - 5 with | x when x > 10 -> 1 | x when x > 0 -> 2 | _ -> 3 = 3

// Guard with tuple pattern
match (5, 10) with | (a, b) when a + b > 10 -> 1 | _ -> 0 = 1
match (2, 3) with | (a, b) when a + b > 10 -> 1 | _ -> 0 = 0

// NOTE: Original Dark tests with L suffix (commented for reference)
// (match 5L with | x when x > 0L -> true | _ -> false) = stdout="true\n"
// (match -5L with | x when x > 0L -> true | _ -> false) = stdout="false\n"
// (match 6L with | x when x == 5L -> "fail" | -6L -> "fail" | 6L -> "pass" | var -> "fail") = "pass"
// (match 5L with | x when x > 0L -> "positive" | x when x < 0L -> "negative" | _ -> false) = "positive"
// (match (5L, "hello") with | (x, y) when x > 0L && y == "hello" -> "pass" | _ -> "fail") = "pass"
// (match (5L, "hello") with | (x, y) when x > 0L && y == "hello" -> "first matching branch" | (x, y) when x == 5L && y == "hello" -> "second matching branch" | _ -> "fail") = "first matching branch"
// (match (-5L, "hello") with | (x, y) when x > 0L && y == "hello" -> "pass" | _ -> "fail") = "fail"
// (match (5L, "hello") with | (x, y) when x > 0L && Stdlib.String.length y == 5L -> "pass" | _ -> "fail") = "pass"
// (match -5L with | x when y > 0L -> true | _ -> false) = Builtin.testDerrorMessage "There is no variable named: y"
// (match 5L with | 5L -> false | x when y > 0L -> true) = stdout="false\n"
// (match 5L with | x when (x + 1L) == 6L -> true | 5L -> false) = stdout="true\n"
// (match 5L with | (x, y) when x > 0L -> true | _ -> false) = stdout="false\n"
// (match 5L with | 2L when x > 2L -> false | 3L -> true) = Builtin.testDerrorMessage "No matching case found for value 5 in match expression"
// (match Stdlib.Result.Result.Error 5L with | Ok x when x > 2L -> false | Error _ -> true) = stdout="true\n"

// ===================================================================
// Pattern Grouping (| in patterns)
// ===================================================================

// Basic pattern grouping tests (without L suffix)
// NOTE: Pattern grouping with literals works by ORing conditions
match 1 with | 1 | 2 | 3 -> 100 | _ -> 0 = 100
match 2 with | 1 | 2 | 3 -> 100 | _ -> 0 = 100
match 3 with | 1 | 2 | 3 -> 100 | _ -> 0 = 100
match 4 with | 1 | 2 | 3 -> 100 | _ -> 0 = 0

// Pattern grouping as fallback
match 5 with | 1 -> 10 | 2 | 3 | 4 -> 20 | _ -> 99 = 99
match 2 with | 1 -> 10 | 2 | 3 | 4 -> 20 | _ -> 99 = 20

// Multiple groups
match 6 with | 1 | 2 -> 10 | 3 | 4 -> 20 | 5 | 6 -> 30 | _ -> 0 = 30

// Pattern grouping with tuples
(match (1, 2) with | (1, 2) | (2, 1) -> "pass" | _ -> "fail") = stdout="pass\n"
(match (1, 3) with | (1, 2) | (2, 1) -> "pass" | _ -> "fail") = stdout="fail\n"
(match (1, 2) with | (1, _) | (_, 1) -> "pass" | _ -> "fail") = stdout="pass\n"

// Pattern grouping with lists
(match [1, 2] with | [1, _] | [_, 1] -> "pass" | _ -> "fail") = stdout="pass\n"

// Pattern grouping with let binding
(let x = 4 in match x with | 1 | 2 | 3 | 4 -> "pass" | _ -> "fail") = stdout="pass\n"

// Pattern grouping across multiple branches
(match 5 with | 1 | 2 | 3 -> "fail" | 4 | 5 | 6 -> "pass" | _ -> "fail") = stdout="pass\n"

// Pattern grouping with guard clause
(match 5 with | 4 | 5 | 6 when true -> "pass" | _ -> "fail") = stdout="pass\n"
// (match (1L,2L) with | (x,2L) | (2L,x) when x == 1L -> "pass" | _ -> "fail") = "pass"
// (match (1L, 2L, 3L) with | (x, 2L, y) | (y, x, 2L) when x + y == 4L -> "pass" | _ -> "fail") = "pass"
// (match ([1L;2L], 3L) with | ([x], y) | (x :: xs, y) when x > 0L -> "pass" | _ -> "fail") = "pass"
// (match (1L,2L) with | (x,2L) | (2L,y) when x == y -> "fail" | _ -> "fail") = Builtin.testDerrorMessage "There is no variable named: x"
// (match (1L,2L) with | (x,y) | (x,_) when y > 0L -> "fail" | _ -> "pass") = Builtin.testDerrorMessage "There is no variable named: y"
// (match [1L;2L] with | [x;y] | x::y -> "fail" | _ -> "pass") = "fail"
// (match (1L, "test") with | (x, "test") | ("test", x) -> x | _ -> "fail") = 1
// (match (Stdlib.Result.Result.Ok 1L, Stdlib.Result.Result.Error "error") with | (Ok _ , Ok _) -> "pass" | (Error err, Ok _) | (Ok _, Error err) -> err) = "error"
// (match (Stdlib.Result.Result.Error "error", Stdlib.Result.Result.Ok 1L) with | (Ok _ , Ok _) -> "pass" | (Error err, Ok _) | (Ok _, Error err) -> err) = "error"

// ===================================================================
// Runtime Error Tests (Builtin.testRuntimeError)
// NOTE: Commented out - requires Builtin.testRuntimeError support
// ===================================================================

// (match Builtin.testRuntimeError "cond is error" with | 5L -> "fail" | 6L -> "pass" | var -> "fail") = Builtin.testDerrorMessage "Uncaught exception: cond is error"
// (match Builtin.testRuntimeError "cond is error, wildcard" with | 5L -> 5L | _ -> 6L) = Builtin.testDerrorMessage "Uncaught exception: cond is error, wildcard"
// (match 1L with | 1L -> Builtin.testRuntimeError "a" | 6L -> "pass" | var -> "fail") = Builtin.testDerrorMessage "Uncaught exception: a"
// (match 1L with | 2L -> Builtin.testRuntimeError "Uncaught exception: a" | 1L -> "pass" | var -> "fail") = "pass"
// (match 1L with | 1L -> "pass" | 6L -> Builtin.testRuntimeError "a" | var -> "fail") = "pass"
// (match 1L with | 2L -> "pass" | 1L -> Builtin.testRuntimeError "a" | var -> "fail") = Builtin.testDerrorMessage "Uncaught exception: a"
// (match 3L with | 2L -> "pass" | 1L -> Builtin.testRuntimeError "a" | var -> "pass") = "pass"
