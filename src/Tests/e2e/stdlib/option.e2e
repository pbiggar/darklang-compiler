// Stdlib.Option Tests
// Ported from https://github.com/darklang/dark/tree/main/backend/testfiles/execution/stdlib
//
// Tests for Option module functions

// ===================================================================
// Option.isSome - Returns true if the option is Some
// ===================================================================

Option.isSome(Option.Some(5)) = stdout="true\n"
// Unresolved type variable is defaulted to Int64 during monomorphization
Option.isSome(Option.None) = stdout="false\n"

// ===================================================================
// Option.isNone - Returns true if the option is None
// ===================================================================

Option.isNone(Option.Some(5)) = stdout="false\n"
// Unresolved type variable is defaulted to Int64 during monomorphization
Option.isNone(Option.None) = stdout="true\n"

// ===================================================================
// Option.withDefault - Returns the value or a default
// ===================================================================

Option.withDefault(Option.Some(5), 0) = 5
Option.withDefault(Option.None, 42) = 42

// ===================================================================
// Option.map - Apply a function to the value if Some
// ===================================================================

Option.withDefault(Option.map(Option.Some(5), (x: Int64) => x + 1), 0) = 6
Option.isNone(Option.map(Option.None, (x: Int64) => x + 1)) = stdout="true\n"

// ===================================================================
// Option.andThen - Chain Option computations
// ===================================================================

Option.withDefault(Option.andThen(Option.Some(5), (x: Int64) => Option.Some(x * 2)), 0) = 10
Option.isNone(Option.andThen(Option.None, (x: Int64) => Option.Some(x * 2))) = stdout="true\n"
// NOTE: Needs type params because the lambda returns None which doesn't constrain the output type
Option.isNone(Option.andThen<Int64, Int64>(Option.Some(5), (x: Int64) => Option.None)) = stdout="true\n"

// ===================================================================
// Option.toList - Convert to a list
// ===================================================================

List.length(Option.toList(Option.Some(42))) = stdout="1\n"
List.isEmpty(Option.toList(Option.None)) = stdout="true\n"

// ===================================================================
// Pipe operator with Option functions
// ===================================================================

Option.Some(42) |> Option.isSome() = stdout="true\n"
Option.None |> Option.isNone() = stdout="true\n"
Option.Some(10) |> Option.map((x: Int64) => x * 2) |> Option.withDefault(0) = 20

// ===================================================================
// Unresolved type variable resolved later by context
// Tests that type variables unify correctly with all types
// ===================================================================

// Int64
let x = Option.None in Option.withDefault(x, 42) = 42

// String
let x = Option.None in Option.withDefault(x, "hello") = stdout="hello\n"

// Bool
let x = Option.None in Option.withDefault(x, true) = stdout="true\n"

// Float64
// TODO: Runtime bug - outputs 0.00 instead of 3.14 (being fixed in another branch)
// let x = Option.None in Option.withDefault(x, 3.14) = stdout="3.14\n"

// Char
let x = Option.None in Option.withDefault(x, 'a') = stdout="a\n"

// Unit
// TODO: Runtime bug - outputs nothing instead of () (being fixed in another branch)
// let x = Option.None in Option.withDefault(x, ()) = stdout="()\n"

// Int8
let x = Option.None in Option.withDefault(x, 42y) = stdout="42\n"

// Int16
let x = Option.None in Option.withDefault(x, 42s) = stdout="42\n"

// Int32
let x = Option.None in Option.withDefault(x, 42l) = stdout="42\n"

// UInt8
let x = Option.None in Option.withDefault(x, 42uy) = stdout="42\n"

// UInt16
let x = Option.None in Option.withDefault(x, 42us) = stdout="42\n"

// UInt32
let x = Option.None in Option.withDefault(x, 42ul) = stdout="42\n"

// UInt64
let x = Option.None in Option.withDefault(x, 42UL) = stdout="42\n"

// Tuple
// TODO: Runtime bug - outputs (0, 2) instead of (1, 2) (being fixed in another branch)
// let x = Option.None in Option.withDefault(x, (1, 2)) = stdout="(1, 2)\n"

// Tuple3
// TODO: Runtime bug - outputs (0, 2, 3) instead of (1, 2, 3) (being fixed in another branch)
// let x = Option.None in Option.withDefault(x, (1, 2, 3)) = stdout="(1, 2, 3)\n"

// List
let x = Option.None in List.length(Option.withDefault(x, [1, 2, 3])) = stdout="3\n"

// Nested Option (Option<Option<Int64>>)
let x = Option.None in Option.isSome(Option.withDefault(x, Option.Some(42))) = stdout="true\n"

// Result
let x = Option.None in Result.isOk(Option.withDefault(x, Result.Ok(42))) = stdout="true\n"

