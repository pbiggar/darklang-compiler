// Stdlib.Base64 Tests
// Tests for Base64 encoding and decoding
//
// NOTE: Most Base64 tests are commented out due to compiler limitation:
// "StringRef/Float in TailArgMoves not yet supported"
// The Base64 module implementation is correct but requires compiler support
// for string references in tail call argument moves.

// ===================================================================
// Base64.encode - Encode bytes to base64 string
// ===================================================================

// TODO: Uncomment when compiler supports StringRef in TailArgMoves
// Empty bytes
// Base64.encode(Bytes.create(0)) = stdout="\n"

// Single byte
// Base64.encode(Bytes.fromList([0])) = stdout="AA==\n"
// Base64.encode(Bytes.fromList([255])) = stdout="/w==\n"

// Two bytes
// Base64.encode(Bytes.fromList([0, 0])) = stdout="AAA=\n"

// Three bytes (no padding needed)
// Base64.encode(Bytes.fromList([0, 0, 0])) = stdout="AAAA\n"

// "Hello" = [72, 101, 108, 108, 111]
// Base64.encode(Bytes.fromList([72, 101, 108, 108, 111])) = stdout="SGVsbG8=\n"

// "Hi" = [72, 105]
// Base64.encode(Bytes.fromList([72, 105])) = stdout="SGk=\n"

// "ABC" = [65, 66, 67]
// Base64.encode(Bytes.fromList([65, 66, 67])) = stdout="QUJD\n"

// ===================================================================
// Base64.urlEncode - URL-safe encoding
// ===================================================================

// Test that + and / are replaced with - and _
// Bytes that would produce + in standard encoding
// Base64.urlEncode(Bytes.fromList([251])) = stdout="-w==\n"

// ===================================================================
// Base64.decode - Decode base64 to bytes
// ===================================================================

// Empty string
Result.isOk<Bytes, String>(Base64.decode("")) = stdout="true\n"

// Single padded value
match Base64.decode("AA==") with | Ok(b) -> Bytes.length(b) | Error(_) -> -1 = stdout="1\n"
match Base64.decode("AA==") with | Ok(b) -> Bytes.get(b, 0) | Error(_) -> -1 = 0

// Two bytes
match Base64.decode("AAA=") with | Ok(b) -> Bytes.length(b) | Error(_) -> -1 = stdout="2\n"

// Three bytes
match Base64.decode("AAAA") with | Ok(b) -> Bytes.length(b) | Error(_) -> -1 = stdout="3\n"

// TODO: Uncomment when compiler supports StringRef in TailArgMoves
// "SGVsbG8=" -> "Hello"
// match Base64.decode("SGVsbG8=") with | Ok(b) -> Bytes.length(b) | Error(_) -> -1 = stdout="5\n"
// match Base64.decode("SGVsbG8=") with | Ok(b) -> Bytes.get(b, 0) | Error(_) -> -1 = 72
// match Base64.decode("SGVsbG8=") with | Ok(b) -> Bytes.get(b, 4) | Error(_) -> -1 = 111

// Invalid base64 - wrong length
Result.isError<Bytes, String>(Base64.decode("ABC")) = stdout="true\n"

// ===================================================================
// Roundtrip tests
// ===================================================================

// TODO: Uncomment when compiler supports StringRef in TailArgMoves
// Encode then decode should give back original bytes
// match Base64.decode(Base64.encode(Bytes.fromList([1, 2, 3]))) with | Ok(b) -> Bytes.get(b, 0) | Error(_) -> -1 = 1
// match Base64.decode(Base64.encode(Bytes.fromList([1, 2, 3]))) with | Ok(b) -> Bytes.get(b, 2) | Error(_) -> -1 = 3
