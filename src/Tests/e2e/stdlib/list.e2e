// Stdlib.List Tests
// Ported from https://github.com/darklang/dark/tree/main/backend/testfiles/execution/stdlib
//
// Tests for List module functions
//
// NOTE: Many List functions are commented out because the compiler doesn't support
// list construction with spread syntax. [h, ...rest] only works in pattern matching,
// not in list construction. Functions like append, reverse, map, filter that build
// new lists cannot be implemented without this feature.

// ===================================================================
// Stdlib.List.singleton - Create a single-element list
// ===================================================================

Stdlib.List.length<Int64>(Stdlib.List.singleton<Int64>(42)) = stdout="1\n"
match Stdlib.List.singleton<Int64>(5) with | [x] -> x | _ -> 0 = 5

// ===================================================================
// List spread syntax - [h, ...rest] in expressions
// ===================================================================

// Test basic spread syntax
let rest = [3, 4, 5] in Stdlib.List.length<Int64>([1, 2, ...rest]) = stdout="5\n"

// Test spread with empty list (need type annotation via function call)
Stdlib.List.length<Int64>([1, ...[]]) = stdout="1\n"

// Test spread with single element head
let tail = [2, 3] in match [1, ...tail] with | [a, b, c] -> a + b + c | _ -> 0 = 6

// ===================================================================
// Stdlib.List.push - Add element to front of list
// ===================================================================

match Stdlib.List.push<Int64>([2, 3], 1) with | [a, b, c] -> a | _ -> 0 = 1
Stdlib.List.length<Int64>(Stdlib.List.push<Int64>([1, 2], 0)) = stdout="3\n"

// ===================================================================
// Stdlib.List.append - Concatenate two lists
// ===================================================================

Stdlib.List.length<Int64>(Stdlib.List.append<Int64>([1, 2, 3], [4, 5, 6])) = stdout="6\n"
match Stdlib.List.append<Int64>([1, 2], [3, 4]) with | [a, b, c, d] -> a + b + c + d | _ -> 0 = 10

// ===================================================================
// Stdlib.List.pushBack - Add element to end of list
// ===================================================================

match Stdlib.List.pushBack<Int64>([1, 2], 3) with | [a, b, c] -> c | _ -> 0 = 3

// ===================================================================
// Stdlib.List.reverse - Reverse a list
// NOTE: Currently has a bug - returns unreversed list. Needs investigation.
// ===================================================================

// match Stdlib.List.reverse<Int64>([1, 2, 3]) with | [a, b, c] -> a | _ -> 0 = 3

// ===================================================================
// Stdlib.List.map - Apply a function to each element
// ===================================================================

match Stdlib.List.map<Int64, Int64>([1, 2, 3], (x: Int64) => x + 1) with | [a, b, c] -> a + b + c | _ -> 0 = 9
Stdlib.List.length<Int64>(Stdlib.List.map<Int64, Int64>([1, 2, 3, 4], (x: Int64) => x * 2)) = stdout="4\n"

// ===================================================================
// Stdlib.List.filter - Keep elements that match predicate
// ===================================================================

Stdlib.List.length<Int64>(Stdlib.List.filter<Int64>([1, 2, 3, 4, 5], (x: Int64) => x > 2)) = stdout="3\n"

// ===================================================================
// Stdlib.List.fold - Reduce list with accumulator
// ===================================================================

Stdlib.List.fold<Int64, Int64>([1, 2, 3, 4, 5], 0, (acc: Int64, x: Int64) => acc + x) = 15
Stdlib.List.fold<Int64, Int64>([1, 2, 3, 4], 1, (acc: Int64, x: Int64) => acc * x) = 24

// ===================================================================
// Stdlib.List.drop - Drop first n elements
// ===================================================================

Stdlib.List.length<Int64>(Stdlib.List.drop<Int64>([1, 2, 3, 4, 5], 2)) = stdout="3\n"
Stdlib.List.length<Int64>(Stdlib.List.drop<Int64>([1, 2, 3], 0)) = stdout="3\n"
Stdlib.List.length<Int64>(Stdlib.List.drop<Int64>([1, 2, 3], 10)) = stdout="0\n"

// ===================================================================
// Stdlib.List.take - Take first n elements
// ===================================================================

Stdlib.List.length<Int64>(Stdlib.List.take<Int64>([1, 2, 3, 4, 5], 3)) = stdout="3\n"
Stdlib.List.length<Int64>(Stdlib.List.take<Int64>([1, 2, 3], 0)) = stdout="0\n"
Stdlib.List.length<Int64>(Stdlib.List.take<Int64>([1, 2], 10)) = stdout="2\n"

// ===================================================================
// Stdlib.List.head - Get first element or None
// ===================================================================

Stdlib.Option.withDefault<Int64>(Stdlib.List.head<Int64>([1, 2, 3]), 0) = 1
Stdlib.Option.isNone<Int64>(Stdlib.List.head<Int64>([])) = stdout="true\n"

// ===================================================================
// Stdlib.List.getAt - Get element at index
// ===================================================================

Stdlib.Option.withDefault<Int64>(Stdlib.List.getAt<Int64>([10, 20, 30], 0), 0) = 10
Stdlib.Option.withDefault<Int64>(Stdlib.List.getAt<Int64>([10, 20, 30], 2), 0) = 30
Stdlib.Option.isNone<Int64>(Stdlib.List.getAt<Int64>([1, 2, 3], 10)) = stdout="true\n"

// ===================================================================
// Stdlib.List.findFirst - Find first element matching predicate
// ===================================================================

Stdlib.Option.withDefault<Int64>(Stdlib.List.findFirst<Int64>([1, 2, 3, 4], (x: Int64) => x > 2), 0) = 3
Stdlib.Option.isNone<Int64>(Stdlib.List.findFirst<Int64>([1, 2, 3], (x: Int64) => x > 10)) = stdout="true\n"

// ===================================================================
// NOTE: Functions not yet implemented
// ===================================================================

// Stdlib.List.tail - blocked by parser (can't parse Option<List<a>>)
// Stdlib.List.last - not yet implemented
// Stdlib.List.range - not yet implemented
// Stdlib.List.all/any - not yet implemented
