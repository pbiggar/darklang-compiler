// Stdlib.Result Tests
// Ported from https://github.com/darklang/dark/tree/main/backend/testfiles/execution/stdlib
//
// Tests for Result module functions
// NOTE: Result<T, E> has two type parameters. When using Ok, E is unconstrained.
//       When using Error, T is unconstrained. Type params needed for these cases.

// ===================================================================
// Result.isOk - Returns true if the result is Ok
// ===================================================================

// NOTE: Needs type params because Error type is unconstrained
Result.isOk<Int64, Int64>(Result.Ok(5)) = stdout="true\n"
Result.isOk<Int64, Int64>(Result.Error(99)) = stdout="false\n"

// ===================================================================
// Result.isError - Returns true if the result is Error
// ===================================================================

// NOTE: Needs type params because one type is always unconstrained
Result.isError<Int64, Int64>(Result.Ok(5)) = stdout="false\n"
Result.isError<Int64, Int64>(Result.Error(99)) = stdout="true\n"

// ===================================================================
// Result.withDefault - Returns the value or a default
// ===================================================================

// NOTE: Needs type params - Error type unconstrained
Result.withDefault<Int64, Int64>(Result.Ok(5), 0) = 5
Result.withDefault<Int64, Int64>(Result.Error(99), 42) = 42

// ===================================================================
// Result.map - Apply a function to the Ok value
// ===================================================================

// NOTE: Needs type params - Error type unconstrained from Ok constructor
Result.withDefault<Int64, Int64>(Result.map<Int64, Int64, Int64>(Result.Ok(5), (x: Int64) => x + 1), 0) = 6
Result.isError(Result.map(Result.Error(99), (x: Int64) => x + 1)) = stdout="true\n"

// ===================================================================
// Result.mapError - Apply a function to the Error value
// NOTE: Blocked by type checker - constructor doesn't pick up return type annotation
// When changing error type from e to f, the Error constructor gets the wrong type
// ===================================================================

// Result.mapError(Result.Error(99), (e: Int64) => e + 1)

// ===================================================================
// Result.andThen - Chain Result computations
// ===================================================================

// NOTE: Needs type params - Error type unconstrained
Result.withDefault<Int64, Int64>(Result.andThen<Int64, Int64, Int64>(Result.Ok(5), (x: Int64) => Result.Ok(x * 2)), 0) = 10
Result.isError(Result.andThen(Result.Error(99), (x: Int64) => Result.Ok(x * 2))) = stdout="true\n"
// NOTE: Needs type params because lambda returns Error which doesn't constrain the ok type
Result.isError(Result.andThen<Int64, Int64, Int64>(Result.Ok(5), (x: Int64) => Result.Error(99))) = stdout="true\n"

// ===================================================================
// Pipe operator with Result functions
// ===================================================================

// NOTE: All need type params because Result has two type parameters
Result.Ok(42) |> Result.isOk<Int64, Int64>() = stdout="true\n"
Result.Error(99) |> Result.isError<Int64, Int64>() = stdout="true\n"
Result.Ok(10) |> Result.map<Int64, Int64, Int64>((x: Int64) => x * 2) |> Result.withDefault<Int64, Int64>(0) = 20

