// Stdlib.Result Tests
// Ported from https://github.com/darklang/dark/tree/main/backend/testfiles/execution/stdlib
//
// Tests for Result module functions
// NOTE: Result<T, E> has two type parameters. Unresolved type variables are
//       defaulted to Int64 during monomorphization, so explicit type params
//       are not always needed.

// ===================================================================
// Result.isOk - Returns true if the result is Ok
// ===================================================================

// Unresolved type variables are defaulted to Int64 during monomorphization
Result.isOk(Result.Ok(5)) = stdout="true\n"
Result.isOk(Result.Error(99)) = stdout="false\n"

// ===================================================================
// Result.isError - Returns true if the result is Error
// ===================================================================

// Unresolved type variables are defaulted to Int64 during monomorphization
Result.isError(Result.Ok(5)) = stdout="false\n"
Result.isError(Result.Error(99)) = stdout="true\n"

// ===================================================================
// Result.withDefault - Returns the value or a default
// ===================================================================

// Type inference from default value and constructor works
Result.withDefault(Result.Ok(5), 0) = 5
Result.withDefault(Result.Error(99), 42) = 42

// ===================================================================
// Result.map - Apply a function to the Ok value
// ===================================================================

// Unresolved type variables are defaulted to Int64 during monomorphization
Result.withDefault(Result.map(Result.Ok(5), (x: Int64) => x + 1), 0) = 6
Result.isError(Result.map(Result.Error(99), (x: Int64) => x + 1)) = stdout="true\n"

// ===================================================================
// Result.mapError - Apply a function to the Error value
// NOTE: Blocked by type checker - constructor doesn't pick up return type annotation
// When changing error type from e to f, the Error constructor gets the wrong type
// ===================================================================

// Result.mapError(Result.Error(99), (e: Int64) => e + 1)

// ===================================================================
// Result.andThen - Chain Result computations
// ===================================================================

// Unresolved type variables are defaulted to Int64 during monomorphization
Result.withDefault(Result.andThen(Result.Ok(5), (x: Int64) => Result.Ok(x * 2)), 0) = 10
Result.isError(Result.andThen(Result.Error(99), (x: Int64) => Result.Ok(x * 2))) = stdout="true\n"
// When lambda returns Error, unresolved ok type is defaulted to Int64
Result.isError(Result.andThen(Result.Ok(5), (x: Int64) => Result.Error(99))) = stdout="true\n"

// ===================================================================
// Pipe operator with Result functions
// ===================================================================

// Unresolved type variables are defaulted to Int64 during monomorphization
Result.Ok(42) |> Result.isOk() = stdout="true\n"
Result.Error(99) |> Result.isError() = stdout="true\n"
Result.Ok(10) |> Result.map((x: Int64) => x * 2) |> Result.withDefault(0) = 20

// ===================================================================
// Unresolved type variable resolved later by context
// ===================================================================

// Type is inferred from withDefault's second argument
let x = Result.Error(99) in Result.withDefault(x, 42) = 42

