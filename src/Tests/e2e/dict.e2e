// Tests for Dict (HAMT) implementation

// Empty dict
Stdlib.Dict.empty() = 0

// Get from empty dict returns -1 (not found)
Stdlib.Dict.get(Stdlib.Dict.empty(), 42) = -1

// Set and get single value
Stdlib.Dict.get(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100), 1) = 100

// Get non-existent key from non-empty dict
Stdlib.Dict.get(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100), 2) = -1

// Set multiple values
let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100) in let d2 = Stdlib.Dict.set(d1, 2, 200) in Stdlib.Dict.get(d2, 1) = 100

let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100) in let d2 = Stdlib.Dict.set(d1, 2, 200) in Stdlib.Dict.get(d2, 2) = 200

// Update existing key
let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100) in let d2 = Stdlib.Dict.set(d1, 1, 999) in Stdlib.Dict.get(d2, 1) = 999

// Three values
let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 10) in let d2 = Stdlib.Dict.set(d1, 2, 20) in let d3 = Stdlib.Dict.set(d2, 3, 30) in Stdlib.Dict.get(d3, 1) = 10

let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 10) in let d2 = Stdlib.Dict.set(d1, 2, 20) in let d3 = Stdlib.Dict.set(d2, 3, 30) in Stdlib.Dict.get(d3, 2) = 20

let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 10) in let d2 = Stdlib.Dict.set(d1, 2, 20) in let d3 = Stdlib.Dict.set(d2, 3, 30) in Stdlib.Dict.get(d3, 3) = 30

// Keys with same hash chunk at level 0 (testing internal node expansion)
// Keys 0 and 64 have the same 6-bit chunk at level 0 (both are 0 & 63 = 0)
let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 0, 1000) in let d2 = Stdlib.Dict.set(d1, 64, 2000) in Stdlib.Dict.get(d2, 0) = 1000

let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 0, 1000) in let d2 = Stdlib.Dict.set(d1, 64, 2000) in Stdlib.Dict.get(d2, 64) = 2000

// ========== Dict.remove tests ==========

// Remove from single-entry dict
let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100) in let d2 = Stdlib.Dict.remove(d1, 1) in Stdlib.Dict.get(d2, 1) = -1

// Remove non-existent key (dict unchanged)
let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100) in let d2 = Stdlib.Dict.remove(d1, 999) in Stdlib.Dict.get(d2, 1) = 100

// Remove one key, other keys remain
let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100) in let d2 = Stdlib.Dict.set(d1, 2, 200) in let d3 = Stdlib.Dict.set(d2, 3, 300) in let d4 = Stdlib.Dict.remove(d3, 2) in Stdlib.Dict.get(d4, 1) = 100

let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100) in let d2 = Stdlib.Dict.set(d1, 2, 200) in let d3 = Stdlib.Dict.set(d2, 3, 300) in let d4 = Stdlib.Dict.remove(d3, 2) in Stdlib.Dict.get(d4, 2) = -1

let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100) in let d2 = Stdlib.Dict.set(d1, 2, 200) in let d3 = Stdlib.Dict.set(d2, 3, 300) in let d4 = Stdlib.Dict.remove(d3, 2) in Stdlib.Dict.get(d4, 3) = 300

// Immutability: original dict unchanged after remove
let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100) in let d2 = Stdlib.Dict.remove(d1, 1) in Stdlib.Dict.get(d1, 1) = 100

// Remove all keys one by one
let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 10) in let d2 = Stdlib.Dict.set(d1, 2, 20) in let d3 = Stdlib.Dict.remove(d2, 1) in let d4 = Stdlib.Dict.remove(d3, 2) in Stdlib.Dict.get(d4, 1) = -1

let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 10) in let d2 = Stdlib.Dict.set(d1, 2, 20) in let d3 = Stdlib.Dict.remove(d2, 1) in let d4 = Stdlib.Dict.remove(d3, 2) in Stdlib.Dict.get(d4, 2) = -1

// Remove from empty dict (no-op)
Stdlib.Dict.get(Stdlib.Dict.remove(Stdlib.Dict.empty(), 1), 1) = -1

// ========== String-keyed Dict tests ==========

// Get from empty dict with string key
Stdlib.Dict.get_str(Stdlib.Dict.empty(), "hello") = -1

// Set and get single string key
Stdlib.Dict.get_str(Stdlib.Dict.set_str(Stdlib.Dict.empty(), "hello", 100), "hello") = 100

// Get non-existent string key from non-empty dict
Stdlib.Dict.get_str(Stdlib.Dict.set_str(Stdlib.Dict.empty(), "hello", 100), "world") = -1

// Set multiple string keys
let d1 = Stdlib.Dict.set_str(Stdlib.Dict.empty(), "one", 1) in let d2 = Stdlib.Dict.set_str(d1, "two", 2) in Stdlib.Dict.get_str(d2, "one") = 1

let d1 = Stdlib.Dict.set_str(Stdlib.Dict.empty(), "one", 1) in let d2 = Stdlib.Dict.set_str(d1, "two", 2) in Stdlib.Dict.get_str(d2, "two") = 2

// Update existing string key
let d1 = Stdlib.Dict.set_str(Stdlib.Dict.empty(), "key", 100) in let d2 = Stdlib.Dict.set_str(d1, "key", 999) in Stdlib.Dict.get_str(d2, "key") = 999

// Three string keys
let d1 = Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 10) in let d2 = Stdlib.Dict.set_str(d1, "b", 20) in let d3 = Stdlib.Dict.set_str(d2, "c", 30) in Stdlib.Dict.get_str(d3, "a") = 10

let d1 = Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 10) in let d2 = Stdlib.Dict.set_str(d1, "b", 20) in let d3 = Stdlib.Dict.set_str(d2, "c", 30) in Stdlib.Dict.get_str(d3, "b") = 20

let d1 = Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 10) in let d2 = Stdlib.Dict.set_str(d1, "b", 20) in let d3 = Stdlib.Dict.set_str(d2, "c", 30) in Stdlib.Dict.get_str(d3, "c") = 30

// ========== String Dict remove tests ==========

// Remove from single-entry dict
let d1 = Stdlib.Dict.set_str(Stdlib.Dict.empty(), "key", 100) in let d2 = Stdlib.Dict.remove_str(d1, "key") in Stdlib.Dict.get_str(d2, "key") = -1

// Remove non-existent key (dict unchanged)
let d1 = Stdlib.Dict.set_str(Stdlib.Dict.empty(), "key", 100) in let d2 = Stdlib.Dict.remove_str(d1, "other") in Stdlib.Dict.get_str(d2, "key") = 100

// Remove one key, other keys remain
let d1 = Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 100) in let d2 = Stdlib.Dict.set_str(d1, "b", 200) in let d3 = Stdlib.Dict.set_str(d2, "c", 300) in let d4 = Stdlib.Dict.remove_str(d3, "b") in Stdlib.Dict.get_str(d4, "a") = 100

let d1 = Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 100) in let d2 = Stdlib.Dict.set_str(d1, "b", 200) in let d3 = Stdlib.Dict.set_str(d2, "c", 300) in let d4 = Stdlib.Dict.remove_str(d3, "b") in Stdlib.Dict.get_str(d4, "b") = -1

let d1 = Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 100) in let d2 = Stdlib.Dict.set_str(d1, "b", 200) in let d3 = Stdlib.Dict.set_str(d2, "c", 300) in let d4 = Stdlib.Dict.remove_str(d3, "b") in Stdlib.Dict.get_str(d4, "c") = 300

// Immutability: original dict unchanged after remove
let d1 = Stdlib.Dict.set_str(Stdlib.Dict.empty(), "key", 100) in let d2 = Stdlib.Dict.remove_str(d1, "key") in Stdlib.Dict.get_str(d1, "key") = 100

// Empty string as key
Stdlib.Dict.get_str(Stdlib.Dict.set_str(Stdlib.Dict.empty(), "", 42), "") = 42

// Edge case: keys that differ only in length
let d1 = Stdlib.Dict.set_str(Stdlib.Dict.empty(), "ab", 1) in let d2 = Stdlib.Dict.set_str(d1, "abc", 2) in Stdlib.Dict.get_str(d2, "ab") = 1

let d1 = Stdlib.Dict.set_str(Stdlib.Dict.empty(), "ab", 1) in let d2 = Stdlib.Dict.set_str(d1, "abc", 2) in Stdlib.Dict.get_str(d2, "abc") = 2

// ========== Dict utility functions ==========

// isEmpty tests
Stdlib.Dict.isEmpty(Stdlib.Dict.empty()) = stdout="true\n"
Stdlib.Dict.isEmpty(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100)) = stdout="false\n"

// contains tests (int-keyed)
Stdlib.Dict.contains(Stdlib.Dict.empty(), 1) = stdout="false\n"
Stdlib.Dict.contains(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100), 1) = stdout="true\n"
Stdlib.Dict.contains(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100), 2) = stdout="false\n"

// contains_str tests (string-keyed)
Stdlib.Dict.contains_str(Stdlib.Dict.empty(), "hello") = stdout="false\n"
Stdlib.Dict.contains_str(Stdlib.Dict.set_str(Stdlib.Dict.empty(), "hello", 100), "hello") = stdout="true\n"
Stdlib.Dict.contains_str(Stdlib.Dict.set_str(Stdlib.Dict.empty(), "hello", 100), "world") = stdout="false\n"

// size tests
Stdlib.Dict.size(Stdlib.Dict.empty()) = 0
Stdlib.Dict.size(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100)) = 1
let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 10) in let d2 = Stdlib.Dict.set(d1, 2, 20) in Stdlib.Dict.size(d2) = 2
let d1 = Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 10) in let d2 = Stdlib.Dict.set(d1, 2, 20) in let d3 = Stdlib.Dict.set(d2, 3, 30) in Stdlib.Dict.size(d3) = 3

// size with string keys (same underlying structure)
Stdlib.Dict.size(Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 1)) = 1
let d1 = Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 1) in let d2 = Stdlib.Dict.set_str(d1, "b", 2) in Stdlib.Dict.size(d2) = 2

// ========== Dict enumeration (Int64-keyed) ==========

// keys tests
Stdlib.List.length<Int64>(Stdlib.Dict.keys(Stdlib.Dict.empty())) = 0
Stdlib.List.length<Int64>(Stdlib.Dict.keys(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100))) = 1
let d = Stdlib.Dict.set(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 10), 2, 20) in Stdlib.List.length<Int64>(Stdlib.Dict.keys(d)) = 2

// values tests
Stdlib.List.length<Int64>(Stdlib.Dict.values(Stdlib.Dict.empty())) = 0
Stdlib.List.length<Int64>(Stdlib.Dict.values(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100))) = 1
let d = Stdlib.Dict.set(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 10), 2, 20) in Stdlib.List.length<Int64>(Stdlib.Dict.values(d)) = 2

// entries tests - test via isEmpty on the resulting list
Stdlib.Dict.entries(Stdlib.Dict.empty()) == [] = stdout="true\n"
Stdlib.Dict.entries(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100)) == [] = stdout="false\n"

// ========== Dict enumeration (String-keyed) ==========

// keys_str tests
Stdlib.List.length<String>(Stdlib.Dict.keys_str(Stdlib.Dict.empty())) = 0
Stdlib.List.length<String>(Stdlib.Dict.keys_str(Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 100))) = 1
let d = Stdlib.Dict.set_str(Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 10), "b", 20) in Stdlib.List.length<String>(Stdlib.Dict.keys_str(d)) = 2

// values_str tests (same as values since values are Int64)
Stdlib.List.length<Int64>(Stdlib.Dict.values_str(Stdlib.Dict.empty())) = 0
Stdlib.List.length<Int64>(Stdlib.Dict.values_str(Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 100))) = 1

// entries_str tests
Stdlib.Dict.entries_str(Stdlib.Dict.empty()) == [] = stdout="true\n"
Stdlib.Dict.entries_str(Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 100)) == [] = stdout="false\n"

// ========== Dict functional operations (Int64-keyed) ==========

// fold tests - sum all values
Stdlib.Dict.fold(Stdlib.Dict.empty(), 0, (acc: Int64, k: Int64, v: Int64) => acc + v) = 0
Stdlib.Dict.fold(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 100), 0, (acc: Int64, k: Int64, v: Int64) => acc + v) = 100
let d = Stdlib.Dict.set(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 10), 2, 20) in Stdlib.Dict.fold(d, 0, (acc: Int64, k: Int64, v: Int64) => acc + v) = 30

// fold tests - sum all keys
let d = Stdlib.Dict.set(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 10), 2, 20) in Stdlib.Dict.fold(d, 0, (acc: Int64, k: Int64, v: Int64) => acc + k) = 3

// map tests - double all values
let d = Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 10) in let d2 = Stdlib.Dict.map(d, (v: Int64) => v * 2) in Stdlib.Dict.get(d2, 1) = 20
let d = Stdlib.Dict.set(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 10), 2, 20) in let d2 = Stdlib.Dict.map(d, (v: Int64) => v * 2) in Stdlib.Dict.get(d2, 2) = 40

// filter tests - keep values > 15
let d = Stdlib.Dict.set(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 10), 2, 20) in let d2 = Stdlib.Dict.filter(d, (k: Int64, v: Int64) => v > 15) in Stdlib.Dict.contains(d2, 1) = stdout="false\n"
let d = Stdlib.Dict.set(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 10), 2, 20) in let d2 = Stdlib.Dict.filter(d, (k: Int64, v: Int64) => v > 15) in Stdlib.Dict.contains(d2, 2) = stdout="true\n"

// filter tests - keep keys > 1
let d = Stdlib.Dict.set(Stdlib.Dict.set(Stdlib.Dict.empty(), 1, 10), 2, 20) in let d2 = Stdlib.Dict.filter(d, (k: Int64, v: Int64) => k > 1) in Stdlib.Dict.size(d2) = 1

// ========== Dict functional operations (String-keyed) ==========

// fold_str tests - sum all values
Stdlib.Dict.fold_str(Stdlib.Dict.empty(), 0, (acc: Int64, k: String, v: Int64) => acc + v) = 0
Stdlib.Dict.fold_str(Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 100), 0, (acc: Int64, k: String, v: Int64) => acc + v) = 100
let d = Stdlib.Dict.set_str(Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 10), "b", 20) in Stdlib.Dict.fold_str(d, 0, (acc: Int64, k: String, v: Int64) => acc + v) = 30

// map_str tests - double all values
let d = Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 10) in let d2 = Stdlib.Dict.map_str(d, (v: Int64) => v * 2) in Stdlib.Dict.get_str(d2, "a") = 20
let d = Stdlib.Dict.set_str(Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 10), "b", 20) in let d2 = Stdlib.Dict.map_str(d, (v: Int64) => v * 2) in Stdlib.Dict.get_str(d2, "b") = 40

// filter_str tests - keep values > 15
let d = Stdlib.Dict.set_str(Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 10), "b", 20) in let d2 = Stdlib.Dict.filter_str(d, (k: String, v: Int64) => v > 15) in Stdlib.Dict.contains_str(d2, "a") = stdout="false\n"
let d = Stdlib.Dict.set_str(Stdlib.Dict.set_str(Stdlib.Dict.empty(), "a", 10), "b", 20) in let d2 = Stdlib.Dict.filter_str(d, (k: String, v: Int64) => v > 15) in Stdlib.Dict.contains_str(d2, "b") = stdout="true\n"
