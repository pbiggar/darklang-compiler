// Tests for Dict (HAMT) implementation

// Empty dict is 0 (null pointer)
Stdlib.Dict.empty<Int64, Int64>() = 0

// Get from empty dict returns None
Stdlib.Option.isNone<Int64>(Stdlib.Dict.get<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 42)) = stdout="true\n"

// Set and get single value
Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<Int64, Int64>(Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 100), 1), -1) = 100

// Get non-existent key from non-empty dict returns None
Stdlib.Option.isNone<Int64>(Stdlib.Dict.get<Int64, Int64>(Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 100), 2)) = stdout="true\n"

// Set multiple values
let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 100) in let d2 = Stdlib.Dict.set<Int64, Int64>(d1, 2, 200) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<Int64, Int64>(d2, 1), -1) = 100

let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 100) in let d2 = Stdlib.Dict.set<Int64, Int64>(d1, 2, 200) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<Int64, Int64>(d2, 2), -1) = 200

// Update existing key
let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 100) in let d2 = Stdlib.Dict.set<Int64, Int64>(d1, 1, 999) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<Int64, Int64>(d2, 1), -1) = 999

// Three values
let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 10) in let d2 = Stdlib.Dict.set<Int64, Int64>(d1, 2, 20) in let d3 = Stdlib.Dict.set<Int64, Int64>(d2, 3, 30) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<Int64, Int64>(d3, 1), -1) = 10

let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 10) in let d2 = Stdlib.Dict.set<Int64, Int64>(d1, 2, 20) in let d3 = Stdlib.Dict.set<Int64, Int64>(d2, 3, 30) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<Int64, Int64>(d3, 2), -1) = 20

let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 10) in let d2 = Stdlib.Dict.set<Int64, Int64>(d1, 2, 20) in let d3 = Stdlib.Dict.set<Int64, Int64>(d2, 3, 30) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<Int64, Int64>(d3, 3), -1) = 30

// Keys with same hash chunk at level 0 (testing internal node expansion)
// Keys 0 and 64 have the same 6-bit chunk at level 0 (both are 0 & 63 = 0)
let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 0, 1000) in let d2 = Stdlib.Dict.set<Int64, Int64>(d1, 64, 2000) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<Int64, Int64>(d2, 0), -1) = 1000

let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 0, 1000) in let d2 = Stdlib.Dict.set<Int64, Int64>(d1, 64, 2000) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<Int64, Int64>(d2, 64), -1) = 2000

// ========== Dict.remove tests ==========

// Remove from single-entry dict
let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 100) in let d2 = Stdlib.Dict.remove<Int64, Int64>(d1, 1) in Stdlib.Option.isNone<Int64>(Stdlib.Dict.get<Int64, Int64>(d2, 1)) = stdout="true\n"

// Remove non-existent key (dict unchanged)
let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 100) in let d2 = Stdlib.Dict.remove<Int64, Int64>(d1, 999) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<Int64, Int64>(d2, 1), -1) = 100

// Remove one key, other keys remain
let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 100) in let d2 = Stdlib.Dict.set<Int64, Int64>(d1, 2, 200) in let d3 = Stdlib.Dict.set<Int64, Int64>(d2, 3, 300) in let d4 = Stdlib.Dict.remove<Int64, Int64>(d3, 2) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<Int64, Int64>(d4, 1), -1) = 100

let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 100) in let d2 = Stdlib.Dict.set<Int64, Int64>(d1, 2, 200) in let d3 = Stdlib.Dict.set<Int64, Int64>(d2, 3, 300) in let d4 = Stdlib.Dict.remove<Int64, Int64>(d3, 2) in Stdlib.Option.isNone<Int64>(Stdlib.Dict.get<Int64, Int64>(d4, 2)) = stdout="true\n"

let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 100) in let d2 = Stdlib.Dict.set<Int64, Int64>(d1, 2, 200) in let d3 = Stdlib.Dict.set<Int64, Int64>(d2, 3, 300) in let d4 = Stdlib.Dict.remove<Int64, Int64>(d3, 2) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<Int64, Int64>(d4, 3), -1) = 300

// Immutability: original dict unchanged after remove
let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 100) in let d2 = Stdlib.Dict.remove<Int64, Int64>(d1, 1) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<Int64, Int64>(d1, 1), -1) = 100

// Remove all keys one by one
let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 10) in let d2 = Stdlib.Dict.set<Int64, Int64>(d1, 2, 20) in let d3 = Stdlib.Dict.remove<Int64, Int64>(d2, 1) in let d4 = Stdlib.Dict.remove<Int64, Int64>(d3, 2) in Stdlib.Option.isNone<Int64>(Stdlib.Dict.get<Int64, Int64>(d4, 1)) = stdout="true\n"

let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 10) in let d2 = Stdlib.Dict.set<Int64, Int64>(d1, 2, 20) in let d3 = Stdlib.Dict.remove<Int64, Int64>(d2, 1) in let d4 = Stdlib.Dict.remove<Int64, Int64>(d3, 2) in Stdlib.Option.isNone<Int64>(Stdlib.Dict.get<Int64, Int64>(d4, 2)) = stdout="true\n"

// Remove from empty dict (no-op)
Stdlib.Option.isNone<Int64>(Stdlib.Dict.get<Int64, Int64>(Stdlib.Dict.remove<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1), 1)) = stdout="true\n"

// ========== String-keyed Dict tests ==========

// Get from empty dict with string key
Stdlib.Option.isNone<Int64>(Stdlib.Dict.get<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "hello")) = stdout="true\n"

// Set and get single string key
Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<String, Int64>(Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "hello", 100), "hello"), -1) = 100

// Get non-existent string key from non-empty dict
Stdlib.Option.isNone<Int64>(Stdlib.Dict.get<String, Int64>(Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "hello", 100), "world")) = stdout="true\n"

// Set multiple string keys
let d1 = Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "one", 1) in let d2 = Stdlib.Dict.set<String, Int64>(d1, "two", 2) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<String, Int64>(d2, "one"), -1) = 1

let d1 = Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "one", 1) in let d2 = Stdlib.Dict.set<String, Int64>(d1, "two", 2) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<String, Int64>(d2, "two"), -1) = 2

// Update existing string key
let d1 = Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "key", 100) in let d2 = Stdlib.Dict.set<String, Int64>(d1, "key", 999) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<String, Int64>(d2, "key"), -1) = 999

// Three string keys
let d1 = Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "a", 10) in let d2 = Stdlib.Dict.set<String, Int64>(d1, "b", 20) in let d3 = Stdlib.Dict.set<String, Int64>(d2, "c", 30) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<String, Int64>(d3, "a"), -1) = 10

let d1 = Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "a", 10) in let d2 = Stdlib.Dict.set<String, Int64>(d1, "b", 20) in let d3 = Stdlib.Dict.set<String, Int64>(d2, "c", 30) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<String, Int64>(d3, "b"), -1) = 20

let d1 = Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "a", 10) in let d2 = Stdlib.Dict.set<String, Int64>(d1, "b", 20) in let d3 = Stdlib.Dict.set<String, Int64>(d2, "c", 30) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<String, Int64>(d3, "c"), -1) = 30

// ========== String Dict remove tests ==========

// Remove from single-entry dict
let d1 = Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "key", 100) in let d2 = Stdlib.Dict.remove<String, Int64>(d1, "key") in Stdlib.Option.isNone<Int64>(Stdlib.Dict.get<String, Int64>(d2, "key")) = stdout="true\n"

// Remove non-existent key (dict unchanged)
let d1 = Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "key", 100) in let d2 = Stdlib.Dict.remove<String, Int64>(d1, "other") in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<String, Int64>(d2, "key"), -1) = 100

// Remove one key, other keys remain
let d1 = Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "a", 100) in let d2 = Stdlib.Dict.set<String, Int64>(d1, "b", 200) in let d3 = Stdlib.Dict.set<String, Int64>(d2, "c", 300) in let d4 = Stdlib.Dict.remove<String, Int64>(d3, "b") in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<String, Int64>(d4, "a"), -1) = 100

let d1 = Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "a", 100) in let d2 = Stdlib.Dict.set<String, Int64>(d1, "b", 200) in let d3 = Stdlib.Dict.set<String, Int64>(d2, "c", 300) in let d4 = Stdlib.Dict.remove<String, Int64>(d3, "b") in Stdlib.Option.isNone<Int64>(Stdlib.Dict.get<String, Int64>(d4, "b")) = stdout="true\n"

let d1 = Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "a", 100) in let d2 = Stdlib.Dict.set<String, Int64>(d1, "b", 200) in let d3 = Stdlib.Dict.set<String, Int64>(d2, "c", 300) in let d4 = Stdlib.Dict.remove<String, Int64>(d3, "b") in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<String, Int64>(d4, "c"), -1) = 300

// Immutability: original dict unchanged after remove
let d1 = Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "key", 100) in let d2 = Stdlib.Dict.remove<String, Int64>(d1, "key") in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<String, Int64>(d1, "key"), -1) = 100

// Empty string as key
Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<String, Int64>(Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "", 42), ""), -1) = 42

// Edge case: keys that differ only in length
let d1 = Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "ab", 1) in let d2 = Stdlib.Dict.set<String, Int64>(d1, "abc", 2) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<String, Int64>(d2, "ab"), -1) = 1

let d1 = Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "ab", 1) in let d2 = Stdlib.Dict.set<String, Int64>(d1, "abc", 2) in Stdlib.Option.withDefault<Int64>(Stdlib.Dict.get<String, Int64>(d2, "abc"), -1) = 2

// ========== Dict utility functions ==========

// isEmpty tests
Stdlib.Dict.isEmpty<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>()) = stdout="true\n"
Stdlib.Dict.isEmpty<Int64, Int64>(Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 100)) = stdout="false\n"

// contains tests (int-keyed)
Stdlib.Dict.contains<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1) = stdout="false\n"
Stdlib.Dict.contains<Int64, Int64>(Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 100), 1) = stdout="true\n"
Stdlib.Dict.contains<Int64, Int64>(Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 100), 2) = stdout="false\n"

// contains tests (string-keyed)
Stdlib.Dict.contains<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "hello") = stdout="false\n"
Stdlib.Dict.contains<String, Int64>(Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "hello", 100), "hello") = stdout="true\n"
Stdlib.Dict.contains<String, Int64>(Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "hello", 100), "world") = stdout="false\n"

// size tests
Stdlib.Dict.size<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>()) = 0
Stdlib.Dict.size<Int64, Int64>(Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 100)) = 1
let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 10) in let d2 = Stdlib.Dict.set<Int64, Int64>(d1, 2, 20) in Stdlib.Dict.size<Int64, Int64>(d2) = 2
let d1 = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 10) in let d2 = Stdlib.Dict.set<Int64, Int64>(d1, 2, 20) in let d3 = Stdlib.Dict.set<Int64, Int64>(d2, 3, 30) in Stdlib.Dict.size<Int64, Int64>(d3) = 3

// size with string keys
Stdlib.Dict.size<String, Int64>(Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "a", 1)) = 1
let d1 = Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "a", 1) in let d2 = Stdlib.Dict.set<String, Int64>(d1, "b", 2) in Stdlib.Dict.size<String, Int64>(d2) = 2

// ========== Dict enumeration (Int64-keyed) ==========

// keys tests
Stdlib.List.length<Int64>(Stdlib.Dict.keys<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>())) = 0
Stdlib.List.length<Int64>(Stdlib.Dict.keys<Int64, Int64>(Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 100))) = 1
let d = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 10), 2, 20) in Stdlib.List.length<Int64>(Stdlib.Dict.keys<Int64, Int64>(d)) = 2

// values tests
Stdlib.List.length<Int64>(Stdlib.Dict.values<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>())) = 0
Stdlib.List.length<Int64>(Stdlib.Dict.values<Int64, Int64>(Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 100))) = 1
let d = Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.set<Int64, Int64>(Stdlib.Dict.empty<Int64, Int64>(), 1, 10), 2, 20) in Stdlib.List.length<Int64>(Stdlib.Dict.values<Int64, Int64>(d)) = 2

// ========== Dict enumeration (String-keyed) ==========

// keys tests
Stdlib.List.length<String>(Stdlib.Dict.keys<String, Int64>(Stdlib.Dict.empty<String, Int64>())) = 0
Stdlib.List.length<String>(Stdlib.Dict.keys<String, Int64>(Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "a", 100))) = 1
let d = Stdlib.Dict.set<String, Int64>(Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "a", 10), "b", 20) in Stdlib.List.length<String>(Stdlib.Dict.keys<String, Int64>(d)) = 2

// values tests
Stdlib.List.length<Int64>(Stdlib.Dict.values<String, Int64>(Stdlib.Dict.empty<String, Int64>())) = 0
Stdlib.List.length<Int64>(Stdlib.Dict.values<String, Int64>(Stdlib.Dict.set<String, Int64>(Stdlib.Dict.empty<String, Int64>(), "a", 100))) = 1

// TODO: entries, fold, map, filter tests require parser support for:
// - Tuple types in generics: List<(k, v)>
// - Multi-arg function types: (a, k, v) -> a
// These will be added once the parser is extended.
