// Reference Counting Tests
//
// Tests for reference counting behavior with memory reuse via free list.
//
// Implementation status:
// - RefCountDec is inserted at END of scope (before Return)
// - Free list logic is fully implemented
// - Memory is reclaimed and reused when ref count hits 0
// - Borrowed values (TupleGet, aliases) don't get their own Dec

// ===================================================================
// Basic tuple creation and use - should work correctly
// ===================================================================

// Simple tuple
let t = (1, 2) in t.0 + t.1 = stdout="3\n"

// Tuple destructuring
let (a, b) = (10, 20) in a + b = stdout="30\n"

// Multiple tuples
let t1 = (1, 2) in let t2 = (3, 4) in t1.0 + t2.1 = stdout="5\n"

// ===================================================================
// Tests for correct RefCountDec placement
// Dec should happen at END of scope, not start
// ===================================================================

// Tuple used then destructured - Dec happens after use
let t = (1, 2) in let (a, b) = t in a + b = stdout="3\n"

// Tuple aliased - alias is borrowed, original gets Dec
let outer = (1, 2) in let inner = outer in inner.0 + inner.1 = stdout="3\n"

// ===================================================================
// Memory reuse tests - free list reclaims and reuses memory
// ===================================================================

// Allocate two tuples of same size - second reuses freed memory
let t1 = (1, 2) in let _ = t1.0 in let t2 = (3, 4) in t2.0 + t2.1 = stdout="7\n"

// Allocate many tuples - tests free list under pressure
let a = (1, 1) in let b = (2, 2) in let c = (3, 3) in let d = (4, 4) in a.0 + b.0 + c.0 + d.0 = stdout="10\n"

// ===================================================================
// Function calls with heap values
// ===================================================================

// Tuple passed to function and returned - ownership transfer
def identity(t: int) : int = t def main() : int = identity(42) = 42

// Tuple created in function and returned
def make_value() : int = 42 def main() : int = make_value() = 42

// Multiple function calls
def add1(x: int) : int = x + 1 def main() : int = let a = add1(1) in let b = add1(10) in a + b = 13

// ===================================================================
// Records (also heap-allocated)
// ===================================================================

// Basic record
type Point = { x: int, y: int } let p = Point { x = 10, y = 20 } in p.x + p.y = stdout="30\n"

// Record with aliasing
type Point = { x: int, y: int } let p = Point { x = 5, y = 7 } in let q = p in q.x + q.y = stdout="12\n"

// ===================================================================
// Nested heap values
// ===================================================================

// Tuple containing tuples - outer tuple owns nested refs
let outer = ((1, 2), (3, 4)) in let (a, b) = outer in a.0 + b.1 = stdout="5\n"

// Deeply nested tuple access (must use intermediate let bindings)
let t = ((10, 20), (30, 40)) in let a = t.0 in let b = t.1 in a.0 + b.1 = stdout="50\n"

// ===================================================================
// Lists (also heap-allocated)
// ===================================================================

// Simple list operations
match [1, 2, 3] with | [x, _, _] -> x | _ -> 0 = stdout="1\n"

// List with element extraction
match [10, 20, 30] with | [x, y, z] -> x | _ -> 0 = stdout="10\n"

// Empty list
match [] with | [] -> 42 | _ -> 0 = stdout="42\n"

// List allocation then match
let xs = [1, 2] in match xs with | [a, b] -> a + b | _ -> 0 = stdout="3\n"

// ===================================================================
// Memory reuse stress test
// ===================================================================

// 5000 allocations of 24-byte tuples = 120KB, but heap is 64KB
// This only works because freed memory is reused via free list
def alloc_one() : int = let t = (1, 1) in t.0 + t.1 def loop(n: int, acc: int) : int = if n < 1 then acc else loop(n - 1, acc + alloc_one()) def main() : int = loop(5000, 0) = 10000
