// List tests for Phase 8

// === Empty List ===

// Empty list is Nil (represented as 0)
match [] with | [] -> 1 | _ -> 0 = stdout="1\n"

// Empty list fallback
match [] with | [x] -> x | [] -> 99 = stdout="99\n"

// === Single Element List ===

// Single element list
match [42] with | [x] -> x | _ -> 0 = stdout="42\n"

// Single element list with arithmetic
match [10] with | [x] -> x * 2 | _ -> 0 = stdout="20\n"

// Single element wildcard
match [100] with | [_] -> 1 | _ -> 0 = stdout="1\n"

// === Two Element List ===

// Two element list - sum
match [1, 2] with | [a, b] -> a + b | _ -> 0 = stdout="3\n"

// Two element list - product
match [3, 4] with | [a, b] -> a * b | _ -> 0 = stdout="12\n"

// Two element list - first element
match [10, 20] with | [a, _] -> a | _ -> 0 = stdout="10\n"

// Two element list - second element
match [10, 20] with | [_, b] -> b | _ -> 0 = stdout="20\n"

// === Three Element List ===

// Three element list - sum
match [10, 20, 30] with | [a, b, c] -> a + b + c | _ -> 0 = stdout="60\n"

// Three element list - middle element
match [1, 2, 3] with | [_, x, _] -> x | _ -> 0 = stdout="2\n"

// Three element list - product
match [2, 3, 4] with | [a, b, c] -> a * b * c | _ -> 0 = stdout="24\n"

// === Four Element List ===

// Four element list
match [1, 2, 3, 4] with | [a, b, c, d] -> a + b + c + d | _ -> 0 = stdout="10\n"

// === Five Element List ===

// Five element list
match [1, 2, 3, 4, 5] with | [a, b, c, d, e] -> a + b + c + d + e | _ -> 0 = stdout="15\n"

// === Wildcard Patterns ===

// All wildcards in list pattern
match [1, 2, 3] with | [_, _, _] -> 42 | _ -> 0 = stdout="42\n"

// Mix of binding and wildcard (3 elements)
match [5, 10, 15] with | [a, _, c] -> a + c | _ -> 0 = stdout="20\n"

// === Non-Matching Cases ===

// Empty list doesn't match single element pattern
match [] with | [x] -> x | [] -> 99 = stdout="99\n"

// Shorter list falls through to fallback
// (Note: matching longer pattern against shorter list crashes due to null deref)
match [1] with | [x] -> x | _ -> 99 = stdout="1\n"

// === List in Variable ===

// Store list in variable
let xs = [5, 10] in match xs with | [a, b] -> a * b | _ -> 0 = stdout="50\n"

// Store empty list in variable
let xs = [] in match xs with | [] -> 42 | _ -> 0 = stdout="42\n"

// Store longer list in variable
let xs = [1, 2, 3, 4] in match xs with | [a, b, c, d] -> a + b + c + d | _ -> 0 = stdout="10\n"

// === Computed List Elements ===

// List with computed elements
let x = 5 in match [x, x + 1, x + 2] with | [a, b, c] -> a + b + c | _ -> 0 = stdout="18\n"

// List with arithmetic expressions (2 elements to avoid register pressure)
match [2 + 3, 4 * 5] with | [a, b] -> a + b | _ -> 0 = stdout="25\n"

// === Nested Match ===

// Match result is a list, then match that
match [1] with | [x] -> match [x, x + 1] with | [a, b] -> a + b | _ -> 0 | _ -> 0 = stdout="3\n"

// Chain of list matches
match [2] with | [x] -> let y = x * 3 in match [y] with | [z] -> z | _ -> 0 | _ -> 0 = stdout="6\n"

// === List in Let Body ===

// Use match result in computation
match [5, 10] with | [a, b] -> (a + b) * 2 | _ -> 0 = stdout="30\n"

// Multiple bindings then use
match [1, 2] with | [x, y] -> match [3, 4] with | [a, b] -> x + y + a + b | _ -> 0 | _ -> 0 = stdout="10\n"

// === Edge Cases ===

// Single element list equals empty fallback
match [0] with | [] -> 1 | [x] -> x | _ -> 99 = stdout="0\n"

// Large numbers in list
match [1000000, 2000000] with | [a, b] -> a + b | _ -> 0 = stdout="3000000\n"

// Zero in list
match [0, 0, 0] with | [a, b, c] -> a + b + c | _ -> 99 = stdout="0\n"

// Negative numbers in list (via subtraction)
match [0 - 5, 0 - 10] with | [a, b] -> a + b | _ -> 0 = stdout="-15\n"

// === Pattern Order ===

// More specific pattern first
match [1] with | [] -> 0 | [x] -> x | _ -> 99 = stdout="1\n"

// Catch-all at end (use 2 elements to avoid pattern length mismatch issues)
match [1, 2] with | [] -> 0 | _ -> 99 = stdout="99\n"

// === Complex Bodies ===

// Conditional in body
match [5, 10] with | [a, b] -> if a < b then b else a | _ -> 0 = stdout="10\n"

// Let in body
match [3, 4] with | [a, b] -> let c = a * b in c + 1 | _ -> 0 = stdout="13\n"

// Nested let in body
match [2, 3] with | [a, b] -> let x = a + b in let y = x * 2 in y | _ -> 0 = stdout="10\n"

// === Length Mismatch Tests ===
// These test proper length validation - patterns should fall through when list is too short

// Match [a, b] against [1] - should fall through to wildcard
match [1] with | [a, b] -> a + b | _ -> 99 = stdout="99\n"

// Match [a, b, c] against [1, 2] - should fall through
match [1, 2] with | [a, b, c] -> a + b + c | _ -> 99 = stdout="99\n"

// Match [a] against [] - should fall through
match [] with | [a] -> a | _ -> 99 = stdout="99\n"

// Multiple length patterns - choose correct one
match [1] with | [a, b] -> 1 | [a] -> 2 | [] -> 3 | _ -> 99 = stdout="2\n"

// Empty list with multiple length patterns
match [] with | [a, b] -> 1 | [a] -> 2 | [] -> 3 = stdout="3\n"

// Two-element list with various length patterns
match [1, 2] with | [a, b, c] -> 1 | [a, b] -> 2 | [a] -> 3 | _ -> 99 = stdout="2\n"

// Pattern too long - 4 elements expected, 3 provided
match [1, 2, 3] with | [a, b, c, d] -> a + b + c + d | _ -> 99 = stdout="99\n"

// Pattern too long - 5 elements expected, 2 provided
match [1, 2] with | [a, b, c, d, e] -> a | _ -> 99 = stdout="99\n"

// === Exact-length matching (fixed) ===
// Pattern [a, b] now correctly matches only lists with exactly 2 elements
// VReg conflict issue fixed by initializing RegGen past max TempId
match [1, 2, 3] with | [a, b] -> a + b | _ -> 99 = stdout="99\n"
match [1, 2, 3, 4] with | [a, b, c] -> a + b + c | _ -> 99 = stdout="99\n"

// Verify exact matching works correctly
match [1, 2] with | [a, b] -> a + b | _ -> 99 = stdout="3\n"
match [1, 2, 3] with | [a, b, c] -> a + b + c | _ -> 99 = stdout="6\n"

// =====================================================
// Polymorphic List Tests (List<t>)
// =====================================================

// Bool list - single element
let bs = [true] in match bs with | [x] -> if x then 1 else 0 | _ -> 99 = 1

// Bool list - two elements
let bs = [true, false] in match bs with | [a, b] -> if a then 1 else 0 | _ -> 99 = 1

// Bool list - check second element
let bs = [false, true] in match bs with | [a, b] -> if b then 1 else 0 | _ -> 99 = 1

// Bool list - logical operations from extracted values
let bs = [true, true] in match bs with | [a, b] -> if a && b then 42 else 0 | _ -> 99 = 42

// Bool list - three elements
let bs = [true, false, true] in match bs with | [a, b, c] -> if a && c then 1 else 0 | _ -> 99 = 1

// Int lists still work as before
let xs = [10, 20, 30] in match xs with | [a, b, c] -> a + b + c | _ -> 0 = 60

// =====================================================
// Cons Pattern Tests [h, ...t]
// =====================================================

// Basic cons pattern - extract head
match [1, 2, 3] with | [h, ...t] -> h | [] -> 0 = 1

// Cons pattern - tail is a list
match [1, 2, 3] with | [h, ...t] -> match t with | [a, b] -> a + b | _ -> 0 | [] -> 0 = 5

// Empty list doesn't match [h, ...t]
match [] with | [h, ...t] -> 1 | [] -> 0 = 0

// Single element - tail is empty
match [42] with | [h, ...t] -> match t with | [] -> h | _ -> 0 | [] -> 0 = 42

// Multiple head elements before rest
match [1, 2, 3, 4] with | [a, b, ...t] -> a + b | [] -> 0 | _ -> 0 = 3

// Wildcard in head position
match [1, 2, 3] with | [_, ...t] -> match t with | [a, b] -> a + b | _ -> 0 | [] -> 0 = 5

// Wildcard as tail
match [1, 2, 3] with | [h, ..._] -> h | [] -> 0 = 1

// Rest pattern matches any list including empty: [...t]
match [] with | [...t] -> 1 | _ -> 0 = 1
match [1] with | [...t] -> 1 | _ -> 0 = 1

// Recursive length using cons pattern
def length(xs: List<Int64>) : Int64 = match xs with | [] -> 0 | [_, ...t] -> 1 + length(t) length([1, 2, 3, 4, 5]) = 5

// Recursive sum using cons pattern
def sum(xs: List<Int64>) : Int64 = match xs with | [] -> 0 | [h, ...t] -> h + sum(t) sum([1, 2, 3, 4, 5]) = 15

// =====================================================
// Stdlib.List Function Tests
// =====================================================

// Stdlib.List.isEmpty
Stdlib.List.isEmpty<Int64>([]) = stdout="true\n"
Stdlib.List.isEmpty<Int64>([1]) = stdout="false\n"
Stdlib.List.isEmpty<Int64>([1, 2, 3]) = stdout="false\n"

// Stdlib.List.length
Stdlib.List.length<Int64>([]) = stdout="0\n"
Stdlib.List.length<Int64>([1]) = stdout="1\n"
Stdlib.List.length<Int64>([1, 2]) = stdout="2\n"
Stdlib.List.length<Int64>([1, 2, 3]) = stdout="3\n"
Stdlib.List.length<Int64>([1, 2, 3, 4, 5]) = stdout="5\n"

// Stdlib.List.length with different types
Stdlib.List.length<Bool>([true, false, true]) = stdout="3\n"

// =====================================================
// List Spread Construction Tests [a, b, ...rest]
// =====================================================

// Basic spread construction - prepend single element
let x = [2, 3] in Stdlib.List.length<Int64>([1, ...x]) = stdout="3\n"

// Prepend multiple elements
let x = [3, 4] in Stdlib.List.length<Int64>([1, 2, ...x]) = stdout="4\n"

// Empty spread - just return tail
let x = [1, 2, 3] in Stdlib.List.length<Int64>([...x]) = stdout="3\n"

// Spread with empty tail (use function to get typed empty list)
def emptyList() : List<Int64> = [] Stdlib.List.length<Int64>([1, 2, ...emptyList()]) = stdout="2\n"

// Verify element values with pattern matching
let x = [2, 3] in match [1, ...x] with | [a, b, c] -> a + b + c | _ -> 0 = stdout="6\n"

// Prepend computed value
let x = [2, 3] in match [10 + 1, ...x] with | [a, b, c] -> a | _ -> 0 = stdout="11\n"

// Use in match case body
match [1, 2, 3] with | [h, ...rest] -> Stdlib.List.length<Int64>([h, ...rest]) | [] -> 0 = stdout="3\n"

// Rebuild list with modified head
match [1, 2, 3] with | [h, ...rest] -> match [h + 10, ...rest] with | [a, b, c] -> a + b + c | _ -> 0 | [] -> 0 = stdout="16\n"

// Chain of spreads
let a = [3] in let b = [2, ...a] in Stdlib.List.length<Int64>([1, ...b]) = stdout="3\n"
