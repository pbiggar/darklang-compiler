// List tests for Phase 8

// === Empty List ===

// Empty list is Nil (represented as 0)
match [] with | [] -> 1 | _ -> 0 = stdout="1\n"

// Empty list fallback
match [] with | [x] -> x | [] -> 99 = stdout="99\n"

// === Single Element List ===

// Single element list
match [42] with | [x] -> x | _ -> 0 = stdout="42\n"

// Single element list with arithmetic
match [10] with | [x] -> x * 2 | _ -> 0 = stdout="20\n"

// Single element wildcard
match [100] with | [_] -> 1 | _ -> 0 = stdout="1\n"

// === Two Element List ===

// Two element list - sum
match [1, 2] with | [a, b] -> a + b | _ -> 0 = stdout="3\n"

// Two element list - product
match [3, 4] with | [a, b] -> a * b | _ -> 0 = stdout="12\n"

// Two element list - first element
match [10, 20] with | [a, _] -> a | _ -> 0 = stdout="10\n"

// Two element list - second element
match [10, 20] with | [_, b] -> b | _ -> 0 = stdout="20\n"

// === Three Element List ===

// Three element list - sum
match [10, 20, 30] with | [a, b, c] -> a + b + c | _ -> 0 = stdout="60\n"

// Three element list - middle element
match [1, 2, 3] with | [_, x, _] -> x | _ -> 0 = stdout="2\n"

// Three element list - product
match [2, 3, 4] with | [a, b, c] -> a * b * c | _ -> 0 = stdout="24\n"

// === Four Element List ===

// Four element list
match [1, 2, 3, 4] with | [a, b, c, d] -> a + b + c + d | _ -> 0 = stdout="10\n"

// === Five Element List ===

// Five element list
match [1, 2, 3, 4, 5] with | [a, b, c, d, e] -> a + b + c + d + e | _ -> 0 = stdout="15\n"

// === Wildcard Patterns ===

// All wildcards in list pattern
match [1, 2, 3] with | [_, _, _] -> 42 | _ -> 0 = stdout="42\n"

// Mix of binding and wildcard (3 elements)
match [5, 10, 15] with | [a, _, c] -> a + c | _ -> 0 = stdout="20\n"

// === Non-Matching Cases ===

// Empty list doesn't match single element pattern
match [] with | [x] -> x | [] -> 99 = stdout="99\n"

// Shorter list falls through to fallback
// (Note: matching longer pattern against shorter list crashes due to null deref)
match [1] with | [x] -> x | _ -> 99 = stdout="1\n"

// === List in Variable ===

// Store list in variable
let xs = [5, 10] in match xs with | [a, b] -> a * b | _ -> 0 = stdout="50\n"

// Store empty list in variable
let xs = [] in match xs with | [] -> 42 | _ -> 0 = stdout="42\n"

// Store longer list in variable
let xs = [1, 2, 3, 4] in match xs with | [a, b, c, d] -> a + b + c + d | _ -> 0 = stdout="10\n"

// === Computed List Elements ===

// List with computed elements
let x = 5 in match [x, x + 1, x + 2] with | [a, b, c] -> a + b + c | _ -> 0 = stdout="18\n"

// List with arithmetic expressions (2 elements to avoid register pressure)
match [2 + 3, 4 * 5] with | [a, b] -> a + b | _ -> 0 = stdout="25\n"

// === Nested Match ===

// Match result is a list, then match that
match [1] with | [x] -> match [x, x + 1] with | [a, b] -> a + b | _ -> 0 | _ -> 0 = stdout="3\n"

// Chain of list matches
match [2] with | [x] -> let y = x * 3 in match [y] with | [z] -> z | _ -> 0 | _ -> 0 = stdout="6\n"

// === List in Let Body ===

// Use match result in computation
match [5, 10] with | [a, b] -> (a + b) * 2 | _ -> 0 = stdout="30\n"

// Multiple bindings then use
match [1, 2] with | [x, y] -> match [3, 4] with | [a, b] -> x + y + a + b | _ -> 0 | _ -> 0 = stdout="10\n"

// === Edge Cases ===

// Single element list equals empty fallback
match [0] with | [] -> 1 | [x] -> x | _ -> 99 = stdout="0\n"

// Large numbers in list
match [1000000, 2000000] with | [a, b] -> a + b | _ -> 0 = stdout="3000000\n"

// Zero in list
match [0, 0, 0] with | [a, b, c] -> a + b + c | _ -> 99 = stdout="0\n"

// Negative numbers in list (via subtraction)
match [0 - 5, 0 - 10] with | [a, b] -> a + b | _ -> 0 = stdout="-15\n"

// === Pattern Order ===

// More specific pattern first
match [1] with | [] -> 0 | [x] -> x | _ -> 99 = stdout="1\n"

// Catch-all at end (use 2 elements to avoid pattern length mismatch issues)
match [1, 2] with | [] -> 0 | _ -> 99 = stdout="99\n"

// === Complex Bodies ===

// Conditional in body
match [5, 10] with | [a, b] -> if a < b then b else a | _ -> 0 = stdout="10\n"

// Let in body
match [3, 4] with | [a, b] -> let c = a * b in c + 1 | _ -> 0 = stdout="13\n"

// Nested let in body
match [2, 3] with | [a, b] -> let x = a + b in let y = x * 2 in y | _ -> 0 = stdout="10\n"

// === Length Mismatch Tests ===
// These test proper length validation - patterns should fall through when list is too short

// Match [a, b] against [1] - should fall through to wildcard
match [1] with | [a, b] -> a + b | _ -> 99 = stdout="99\n"

// Match [a, b, c] against [1, 2] - should fall through
match [1, 2] with | [a, b, c] -> a + b + c | _ -> 99 = stdout="99\n"

// Match [a] against [] - should fall through
match [] with | [a] -> a | _ -> 99 = stdout="99\n"

// Multiple length patterns - choose correct one
match [1] with | [a, b] -> 1 | [a] -> 2 | [] -> 3 | _ -> 99 = stdout="2\n"

// Empty list with multiple length patterns
match [] with | [a, b] -> 1 | [a] -> 2 | [] -> 3 = stdout="3\n"

// Two-element list with various length patterns
match [1, 2] with | [a, b, c] -> 1 | [a, b] -> 2 | [a] -> 3 | _ -> 99 = stdout="2\n"

// Pattern too long - 4 elements expected, 3 provided
match [1, 2, 3] with | [a, b, c, d] -> a + b + c + d | _ -> 99 = stdout="99\n"

// Pattern too long - 5 elements expected, 2 provided
match [1, 2] with | [a, b, c, d, e] -> a | _ -> 99 = stdout="99\n"

// === Exact-length matching (fixed) ===
// Pattern [a, b] now correctly matches only lists with exactly 2 elements
// VReg conflict issue fixed by initializing RegGen past max TempId
match [1, 2, 3] with | [a, b] -> a + b | _ -> 99 = stdout="99\n"
match [1, 2, 3, 4] with | [a, b, c] -> a + b + c | _ -> 99 = stdout="99\n"

// Verify exact matching works correctly
match [1, 2] with | [a, b] -> a + b | _ -> 99 = stdout="3\n"
match [1, 2, 3] with | [a, b, c] -> a + b + c | _ -> 99 = stdout="6\n"
