// E2E tests for parametric polymorphism (generics)

// =====================================================
// Basic Identity Function
// =====================================================

// Generic identity function with int
def identity<t>(x: t) : t = x identity(42) = 42

// Identity with bool
def id<t>(x: t) : t = x id(true) = stdout="true\n"

// Identity with different int value
def ident<t>(x: t) : t = x ident(100) = 100

// =====================================================
// Multiple Instantiations
// =====================================================

// Using identity with different types in same expression
def myid<t>(x: t) : t = x myid(40) + myid(2) = 42

// =====================================================
// Generic Functions with Expressions
// =====================================================

// Generic function that uses its parameter
def return_it<t>(value: t) : t = value return_it(42) = 42

def ret<t>(v: t) : t = v ret(false) = stdout="false\n"

// =====================================================
// Generic with Operations on Result
// =====================================================

// Use generic result in arithmetic
def i<t>(x: t) : t = x i(6) * i(7) = 42

def j<t>(x: t) : t = x j(10) + 32 = 42

// =====================================================
// Generic with Let Bindings
// =====================================================

// Use generic in let binding
def k<t>(x: t) : t = x let x = k(21) in x * 2 = 42

def l<t>(x: t) : t = x let a = l(10) in let b = l(32) in a + b = 42

// =====================================================
// Type Inference at Call Sites
// =====================================================

// Basic inference - int inferred from argument
def inf_id<t>(x: t) : t = x inf_id(42) = 42

// Bool inference
def inf_bool<t>(x: t) : t = x inf_bool(true) = stdout="true\n"

// Inference with different int value
def inf_int2<t>(x: t) : t = x inf_int2(100) = 100

// Multiple calls with inference in expression
def inf_mult<t>(x: t) : t = x inf_mult(40) + inf_mult(2) = 42

// Inference with operations on result
def inf_op<t>(x: t) : t = x inf_op(6) * inf_op(7) = 42

// Inference with let binding
def inf_let<t>(x: t) : t = x let y = inf_let(21) in y * 2 = 42

// Mixed explicit and inferred - explicit still works
def mixed<t>(x: t) : t = x mixed(20) + mixed(22) = 42

// Inference with bool in conditional
def inf_cond<t>(x: t) : t = x if inf_cond(true) then 42 else 0 = 42

// =====================================================
// Multiple Type Parameters
// =====================================================

// Two type parameters - return first
def first<a, b>(a: a, b: b) : a = a first(42, true) = 42

// Two type parameters - return second
def second<a, b>(a: a, b: b) : b = b second(42, true) = stdout="true\n"

// Three type parameters
def pick1<a, b, c>(a: a, b: b, c: c) : a = a pick1(42, false, 99) = 42

def pick2<a, b, c>(a: a, b: b, c: c) : b = b pick2(99, true, 99) = stdout="true\n"

def pick3<a, b, c>(a: a, b: b, c: c) : c = c pick3(99, false, 42) = 42

// Type inference with multiple type parameters
def fst<a, b>(a: a, b: b) : a = a fst(10, true) = 10

def snd<a, b>(a: a, b: b) : b = b snd(10, false) = stdout="false\n"

// Inference with three parameters
def get1<a, b, c>(a: a, b: b, c: c) : a = a get1(42, true, false) = 42

def get2<a, b, c>(a: a, b: b, c: c) : b = b get2(99, true, false) = stdout="true\n"

def get3<a, b, c>(a: a, b: b, c: c) : c = c get3(99, true, false) = stdout="false\n"

// Multiple params with same type
def both_int<a, b>(a: a, b: b) : a = a both_int(42, 99) = 42

// Use result in expression
def fst2<a, b>(a: a, b: b) : a = a fst2(40, true) + 2 = 42

// Multiple params in let binding
def getfst<a, b>(a: a, b: b) : a = a let x = getfst(21, false) in x * 2 = 42

// =====================================================
// Generic Type Unification in If Expressions
// =====================================================

// If with generic Option - Some on then, None on else
type Option1<t> = None1 | Some1 of t match (if true then Some1(42) else None1) with | Some1(x) -> x | None1 -> 0 = 42

// If with generic Option - None on then, Some on else
type Option2<t> = None2 | Some2 of t match (if false then None2 else Some2(99)) with | Some2(x) -> x | None2 -> 0 = 99

// If with generic Option - variable holding None
type Option3<t> = None3 | Some3 of t let n = None3 in match (if true then Some3(55) else n) with | Some3(x) -> x | None3 -> 0 = 55

// If with generic Result type
// NOTE: Using Int64 for error type. String fails in test suite (parallel execution issue)
// but works in manual execution. Needs investigation.
type Result1<t, e> = Ok1 of t | Err1 of e match (if true then Ok1(42) else Err1(99)) with | Ok1(x) -> x | Err1(_) -> 0 = 42

// Nested if with generic types
type Option4<t> = None4 | Some4 of t match (if true then (if false then None4 else Some4(42)) else None4) with | Some4(x) -> x | None4 -> 0 = 42
