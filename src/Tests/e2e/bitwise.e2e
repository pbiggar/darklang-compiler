// Bitwise Operators Tests
//
// Tests covering:
// - Left shift (<<)
// - Right shift (>>)
// - Bitwise AND (&)
// - Bitwise XOR (^)
// - Bitwise NOT (~~~)
// Note: Bitwise OR (|) is not available as operator due to conflict with pattern matching.
// Use Stdlib.Int64.bitwiseOr function instead.


// ===================================================================
// Left Shift (<<)
// ===================================================================

// Basic shifts
1 << 0 = 1
1 << 1 = 2
1 << 2 = 4
1 << 3 = 8
1 << 4 = 16
1 << 5 = 32
1 << 6 = 64
1 << 7 = 128
1 << 8 = 256

// Shifting larger values
2 << 1 = 4
2 << 2 = 8
3 << 1 = 6
3 << 2 = 12
5 << 3 = 40
10 << 4 = 160

// Shifting by 0
42 << 0 = 42
100 << 0 = 100

// Large shifts
1 << 16 = 65536
1 << 20 = 1048576
1 << 30 = 1073741824
1 << 31 = 2147483648
1 << 32 = 4294967296
1 << 62 = 4611686018427387904


// ===================================================================
// Right Shift (>>)
// ===================================================================

// Basic shifts
256 >> 0 = 256
256 >> 1 = 128
256 >> 2 = 64
256 >> 3 = 32
256 >> 4 = 16
256 >> 5 = 8
256 >> 6 = 4
256 >> 7 = 2
256 >> 8 = 1

// Shifting larger values
100 >> 1 = 50
100 >> 2 = 25
64 >> 3 = 8
128 >> 4 = 8

// Shift to zero
1 >> 1 = 0
3 >> 2 = 0
7 >> 3 = 0
15 >> 4 = 0

// Large number shifts
1073741824 >> 30 = 1
4294967296 >> 32 = 1
4611686018427387904 >> 62 = 1


// ===================================================================
// Bitwise AND (&)
// ===================================================================

// Basic AND
0 & 0 = 0
1 & 0 = 0
0 & 1 = 0
1 & 1 = 1

// With larger values
255 & 0 = 0
255 & 255 = 255
255 & 15 = 15
15 & 255 = 15

// Binary patterns
// 0b1100 & 0b1010 = 0b1000 = 8
12 & 10 = 8
// 0b1111 & 0b1010 = 0b1010 = 10
15 & 10 = 10
// 0b10101010 & 0b01010101 = 0 (alternating bits)
170 & 85 = 0
// 0b11111111 & 0b10101010 = 0b10101010
255 & 170 = 170

// Masking operations
256 & 255 = 0
257 & 255 = 1
258 & 255 = 2
1000 & 255 = 232


// ===================================================================
// Bitwise XOR (^)
// ===================================================================

// Basic XOR
0 ^ 0 = 0
1 ^ 0 = 1
0 ^ 1 = 1
1 ^ 1 = 0

// XOR with same value = 0
42 ^ 42 = 0
255 ^ 255 = 0
1000 ^ 1000 = 0

// Binary patterns
// 0b1100 ^ 0b1010 = 0b0110 = 6
12 ^ 10 = 6
// 0b1111 ^ 0b1010 = 0b0101 = 5
15 ^ 10 = 5
// 0b10101010 ^ 0b01010101 = 0b11111111 = 255
170 ^ 85 = 255
// 0b11111111 ^ 0b10101010 = 0b01010101 = 85
255 ^ 170 = 85

// Toggle bits
255 ^ 1 = 254
255 ^ 128 = 127


// ===================================================================
// Bitwise NOT (~~~)
// ===================================================================

// Basic NOT - inverts all bits
~~~0 = -1                     // 0 -> all 1s (signed -1)
~~~1 = -2                     // 0b...0001 -> 0b...1110 (signed -2)
~~~2 = -3                     // 0b...0010 -> 0b...1101 (signed -3)
~~~(-1) = 0                   // all 1s -> 0

// Bit patterns
~~~255 = -256                 // 0x00FF -> 0xFF00 (sign-extended)
~~~256 = -257                 // 0x0100 -> 0xFEFF
~~~127 = -128                 // 0x7F -> 0x80

// Double negation is identity
~~~(~~~0) = 0
~~~(~~~1) = 1
~~~(~~~42) = 42
~~~(~~~(-1)) = -1
~~~(~~~9223372036854775807) = 9223372036854775807

// Property: x XOR ~~~x = -1 (all bits set)
(0 ^ ~~~0) = -1
(1 ^ ~~~1) = -1
(42 ^ ~~~42) = -1
(255 ^ ~~~255) = -1

// Property: x AND ~~~x = 0 (no common bits)
(0 & ~~~0) = 0
(1 & ~~~1) = 0
(42 & ~~~42) = 0
(255 & ~~~255) = 0

// Property: x OR ~~~x = -1 (all bits set)
Int64.bitwiseOr(0, ~~~0) = -1
Int64.bitwiseOr(1, ~~~1) = -1
Int64.bitwiseOr(42, ~~~42) = -1
Int64.bitwiseOr(255, ~~~255) = -1

// Combined with shifts
~~~(1 << 0) = -2              // Clear bit 0 (inverted)
~~~(1 << 3) = -9              // Clear bit 3 (inverted)
~~~(1 << 7) = -129            // Clear bit 7 (inverted)
~~~(1 << 63) = 9223372036854775807   // Min int -> Max int

// Masking patterns with NOT
(~~~255) & 65535 = 65280      // Mask out low byte: 0xFF00

// De Morgan's Law: ~~~(a & b) = (~~~a) | (~~~b)
~~~(12 & 10) = -9             // ~~~8 = -9
Int64.bitwiseOr(~~~12, ~~~10) = -9

// Constant folding verification (in variables)
let x = 42 in ~~~x = -43
let y = -1 in ~~~y = 0
let z = 0 in ~~~z = -1


// ===================================================================
// Wrapping Negation for Bit Manipulation
// ===================================================================

// Basic wrapping negation (two's complement)
0 - 1 = -1                       // Wrapping subtraction
0 - 12 = -12                     // Same as unary negation

// Lowest set bit pattern: x & -x (used in nqueen)
let x = 12 in x & (0 - x) = 4    // 12 = 0b1100, lowest bit at position 2 = 4
let x = 8 in x & (0 - x) = 8     // 8 = 0b1000, power of 2, result = 8
let x = 7 in x & (0 - x) = 1     // 7 = 0b0111, lowest bit = 1
let x = 1 in x & (0 - x) = 1     // 1 = 0b0001, lowest bit = 1

// Clear lowest set bit: x & (x - 1)
let x = 12 in x & (x - 1) = 8    // 12 = 0b1100 -> 0b1000 = 8
let x = 8 in x & (x - 1) = 0     // 8 = 0b1000 -> 0b0000 = 0
let x = 7 in x & (x - 1) = 6     // 7 = 0b0111 -> 0b0110 = 6

// nqueen availability check pattern
let avail = 23 in let pos = avail & (0 - avail) in pos = 1     // 23 = 0b10111, lowest = 1
let avail = 22 in let pos = avail & (0 - avail) in pos = 2     // 22 = 0b10110, lowest = 2
let avail = 20 in let pos = avail & (0 - avail) in pos = 4     // 20 = 0b10100, lowest = 4


// ===================================================================
// Combined Operations
// ===================================================================

// Shift and AND (common masking pattern)
(256 >> 1) & 255 = 128
(1 << 8) & 255 = 0
((1 << 4) - 1) = 15

// Extracting bits
(255 >> 4) & 15 = 15
(240 >> 4) & 15 = 15
(128 >> 7) & 1 = 1
(127 >> 7) & 1 = 0


// ===================================================================
// 64-bit Operations
// ===================================================================

// Powers of 2 via shift
1 << 10 = 1024
1 << 20 = 1048576
1 << 40 = 1099511627776
1 << 50 = 1125899906842624

// Large number shifts
1 << 63 = -9223372036854775808


// ===================================================================
// Stdlib Function Versions (coverage for function forms)
// ===================================================================

// Stdlib.Int64.bitwiseAnd
Int64.bitwiseAnd(12, 10) = 8
Int64.bitwiseAnd(255, 15) = 15
Int64.bitwiseAnd(0, 255) = 0

// Stdlib.Int64.bitwiseXor
Int64.bitwiseXor(12, 10) = 6
Int64.bitwiseXor(42, 42) = 0
Int64.bitwiseXor(170, 85) = 255

// Stdlib.Int64.shiftLeft
Int64.shiftLeft(1, 4) = 16
Int64.shiftLeft(1, 10) = 1024
Int64.shiftLeft(5, 3) = 40

// Stdlib.Int64.shiftRight
Int64.shiftRight(16, 4) = 1
Int64.shiftRight(1024, 10) = 1
Int64.shiftRight(256, 4) = 16

// Stdlib.Int64.bitwiseNot
Int64.bitwiseNot(0) = -1
Int64.bitwiseNot(1) = -2
Int64.bitwiseNot(-1) = 0
Int64.bitwiseNot(255) = -256
Int64.bitwiseNot(42) = -43
