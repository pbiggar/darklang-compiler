// Stdlib.dark - Standard Library Functions
//
// These functions are automatically included in all Dark programs.
// They provide the built-in Stdlib modules.

// Stdlib.Int64 - Integer operations

def Stdlib.Int64.add(a: Int64, b: Int64) : Int64 = a + b

def Stdlib.Int64.sub(a: Int64, b: Int64) : Int64 = a - b

def Stdlib.Int64.mul(a: Int64, b: Int64) : Int64 = a * b

def Stdlib.Int64.div(a: Int64, b: Int64) : Int64 = a / b

def Stdlib.Int64.max(a: Int64, b: Int64) : Int64 = if a > b then a else b

def Stdlib.Int64.min(a: Int64, b: Int64) : Int64 = if a < b then a else b

def Stdlib.Int64.mod(a: Int64, b: Int64) : Int64 = a % b

def Stdlib.Int64.absoluteValue(a: Int64) : Int64 = if a < 0 then 0 - a else a

def Stdlib.Int64.negate(a: Int64) : Int64 = 0 - a

def Stdlib.Int64.power(base: Int64, exponent: Int64) : Int64 =
    if exponent == 0 then 1
    else if exponent == 1 then base
    else base * Stdlib.Int64.power(base, exponent - 1)

def Stdlib.Int64.clamp(value: Int64, limitA: Int64, limitB: Int64) : Int64 =
    let lower = Stdlib.Int64.min(limitA, limitB) in
    let upper = Stdlib.Int64.max(limitA, limitB) in
    Stdlib.Int64.max(lower, Stdlib.Int64.min(upper, value))

def Stdlib.Int64.greaterThan(a: Int64, b: Int64) : Bool = a > b

def Stdlib.Int64.greaterThanOrEqualTo(a: Int64, b: Int64) : Bool = a >= b

def Stdlib.Int64.lessThan(a: Int64, b: Int64) : Bool = a < b

def Stdlib.Int64.lessThanOrEqualTo(a: Int64, b: Int64) : Bool = a <= b

// Bitwise operations
def Stdlib.Int64.bitwiseAnd(a: Int64, b: Int64) : Int64 = a & b

def Stdlib.Int64.bitwiseXor(a: Int64, b: Int64) : Int64 = a ^ b

def Stdlib.Int64.shiftLeft(a: Int64, shift: Int64) : Int64 = a << shift

def Stdlib.Int64.shiftRight(a: Int64, shift: Int64) : Int64 = a >> shift

// Count number of set bits (population count)
// Uses parallel bit counting algorithm (Brian Kernighan / SWAR)
def Stdlib.Int64.popcount(x: Int64) : Int64 =
    // Constants (in decimal):
    // 0x5555555555555555 = 6148914691236517205
    // 0x3333333333333333 = 3689348814741910323
    // 0x0F0F0F0F0F0F0F0F = 1085102592571150095
    // 0x0101010101010101 = 72340172838076673
    let mask1 = 6148914691236517205 in
    let mask2 = 3689348814741910323 in
    let mask3 = 1085102592571150095 in
    let mult = 72340172838076673 in
    let x = x - ((x >> 1) & mask1) in
    let x = (x & mask2) + ((x >> 2) & mask2) in
    let x = (x + (x >> 4)) & mask3 in
    (x * mult) >> 56

// Convert a single digit (0-9) to its string representation
def Stdlib.Int64.digitToString(n: Int64) : String =
    match n with
    | 0 -> "0"
    | 1 -> "1"
    | 2 -> "2"
    | 3 -> "3"
    | 4 -> "4"
    | 5 -> "5"
    | 6 -> "6"
    | 7 -> "7"
    | 8 -> "8"
    | 9 -> "9"
    | _ -> "?"

// Convert an integer to its string representation
def Stdlib.Int64.toString(n: Int64) : String =
    if n < 0 then "-" ++ Stdlib.Int64.toString(0 - n)
    else if n < 10 then Stdlib.Int64.digitToString(n)
    else Stdlib.Int64.toString(n / 10) ++ Stdlib.Int64.digitToString(n % 10)

// Stdlib.Bool - Boolean operations

def Stdlib.Bool.not(b: Bool) : Bool = !b

def Stdlib.Bool.and(a: Bool, b: Bool) : Bool = a && b

def Stdlib.Bool.or(a: Bool, b: Bool) : Bool = a || b

def Stdlib.Bool.xor(a: Bool, b: Bool) : Bool = if a then !b else b

def Stdlib.Bool.toString(b: Bool) : String = if b then "true" else "false"

// Stdlib.Tuple2 - 2-tuple operations

def Stdlib.Tuple2.create<a, b>(first: a, second: b) : (a, b) = (first, second)

def Stdlib.Tuple2.first<a, b>(t: (a, b)) : a = match t with | (x, y) -> x

def Stdlib.Tuple2.second<a, b>(t: (a, b)) : b = match t with | (x, y) -> y

def Stdlib.Tuple2.swap<a, b>(t: (a, b)) : (b, a) = match t with | (x, y) -> (y, x)

def Stdlib.Tuple2.mapFirst<a, b, c>(fn: (a) -> c, t: (a, b)) : (c, b) =
    match t with | (x, y) -> (fn(x), y)

def Stdlib.Tuple2.mapSecond<a, b, c>(fn: (b) -> c, t: (a, b)) : (a, c) =
    match t with | (x, y) -> (x, fn(y))

def Stdlib.Tuple2.mapBoth<a, b, c, d>(fnFirst: (a) -> c, fnSecond: (b) -> d, t: (a, b)) : (c, d) =
    match t with | (x, y) -> (fnFirst(x), fnSecond(y))

// Stdlib.Tuple3 - 3-tuple operations

def Stdlib.Tuple3.create<a, b, c>(first: a, second: b, third: c) : (a, b, c) = (first, second, third)

def Stdlib.Tuple3.first<a, b, c>(t: (a, b, c)) : a = match t with | (x, y, z) -> x

def Stdlib.Tuple3.second<a, b, c>(t: (a, b, c)) : b = match t with | (x, y, z) -> y

def Stdlib.Tuple3.third<a, b, c>(t: (a, b, c)) : c = match t with | (x, y, z) -> z

def Stdlib.Tuple3.mapFirst<a, b, c, d>(fn: (a) -> d, t: (a, b, c)) : (d, b, c) =
    match t with | (x, y, z) -> (fn(x), y, z)

def Stdlib.Tuple3.mapSecond<a, b, c, d>(fn: (b) -> d, t: (a, b, c)) : (a, d, c) =
    match t with | (x, y, z) -> (x, fn(y), z)

def Stdlib.Tuple3.mapThird<a, b, c, d>(fn: (c) -> d, t: (a, b, c)) : (a, b, d) =
    match t with | (x, y, z) -> (x, y, fn(z))

def Stdlib.Tuple3.mapAllThree<a, b, c, d, e, f>(fnFirst: (a) -> d, fnSecond: (b) -> e, fnThird: (c) -> f, t: (a, b, c)) : (d, e, f) =
    match t with | (x, y, z) -> (fnFirst(x), fnSecond(y), fnThird(z))

// Stdlib.Result - Result type for error handling
type Stdlib.Result.Result<t, e> = Ok of t | Error of e

// Check if result is Ok
def Stdlib.Result.isOk<t, e>(result: Stdlib.Result.Result<t, e>) : Bool =
    match result with
    | Ok(_) -> true
    | Error(_) -> false

// Check if result is Error
def Stdlib.Result.isError<t, e>(result: Stdlib.Result.Result<t, e>) : Bool =
    match result with
    | Ok(_) -> false
    | Error(_) -> true

// Get the Ok value or return a default
def Stdlib.Result.withDefault<t, e>(result: Stdlib.Result.Result<t, e>, default: t) : t =
    match result with
    | Ok(v) -> v
    | Error(_) -> default

// Transform the Ok value with a function
def Stdlib.Result.map<t, u, e>(result: Stdlib.Result.Result<t, e>, fn: (t) -> u) : Stdlib.Result.Result<u, e> =
    match result with
    | Ok(v) -> Ok(fn(v))
    | Error(err) -> Error(err)

// Transform the Error value with a function
def Stdlib.Result.mapError<t, e, f>(fn: (e) -> f, result: Stdlib.Result.Result<t, e>) : Stdlib.Result.Result<t, f> =
    match result with
    | Ok(v) -> Ok(v)
    | Error(err) -> Error(fn(err))

// Chain Result computations
def Stdlib.Result.andThen<t, u, e>(result: Stdlib.Result.Result<t, e>, fn: (t) -> Stdlib.Result.Result<u, e>) : Stdlib.Result.Result<u, e> =
    match result with
    | Ok(v) -> fn(v)
    | Error(err) -> Error(err)

// Stdlib.Option - Optional values
type Stdlib.Option.Option<t> = Some of t | None

// Check if option has a value
def Stdlib.Option.isSome<t>(opt: Stdlib.Option.Option<t>) : Bool =
    match opt with
    | Some(_) -> true
    | None -> false

// Check if option is empty
def Stdlib.Option.isNone<t>(opt: Stdlib.Option.Option<t>) : Bool =
    match opt with
    | Some(_) -> false
    | None -> true

// Get the value or return a default
def Stdlib.Option.withDefault<t>(opt: Stdlib.Option.Option<t>, default: t) : t =
    match opt with
    | Some(v) -> v
    | None -> default

// Transform the value with a function if present
def Stdlib.Option.map<t, u>(opt: Stdlib.Option.Option<t>, fn: (t) -> u) : Stdlib.Option.Option<u> =
    match opt with
    | Some(v) -> Some(fn(v))
    | None -> None

// Chain Option computations
def Stdlib.Option.andThen<t, u>(opt: Stdlib.Option.Option<t>, fn: (t) -> Stdlib.Option.Option<u>) : Stdlib.Option.Option<u> =
    match opt with
    | Some(v) -> fn(v)
    | None -> None

// Convert Option to a single-element or empty list
def Stdlib.Option.toList<t>(opt: Stdlib.Option.Option<t>) : List<t> =
    match opt with
    | Some(v) -> [v]
    | None -> []

// Stdlib.List - List operations
// Lists are represented as: Nil = 0, Cons = [tag=1, head, tail]

// Check if list is empty
def Stdlib.List.isEmpty<t>(list: List<t>) : Bool =
    match list with
    | [] -> true
    | _ -> false

// Get the length of a list
def Stdlib.List.length<t>(list: List<t>) : Int64 =
    match list with
    | [] -> 0
    | [h, ...rest] -> 1 + Stdlib.List.length<t>(rest)

// Create a single-element list
def Stdlib.List.singleton<t>(value: t) : List<t> = [value]

// Prepend an element to a list
def Stdlib.List.push<t>(list: List<t>, value: t) : List<t> = [value, ...list]

// Apply a function to each element of a list
def Stdlib.List.map<a, b>(list: List<a>, fn: (a) -> b) : List<b> =
    match list with
    | [] -> []
    | [h, ...t] -> [fn(h), ...Stdlib.List.map<a, b>(t, fn)]

// Flatten a list of lists into a single list
def Stdlib.List.flatten<a>(lists: List<List<a>>) : List<a> =
    match lists with
    | [] -> []
    | [h, ...t] -> Stdlib.List.append<a>(h, Stdlib.List.flatten<a>(t))

// Apply a function that returns a list and flatten the results
def Stdlib.List.flatMap<a, b>(list: List<a>, fn: (a) -> List<b>) : List<b> =
    Stdlib.List.flatten<b>(Stdlib.List.map<a, List<b>>(list, fn))

// Keep only elements that satisfy a predicate
def Stdlib.List.filter<a>(list: List<a>, fn: (a) -> Bool) : List<a> =
    match list with
    | [] -> []
    | [h, ...t] ->
        if fn(h) then [h, ...Stdlib.List.filter<a>(t, fn)]
        else Stdlib.List.filter<a>(t, fn)

// Append an element to the end of a list
def Stdlib.List.pushBack<a>(list: List<a>, value: a) : List<a> =
    match list with
    | [] -> [value]
    | [h, ...t] -> [h, ...Stdlib.List.pushBack<a>(t, value)]

// Concatenate two lists
def Stdlib.List.append<a>(list1: List<a>, list2: List<a>) : List<a> =
    match list1 with
    | [] -> list2
    | [h, ...t] -> [h, ...Stdlib.List.append<a>(t, list2)]

// Reverse a list
def Stdlib.List.reverse<a>(list: List<a>) : List<a> =
    Stdlib.List.__reverseHelper<a>(list, [])

def Stdlib.List.__reverseHelper<a>(list: List<a>, acc: List<a>) : List<a> =
    match list with
    | [] -> acc
    | [h, ...t] -> Stdlib.List.__reverseHelper<a>(t, [h, ...acc])

// Fold left (reduce) over a list
def Stdlib.List.fold<a, b>(list: List<a>, init: b, fn: (b, a) -> b) : b =
    match list with
    | [] -> init
    | [h, ...t] -> Stdlib.List.fold<a, b>(t, fn(init, h), fn)

// Get head of list or return None
def Stdlib.List.head<a>(list: List<a>) : Stdlib.Option.Option<a> =
    match list with
    | [] -> None
    | [h, ...t] -> Some(h)

// Get tail of list or return None
def Stdlib.List.tail<a>(list: List<a>) : Stdlib.Option.Option<List<a>> =
    match list with
    | [] -> None
    | [h, ...t] -> Some(t)

// Get element at index (0-based)
def Stdlib.List.getAt<a>(list: List<a>, index: Int64) : Stdlib.Option.Option<a> =
    if index < 0 then None
    else match list with
    | [] -> None
    | [h, ...t] -> if index == 0 then Some(h) else Stdlib.List.getAt<a>(t, index - 1)

// Find first element satisfying a predicate
def Stdlib.List.findFirst<a>(list: List<a>, fn: (a) -> Bool) : Stdlib.Option.Option<a> =
    match list with
    | [] -> None
    | [h, ...t] -> if fn(h) then Some(h) else Stdlib.List.findFirst<a>(t, fn)

// Take first n elements
def Stdlib.List.take<a>(list: List<a>, n: Int64) : List<a> =
    if n <= 0 then []
    else match list with
    | [] -> []
    | [h, ...t] -> [h, ...Stdlib.List.take<a>(t, n - 1)]

// Drop first n elements
def Stdlib.List.drop<a>(list: List<a>, n: Int64) : List<a> =
    if n <= 0 then list
    else match list with
    | [] -> []
    | [h, ...t] -> Stdlib.List.drop<a>(t, n - 1)

// Check if all elements satisfy a predicate
def Stdlib.List.forAll<a>(list: List<a>, fn: (a) -> Bool) : Bool =
    match list with
    | [] -> true
    | [h, ...t] -> fn(h) && Stdlib.List.forAll<a>(t, fn)

// Check if any element satisfies a predicate
def Stdlib.List.exists<a>(list: List<a>, fn: (a) -> Bool) : Bool =
    match list with
    | [] -> false
    | [h, ...t] -> fn(h) || Stdlib.List.exists<a>(t, fn)

// TODO: List.zip is disabled due to compiler bug with tuple recursion
// def Stdlib.List.zip<a, b>(list1: List<a>, list2: List<b>) : List<(a, b)> =
//     match (list1, list2) with
//     | ([], _) -> []
//     | (_, []) -> []
//     | ([h1, ...t1], [h2, ...t2]) -> [(h1, h2), ...Stdlib.List.zip<a, b>(t1, t2)]

// Stdlib.Path - Path operations

// Combine two path segments
def Stdlib.Path.combine(a: String, b: String) : String = a ++ "/" ++ b

// Get system temp directory (constant-folded at compile time)
// This is an intrinsic that returns "/tmp" on both macOS and Linux
// Note: The actual implementation is in the compiler, this is just type info
def Stdlib.Path.tempDir() : String = "/tmp"

// Stdlib.Platform - Platform detection (constant-folded at compile time)

// Check if running on macOS
def Stdlib.Platform.isMacOS() : Bool = false

// Check if running on Linux
def Stdlib.Platform.isLinux() : Bool = false

// Stdlib.String - String operations

// Newline constant (nullary function)
def Stdlib.String.newline() : String = "\n"

// Append two strings
def Stdlib.String.append(s1: String, s2: String) : String = s1 ++ s2

// Prepend first string to second
def Stdlib.String.prepend(s2: String, s1: String) : String = s1 ++ s2

// Get the length of a string in bytes
// String format: [len:8 bytes][data:N bytes]
def Stdlib.String.length(s: String) : Int64 =
    __raw_get<Int64>(__int64_to_rawptr(__string_to_int64(s)), 0)

// Check if string is empty
def Stdlib.String.isEmpty(s: String) : Bool =
    Stdlib.String.length(s) == 0

// Get the byte value at a given index (0-based)
// Returns the byte as an Int64 (0-255)
// String data starts at offset 8 (after the length field)
def Stdlib.String.getByteAt(s: String, index: Int64) : Int64 =
    __raw_get_byte(__int64_to_rawptr(__string_to_int64(s)), index + 8)

// Check if a byte is an ASCII lowercase letter (a-z)
def Stdlib.String.__isLowercase(byte: Int64) : Bool =
    byte >= 97 && byte <= 122

// Check if a byte is an ASCII uppercase letter (A-Z)
def Stdlib.String.__isUppercase(byte: Int64) : Bool =
    byte >= 65 && byte <= 90

// Internal: Compare n bytes starting at positions in two strings
// Returns true if all bytes match
def Stdlib.String.__compareBytes(s1: String, start1: Int64, s2: String, start2: Int64, count: Int64) : Bool =
    if count <= 0 then
        true
    else
        let b1 = Stdlib.String.getByteAt(s1, start1) in
        let b2 = Stdlib.String.getByteAt(s2, start2) in
        if b1 != b2 then
            false
        else
            Stdlib.String.__compareBytes(s1, start1 + 1, s2, start2 + 1, count - 1)

// Check if string starts with prefix
def Stdlib.String.startsWith(s: String, prefix: String) : Bool =
    let sLen = Stdlib.String.length(s) in
    let prefixLen = Stdlib.String.length(prefix) in
    if prefixLen > sLen then
        false
    else
        Stdlib.String.__compareBytes(s, 0, prefix, 0, prefixLen)

// Check if string ends with suffix
def Stdlib.String.endsWith(s: String, suffix: String) : Bool =
    let sLen = Stdlib.String.length(s) in
    let suffixLen = Stdlib.String.length(suffix) in
    if suffixLen > sLen then
        false
    else
        Stdlib.String.__compareBytes(s, sLen - suffixLen, suffix, 0, suffixLen)

// Internal: Find substring starting at offset, returns -1 if not found
def Stdlib.String.__findFrom(s: String, search: String, offset: Int64) : Int64 =
    let sLen = Stdlib.String.length(s) in
    let searchLen = Stdlib.String.length(search) in
    if searchLen == 0 then
        offset  // Empty string is always found at current position
    else if offset + searchLen > sLen then
        -1  // Not enough characters left
    else if Stdlib.String.__compareBytes(s, offset, search, 0, searchLen) then
        offset  // Found match at this position
    else
        Stdlib.String.__findFrom(s, search, offset + 1)

// Find position of first occurrence of search string, returns -1 if not found
def Stdlib.String.indexOf(s: String, search: String) : Int64 =
    Stdlib.String.__findFrom(s, search, 0)

// Check if string contains substring
def Stdlib.String.contains(s: String, search: String) : Bool =
    Stdlib.String.indexOf(s, search) >= 0

// Internal: Copy n bytes from source string to destination raw pointer
def Stdlib.String.__copyBytesToPtr(src: String, srcStart: Int64, dest: RawPtr, destStart: Int64, count: Int64) : Unit =
    if count <= 0 then
        ()
    else
        let byte = Stdlib.String.getByteAt(src, srcStart) in
        let _ = __raw_set_byte(dest, destStart, byte) in
        Stdlib.String.__copyBytesToPtr(src, srcStart + 1, dest, destStart + 1, count - 1)

// Extract substring from start index with given length
// String format: [length:8 bytes][data:N bytes][refcount:8 bytes]
def Stdlib.String.slice(s: String, start: Int64, len: Int64) : String =
    let sLen = Stdlib.String.length(s) in
    // Clamp start and len to valid range
    let actualStart = if start < 0 then 0 else if start > sLen then sLen else start in
    let maxLen = sLen - actualStart in
    let actualLen = if len < 0 then 0 else if len > maxLen then maxLen else len in
    if actualLen == 0 then
        ""
    else
        // Allocate: 8 (length) + actualLen (data) + 8 (refcount) = 16 + actualLen
        let totalSize = 16 + actualLen in
        let ptr = __raw_alloc(totalSize) in
        // Write length at offset 0
        let _ = __raw_set<Int64>(ptr, 0, actualLen) in
        // Copy bytes from source (offset 8 + actualStart) to dest (offset 8)
        let _ = Stdlib.String.__copyBytesToPtr(s, actualStart, ptr, 8, actualLen) in
        // Write refcount = 1 at offset (8 + actualLen)
        let _ = __raw_set<Int64>(ptr, 8 + actualLen, 1) in
        // Convert raw pointer to string
        __int64_to_string(__rawptr_to_int64(ptr))

// Get substring from start to end (excluding end)
def Stdlib.String.substring(s: String, start: Int64, end_: Int64) : String =
    Stdlib.String.slice(s, start, end_ - start)

// Get first n characters
def Stdlib.String.take(s: String, n: Int64) : String =
    Stdlib.String.slice(s, 0, n)

// Drop first n characters
def Stdlib.String.drop(s: String, n: Int64) : String =
    let sLen = Stdlib.String.length(s) in
    Stdlib.String.slice(s, n, sLen - n)

// =============================================================================
// UTF-8 Decoding (for Unicode support)
// =============================================================================

// Decode a single UTF-8 codepoint starting at byteIndex
// Returns (codepoint, bytesConsumed) tuple
// UTF-8 encoding:
//   - 1 byte:  0xxxxxxx (ASCII, 0-127)
//   - 2 bytes: 110xxxxx 10xxxxxx (128-2047)
//   - 3 bytes: 1110xxxx 10xxxxxx 10xxxxxx (2048-65535)
//   - 4 bytes: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx (65536-1114111)
def Stdlib.String.__decodeUtf8At(s: String, byteIndex: Int64) : (Int64, Int64) =
    let b0 = Stdlib.String.getByteAt(s, byteIndex) in
    if b0 < 128 then
        // 1-byte (ASCII): 0xxxxxxx
        (b0, 1)
    else if b0 < 224 then
        // 2-byte: 110xxxxx 10xxxxxx
        let b1 = Stdlib.String.getByteAt(s, byteIndex + 1) in
        let cp = ((b0 & 31) << 6) ^ (b1 & 63) in
        (cp, 2)
    else if b0 < 240 then
        // 3-byte: 1110xxxx 10xxxxxx 10xxxxxx
        let b1 = Stdlib.String.getByteAt(s, byteIndex + 1) in
        let b2 = Stdlib.String.getByteAt(s, byteIndex + 2) in
        let cp = ((b0 & 15) << 12) ^ ((b1 & 63) << 6) ^ (b2 & 63) in
        (cp, 3)
    else
        // 4-byte: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        let b1 = Stdlib.String.getByteAt(s, byteIndex + 1) in
        let b2 = Stdlib.String.getByteAt(s, byteIndex + 2) in
        let b3 = Stdlib.String.getByteAt(s, byteIndex + 3) in
        let cp = ((b0 & 7) << 18) ^ ((b1 & 63) << 12) ^ ((b2 & 63) << 6) ^ (b3 & 63) in
        (cp, 4)

// Convert a string to a list of Unicode codepoints
def Stdlib.String.toCodepoints(s: String) : List<Int64> =
    Stdlib.String.__toCodepointsHelper(s, 0, Stdlib.String.length(s), [])

// Helper: recursively decode codepoints
def Stdlib.String.__toCodepointsHelper(s: String, byteIndex: Int64, byteLen: Int64, acc: List<Int64>) : List<Int64> =
    if byteIndex >= byteLen then
        Stdlib.List.reverse<Int64>(acc)
    else
        let result = Stdlib.String.__decodeUtf8At(s, byteIndex) in
        let cp = Stdlib.Tuple2.first<Int64, Int64>(result) in
        let consumed = Stdlib.Tuple2.second<Int64, Int64>(result) in
        Stdlib.String.__toCodepointsHelper(s, byteIndex + consumed, byteLen, [cp, ...acc])

// Get the number of codepoints in a string (not bytes)
def Stdlib.String.codepointLength(s: String) : Int64 =
    Stdlib.List.length<Int64>(Stdlib.String.toCodepoints(s))

// =============================================================================
// UTF-8 Encoding (codepoints to string)
// =============================================================================

// Calculate UTF-8 byte length for a single codepoint
def Stdlib.String.__utf8ByteLen(cp: Int64) : Int64 =
    if cp < 128 then 1
    else if cp < 2048 then 2
    else if cp < 65536 then 3
    else 4

// Calculate total UTF-8 byte length for a list of codepoints
def Stdlib.String.__totalUtf8Len(cps: List<Int64>) : Int64 =
    Stdlib.List.fold<Int64, Int64>(cps, 0, (acc: Int64, cp: Int64) => acc + Stdlib.String.__utf8ByteLen(cp))

// Encode a single codepoint to UTF-8 bytes at given offset, return new offset
def Stdlib.String.__encodeUtf8At(ptr: RawPtr, offset: Int64, cp: Int64) : Int64 =
    if cp < 128 then
        // 1-byte: 0xxxxxxx
        let _ = __raw_set_byte(ptr, offset, cp) in
        offset + 1
    else if cp < 2048 then
        // 2-byte: 110xxxxx 10xxxxxx
        let b0 = 192 ^ (cp >> 6) in
        let b1 = 128 ^ (cp & 63) in
        let _ = __raw_set_byte(ptr, offset, b0) in
        let _ = __raw_set_byte(ptr, offset + 1, b1) in
        offset + 2
    else if cp < 65536 then
        // 3-byte: 1110xxxx 10xxxxxx 10xxxxxx
        let b0 = 224 ^ (cp >> 12) in
        let b1 = 128 ^ ((cp >> 6) & 63) in
        let b2 = 128 ^ (cp & 63) in
        let _ = __raw_set_byte(ptr, offset, b0) in
        let _ = __raw_set_byte(ptr, offset + 1, b1) in
        let _ = __raw_set_byte(ptr, offset + 2, b2) in
        offset + 3
    else
        // 4-byte: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        let b0 = 240 ^ (cp >> 18) in
        let b1 = 128 ^ ((cp >> 12) & 63) in
        let b2 = 128 ^ ((cp >> 6) & 63) in
        let b3 = 128 ^ (cp & 63) in
        let _ = __raw_set_byte(ptr, offset, b0) in
        let _ = __raw_set_byte(ptr, offset + 1, b1) in
        let _ = __raw_set_byte(ptr, offset + 2, b2) in
        let _ = __raw_set_byte(ptr, offset + 3, b3) in
        offset + 4

// Encode all codepoints starting at offset
def Stdlib.String.__encodeCodepointsAt(ptr: RawPtr, offset: Int64, cps: List<Int64>) : Int64 =
    match cps with
    | [] -> offset
    | [cp, ...rest] ->
        let newOffset = Stdlib.String.__encodeUtf8At(ptr, offset, cp) in
        Stdlib.String.__encodeCodepointsAt(ptr, newOffset, rest)

// Build a string from a list of Unicode codepoints
// String format: [length:8 bytes][data:N bytes][refcount:8 bytes]
def Stdlib.String.fromCodepoints(cps: List<Int64>) : String =
    let byteLen = Stdlib.String.__totalUtf8Len(cps) in
    if byteLen == 0 then
        ""
    else
        // Allocate: 8 (length) + byteLen (data) + 8 (refcount)
        let totalSize = 16 + byteLen in
        let ptr = __raw_alloc(totalSize) in
        // Write length at offset 0
        let _ = __raw_set<Int64>(ptr, 0, byteLen) in
        // Encode codepoints starting at offset 8
        let _ = Stdlib.String.__encodeCodepointsAt(ptr, 8, cps) in
        // Write refcount = 1 at end
        let _ = __raw_set<Int64>(ptr, 8 + byteLen, 1) in
        __int64_to_string(__rawptr_to_int64(ptr))

// =============================================================================
// Case Mapping Functions (ASCII fast path, with Unicode table fallback)
// =============================================================================

// Map ASCII lowercase to uppercase (a-z -> A-Z)
def Stdlib.String.__asciiToUpper(cp: Int64) : Int64 =
    if cp >= 97 && cp <= 122 then cp - 32 else cp

// Map ASCII uppercase to lowercase (A-Z -> a-z)
def Stdlib.String.__asciiToLower(cp: Int64) : Int64 =
    if cp >= 65 && cp <= 90 then cp + 32 else cp

// Helper: map codepoints to uppercase ASCII (simple version)
def Stdlib.String.__mapUpperAscii(cps: List<Int64>, acc: List<Int64>) : List<Int64> =
    match cps with
    | [] -> Stdlib.List.reverse<Int64>(acc)
    | [cp, ...rest] ->
        let upper = Stdlib.String.__asciiToUpper(cp) in
        Stdlib.String.__mapUpperAscii(rest, [upper, ...acc])

// Helper: map codepoints to lowercase ASCII (simple version)
def Stdlib.String.__mapLowerAscii(cps: List<Int64>, acc: List<Int64>) : List<Int64> =
    match cps with
    | [] -> Stdlib.List.reverse<Int64>(acc)
    | [cp, ...rest] ->
        let lower = Stdlib.String.__asciiToLower(cp) in
        Stdlib.String.__mapLowerAscii(rest, [lower, ...acc])

// Convert string to uppercase (ASCII only for now)
def Stdlib.String.toUpperCase(s: String) : String =
    let codepoints = Stdlib.String.toCodepoints(s) in
    let upper = Stdlib.String.__mapUpperAscii(codepoints, []) in
    Stdlib.String.fromCodepoints(upper)

// Convert string to lowercase (ASCII only for now)
def Stdlib.String.toLowerCase(s: String) : String =
    let codepoints = Stdlib.String.toCodepoints(s) in
    let lower = Stdlib.String.__mapLowerAscii(codepoints, []) in
    Stdlib.String.fromCodepoints(lower)

// =============================================================================
// Grapheme Cluster Segmentation (simplified UAX #29)
// =============================================================================
// Grapheme break categories (simplified):
// - CR (13), LF (10): newline handling
// - ZWJ (8205): zero-width joiner for emoji sequences
// - Extend: combining marks, variation selectors, skin tone modifiers

// Check if codepoint is a combining/extending character
def Stdlib.String.__isExtend(cp: Int64) : Bool =
    // Combining Diacritical Marks (0300-036F)
    (cp >= 768 && cp <= 879) ||
    // Variation Selectors (FE00-FE0F)
    (cp >= 65024 && cp <= 65039) ||
    // Combining Diacritical Marks Extended (1AB0-1AFF)
    (cp >= 6832 && cp <= 6911) ||
    // Combining Half Marks (FE20-FE2F)
    (cp >= 65056 && cp <= 65071) ||
    // Emoji Fitzpatrick modifiers (skin tones) (1F3FB-1F3FF)
    (cp >= 127995 && cp <= 127999) ||
    // Emoji component (hair styles, etc) - simplified range
    (cp >= 127988 && cp <= 127988)

// Check if codepoint is ZWJ (Zero Width Joiner)
def Stdlib.String.__isZWJ(cp: Int64) : Bool = cp == 8205

// Segment codepoints into grapheme clusters
// Returns list of codepoint lists (each inner list is one grapheme)
def Stdlib.String.__segmentGraphemes(cps: List<Int64>, current: List<Int64>, result: List<List<Int64>>) : List<List<Int64>> =
    match cps with
    | [] ->
        // End of input - add current grapheme if non-empty
        if Stdlib.List.isEmpty<Int64>(current) then
            Stdlib.List.reverse<List<Int64>>(result)
        else
            Stdlib.List.reverse<List<Int64>>([Stdlib.List.reverse<Int64>(current), ...result])
    | [cp, ...rest] ->
        if Stdlib.List.isEmpty<Int64>(current) then
            // Start new grapheme
            Stdlib.String.__segmentGraphemes(rest, [cp], result)
        else if Stdlib.String.__isExtend(cp) || Stdlib.String.__isZWJ(cp) then
            // Extend current grapheme
            Stdlib.String.__segmentGraphemes(rest, [cp, ...current], result)
        else if cp == 10 then
            // LF - check if preceded by CR
            match current with
            | [13] ->
                // CR + LF = single grapheme
                Stdlib.String.__segmentGraphemes(rest, [], [Stdlib.List.reverse<Int64>([cp, ...current]), ...result])
            | _ ->
                // LF alone - end current, LF is its own grapheme
                Stdlib.String.__segmentGraphemes(rest, [], [[cp], Stdlib.List.reverse<Int64>(current), ...result])
        else
            // New base character - end current grapheme, start new one
            Stdlib.String.__segmentGraphemes(rest, [cp], [Stdlib.List.reverse<Int64>(current), ...result])

// Convert a list of codepoints to a string
def Stdlib.String.__codepointsToString(cps: List<Int64>) : String =
    Stdlib.String.fromCodepoints(cps)

// Convert string to list of grapheme clusters (each as a string)
def Stdlib.String.toGraphemes(s: String) : List<String> =
    let cps = Stdlib.String.toCodepoints(s) in
    let segments = Stdlib.String.__segmentGraphemes(cps, [], []) in
    Stdlib.List.map<List<Int64>, String>(segments, Stdlib.String.__codepointsToString)

// Get number of grapheme clusters in a string
def Stdlib.String.graphemeLength(s: String) : Int64 =
    Stdlib.List.length<String>(Stdlib.String.toGraphemes(s))

// =============================================================================
// High-Level String API
// =============================================================================

// Repeat a string n times
def Stdlib.String.repeat(s: String, n: Int64) : String =
    if n <= 0 then ""
    else if n == 1 then s
    else s ++ Stdlib.String.repeat(s, n - 1)

// Join a list of strings with a separator
def Stdlib.String.join(strs: List<String>, sep: String) : String =
    match strs with
    | [] -> ""
    | [only] -> only
    | [first, ...rest] -> first ++ sep ++ Stdlib.String.join(rest, sep)

// Check if byte is ASCII whitespace (space, tab, newline, carriage return)
def Stdlib.String.__isWhitespace(b: Int64) : Bool =
    b == 32 || b == 9 || b == 10 || b == 13

// Trim leading whitespace
def Stdlib.String.trimStart(s: String) : String =
    let len = Stdlib.String.length(s) in
    Stdlib.String.__trimStartHelper(s, 0, len)

def Stdlib.String.__trimStartHelper(s: String, i: Int64, len: Int64) : String =
    if i >= len then ""
    else if Stdlib.String.__isWhitespace(Stdlib.String.getByteAt(s, i)) then
        Stdlib.String.__trimStartHelper(s, i + 1, len)
    else
        Stdlib.String.drop(s, i)

// Trim trailing whitespace
def Stdlib.String.trimEnd(s: String) : String =
    let len = Stdlib.String.length(s) in
    Stdlib.String.__trimEndHelper(s, len - 1)

def Stdlib.String.__trimEndHelper(s: String, i: Int64) : String =
    if i < 0 then ""
    else if Stdlib.String.__isWhitespace(Stdlib.String.getByteAt(s, i)) then
        Stdlib.String.__trimEndHelper(s, i - 1)
    else
        Stdlib.String.take(s, i + 1)

// Trim both leading and trailing whitespace
def Stdlib.String.trim(s: String) : String =
    Stdlib.String.trimEnd(Stdlib.String.trimStart(s))

// Split string by delimiter (simple byte-based)
def Stdlib.String.split(s: String, delim: String) : List<String> =
    Stdlib.String.__splitHelper(s, delim, 0, [])

def Stdlib.String.__splitHelper(s: String, delim: String, start: Int64, acc: List<String>) : List<String> =
    let sLen = Stdlib.String.length(s) in
    let delimLen = Stdlib.String.length(delim) in
    if start > sLen then
        Stdlib.List.reverse<String>(acc)
    else
        let idx = Stdlib.String.__findFrom(s, delim, start) in
        if idx < 0 then
            // No more delimiters - add rest of string
            Stdlib.List.reverse<String>([Stdlib.String.drop(s, start), ...acc])
        else
            // Found delimiter - add segment and continue
            let segment = Stdlib.String.substring(s, start, idx) in
            Stdlib.String.__splitHelper(s, delim, idx + delimLen, [segment, ...acc])

// Replace all occurrences of old with new
def Stdlib.String.replace(s: String, old: String, new: String) : String =
    Stdlib.String.join(Stdlib.String.split(s, old), new)

// Reverse a string (byte-based, works for ASCII)
def Stdlib.String.reverse(s: String) : String =
    let cps = Stdlib.String.toCodepoints(s) in
    Stdlib.String.fromCodepoints(Stdlib.List.reverse<Int64>(cps))

// Check if string equals another (byte comparison)
def Stdlib.String.equals(s1: String, s2: String) : Bool =
    let len1 = Stdlib.String.length(s1) in
    let len2 = Stdlib.String.length(s2) in
    if len1 != len2 then false
    else Stdlib.String.__compareBytes(s1, 0, s2, 0, len1)

// Check if byte is an ASCII digit (0-9)
def Stdlib.String.__isDigit(b: Int64) : Bool =
    b >= 48 && b <= 57

// Convert digit byte to its numeric value
def Stdlib.String.__digitValue(b: Int64) : Int64 =
    b - 48

// TODO: parseInt and parseFloat are disabled due to compiler bugs:
// 1. Tail calls with String parameters cause segfaults
// 2. String parameters passed to stdlib functions lose their value
// Will be re-enabled when these compiler bugs are fixed

// =============================================================================
// Stdlib.Dict - Immutable Dictionary using HAMT (Hash Array Mapped Trie)
// =============================================================================

// HAMT internal helper functions for working with bitmaps
// These are the building blocks for the Dict implementation

// Get 6-bit chunk of hash at given level (0-10)
// For a 64-bit hash, there are up to 11 levels (6 bits per level)
def Stdlib.Dict.hashChunk(hash: Int64, level: Int64) : Int64 =
    (hash >> (level * 6)) & 63

// Check if bit is set in bitmap
def Stdlib.Dict.hasBit(bitmap: Int64, bit: Int64) : Bool =
    ((bitmap >> bit) & 1) == 1

// Count bits below position in bitmap (for compressed array index)
def Stdlib.Dict.childIndex(bitmap: Int64, bit: Int64) : Int64 =
    Stdlib.Int64.popcount(bitmap & ((1 << bit) - 1))

// Set a bit in bitmap
def Stdlib.Dict.setBit(bitmap: Int64, bit: Int64) : Int64 =
    bitmap ^ (1 << bit)

// Clear a bit in bitmap (for remove)
// Note: ~x = (-1) ^ x (XOR with all ones)
def Stdlib.Dict.clearBit(bitmap: Int64, bit: Int64) : Int64 =
    bitmap & (((0 - 1)) ^ (1 << bit))

// =============================================================================
// Pointer tagging helpers
// =============================================================================
// We use the low 2 bits of pointers for tags (since 8-byte alignment gives us 3 free bits)
// Tag 0: Empty (NULL)
// Tag 1: Internal node (bitmap + children)
// Tag 2: Leaf node (key + value)
// Tag 3: Collision node (multiple entries with same hash prefix) - not yet implemented

// Get tag from a tagged pointer
def Stdlib.Dict.__getTag<k, v>(dict: Dict<k, v>) : Int64 =
    __dict_get_tag<k, v>(dict)

// Clear tag bits to get actual pointer (returns RawPtr)
def Stdlib.Dict.__clearTag<k, v>(dict: Dict<k, v>) : RawPtr =
    __dict_to_rawptr<k, v>(dict)

// Set tag on a pointer to create a Dict
def Stdlib.Dict.__setTag<k, v>(ptr: RawPtr, tag: Int64) : Dict<k, v> =
    __rawptr_to_dict<k, v>(ptr, tag)

// Allocate a leaf node: [key:8][value:8] = 16 bytes
def Stdlib.Dict.__allocLeaf<k, v>(key: k, value: v) : Dict<k, v> =
    let ptr = __raw_alloc(16) in
    let _ = __raw_set<k>(ptr, 0, key) in
    let _ = __raw_set<v>(ptr, 8, value) in
    Stdlib.Dict.__setTag<k, v>(ptr, 2)

// Allocate an internal node: [bitmap:8][children...] = 8 + 8*numChildren bytes
def Stdlib.Dict.__allocInternal(bitmap: Int64, numChildren: Int64) : RawPtr =
    let ptr = __raw_alloc(8 + (numChildren * 8)) in
    let _ = __raw_set<Int64>(ptr, 0, bitmap) in
    ptr

// =============================================================================
// Dict.empty - returns an empty dictionary
// =============================================================================
// Empty is represented as 0 (NULL with tag 0)
def Stdlib.Dict.empty<k, v>() : Dict<k, v> = __empty_dict<k, v>()

// =============================================================================
// Dict.get - lookup a key in the dictionary
// =============================================================================
// Returns Some(value) if found, None if not found

// Get helper - recursive lookup
// Note: keyHash is pre-computed hash of the key (for efficiency with string keys)
def Stdlib.Dict.__getHelper<k, v>(node: Dict<k, v>, key: k, keyHash: Int64, level: Int64) : Stdlib.Option.Option<v> =
    if __dict_is_null<k, v>(node) then
        None
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            // Leaf node
            let storedKey = __raw_get<k>(ptr, 0) in
            if __key_eq<k>(storedKey, key) then
                Some(__raw_get<v>(ptr, 8))
            else
                None
        else if tag == 1 then
            // Internal node
            let chunk = Stdlib.Dict.hashChunk(keyHash, level) in
            let bitmap = __raw_get<Int64>(ptr, 0) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
                let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
                Stdlib.Dict.__getHelper<k, v>(child, key, keyHash, level + 1)
            else
                None
        else
            // Unknown tag (collision node not yet implemented)
            None

def Stdlib.Dict.get<k, v>(dict: Dict<k, v>, key: k) : Stdlib.Option.Option<v> =
    Stdlib.Dict.__getHelper<k, v>(dict, key, __hash<k>(key), 0)

// =============================================================================
// Dict.set - insert or update a key-value pair
// =============================================================================
// Returns a new dictionary with the key-value pair added/updated

// Set helper - recursive insert
// Note: keyHash is pre-computed hash of the key (for efficiency with string keys)
def Stdlib.Dict.__setHelper<k, v>(node: Dict<k, v>, key: k, keyHash: Int64, value: v, level: Int64) : Dict<k, v> =
    if __dict_is_null<k, v>(node) then
        // Empty - create a new leaf
        Stdlib.Dict.__allocLeaf<k, v>(key, value)
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            // Leaf node - check if same key or need to expand
            let storedKey = __raw_get<k>(ptr, 0) in
            if __key_eq<k>(storedKey, key) then
                // Same key - replace value (create new leaf)
                Stdlib.Dict.__allocLeaf<k, v>(key, value)
            else
                // Different key - need to expand to internal node
                let storedValue = __raw_get<v>(ptr, 8) in
                let storedKeyHash = __hash<k>(storedKey) in
                Stdlib.Dict.__expandLeaf<k, v>(storedKey, storedKeyHash, storedValue, key, keyHash, value, level)
        else if tag == 1 then
            // Internal node - recurse into appropriate child
            let chunk = Stdlib.Dict.hashChunk(keyHash, level) in
            let bitmap = __raw_get<Int64>(ptr, 0) in
            let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                // Child exists - update it
                let oldChild = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
                let newChild = Stdlib.Dict.__setHelper<k, v>(oldChild, key, keyHash, value, level + 1) in
                Stdlib.Dict.__copyInternalWithUpdate<k, v>(ptr, bitmap, idx, newChild)
            else
                // No child at this position - insert new leaf
                let newLeaf = Stdlib.Dict.__allocLeaf<k, v>(key, value) in
                let newBitmap = Stdlib.Dict.setBit(bitmap, chunk) in
                Stdlib.Dict.__copyInternalWithInsert<k, v>(ptr, bitmap, newBitmap, idx, newLeaf)
        else
            // Unknown tag - return node unchanged
            node

// Expand a leaf to an internal node when two keys collide
def Stdlib.Dict.__expandLeaf<k, v>(key1: k, key1Hash: Int64, val1: v, key2: k, key2Hash: Int64, val2: v, level: Int64) : Dict<k, v> =
    let chunk1 = Stdlib.Dict.hashChunk(key1Hash, level) in
    let chunk2 = Stdlib.Dict.hashChunk(key2Hash, level) in
    if chunk1 == chunk2 then
        // Same chunk - need to go deeper
        if level >= 10 then
            // Max depth reached - just keep key2 (overwrites key1)
            // TODO: Implement collision nodes
            Stdlib.Dict.__allocLeaf<k, v>(key2, val2)
        else
            // Create internal node with single child (recursive case)
            let child = Stdlib.Dict.__expandLeaf<k, v>(key1, key1Hash, val1, key2, key2Hash, val2, level + 1) in
            let bitmap = Stdlib.Dict.setBit(0, chunk1) in
            let newNode = Stdlib.Dict.__allocInternal(bitmap, 1) in
            let _ = __raw_set<Dict<k, v>>(newNode, 8, child) in
            Stdlib.Dict.__setTag<k, v>(newNode, 1)
    else
        // Different chunks - create internal node with both leaves
        let leaf1 = Stdlib.Dict.__allocLeaf<k, v>(key1, val1) in
        let leaf2 = Stdlib.Dict.__allocLeaf<k, v>(key2, val2) in
        let bitmap = Stdlib.Dict.setBit(Stdlib.Dict.setBit(0, chunk1), chunk2) in
        let newNode = Stdlib.Dict.__allocInternal(bitmap, 2) in
        // Store children in order of their chunks
        if chunk1 < chunk2 then
            let _ = __raw_set<Dict<k, v>>(newNode, 8, leaf1) in
            let _ = __raw_set<Dict<k, v>>(newNode, 16, leaf2) in
            Stdlib.Dict.__setTag<k, v>(newNode, 1)
        else
            let _ = __raw_set<Dict<k, v>>(newNode, 8, leaf2) in
            let _ = __raw_set<Dict<k, v>>(newNode, 16, leaf1) in
            Stdlib.Dict.__setTag<k, v>(newNode, 1)

// Copy internal node with one child updated
def Stdlib.Dict.__copyInternalWithUpdate<k, v>(oldPtr: RawPtr, bitmap: Int64, updateIdx: Int64, newChild: Dict<k, v>) : Dict<k, v> =
    let numChildren = Stdlib.Int64.popcount(bitmap) in
    let newNode = Stdlib.Dict.__allocInternal(bitmap, numChildren) in
    // Copy all children, replacing the one at updateIdx
    Stdlib.Dict.__copyChildren<k, v>(oldPtr, newNode, numChildren, updateIdx, newChild, 0)

// Copy children from old node to new node, updating one
def Stdlib.Dict.__copyChildren<k, v>(oldPtr: RawPtr, newPtr: RawPtr, numChildren: Int64, updateIdx: Int64, newChild: Dict<k, v>, i: Int64) : Dict<k, v> =
    if i >= numChildren then
        Stdlib.Dict.__setTag<k, v>(newPtr, 1)
    else
        let offset = 8 + (i * 8) in
        if i == updateIdx then
            let _ = __raw_set<Dict<k, v>>(newPtr, offset, newChild) in
            Stdlib.Dict.__copyChildren<k, v>(oldPtr, newPtr, numChildren, updateIdx, newChild, i + 1)
        else
            let child = __raw_get<Dict<k, v>>(oldPtr, offset) in
            let _ = __raw_set<Dict<k, v>>(newPtr, offset, child) in
            Stdlib.Dict.__copyChildren<k, v>(oldPtr, newPtr, numChildren, updateIdx, newChild, i + 1)

// Copy internal node with a new child inserted at position
def Stdlib.Dict.__copyInternalWithInsert<k, v>(oldPtr: RawPtr, oldBitmap: Int64, newBitmap: Int64, insertIdx: Int64, newChild: Dict<k, v>) : Dict<k, v> =
    let oldNumChildren = Stdlib.Int64.popcount(oldBitmap) in
    let newNumChildren = oldNumChildren + 1 in
    let newNode = Stdlib.Dict.__allocInternal(newBitmap, newNumChildren) in
    // Copy children, inserting new one at insertIdx
    Stdlib.Dict.__copyChildrenWithInsert<k, v>(oldPtr, newNode, oldNumChildren, insertIdx, newChild, 0, 0)

// Copy children from old node to new node, inserting one
def Stdlib.Dict.__copyChildrenWithInsert<k, v>(oldPtr: RawPtr, newPtr: RawPtr, oldNumChildren: Int64, insertIdx: Int64, newChild: Dict<k, v>, oldI: Int64, newI: Int64) : Dict<k, v> =
    if newI == insertIdx then
        // Insert the new child here
        let offset = 8 + (newI * 8) in
        let _ = __raw_set<Dict<k, v>>(newPtr, offset, newChild) in
        Stdlib.Dict.__copyChildrenWithInsert<k, v>(oldPtr, newPtr, oldNumChildren, insertIdx, newChild, oldI, newI + 1)
    else if oldI >= oldNumChildren then
        Stdlib.Dict.__setTag<k, v>(newPtr, 1)
    else
        // Copy from old node
        let oldOffset = 8 + (oldI * 8) in
        let newOffset = 8 + (newI * 8) in
        let child = __raw_get<Dict<k, v>>(oldPtr, oldOffset) in
        let _ = __raw_set<Dict<k, v>>(newPtr, newOffset, child) in
        Stdlib.Dict.__copyChildrenWithInsert<k, v>(oldPtr, newPtr, oldNumChildren, insertIdx, newChild, oldI + 1, newI + 1)

def Stdlib.Dict.set<k, v>(dict: Dict<k, v>, key: k, value: v) : Dict<k, v> =
    Stdlib.Dict.__setHelper<k, v>(dict, key, __hash<k>(key), value, 0)

// =============================================================================
// Dict.remove - remove a key from the dictionary
// =============================================================================
// Returns a new dictionary without the key (or unchanged if key not present)

// Copy internal node excluding one child
def Stdlib.Dict.__copyChildrenExcluding<k, v>(oldPtr: RawPtr, newPtr: RawPtr, oldNumChildren: Int64, excludeIdx: Int64, oldI: Int64, newI: Int64) : Dict<k, v> =
    if oldI >= oldNumChildren then
        Stdlib.Dict.__setTag<k, v>(newPtr, 1)
    else if oldI == excludeIdx then
        // Skip this child
        Stdlib.Dict.__copyChildrenExcluding<k, v>(oldPtr, newPtr, oldNumChildren, excludeIdx, oldI + 1, newI)
    else
        // Copy this child
        let oldOffset = 8 + (oldI * 8) in
        let newOffset = 8 + (newI * 8) in
        let child = __raw_get<Dict<k, v>>(oldPtr, oldOffset) in
        let _ = __raw_set<Dict<k, v>>(newPtr, newOffset, child) in
        Stdlib.Dict.__copyChildrenExcluding<k, v>(oldPtr, newPtr, oldNumChildren, excludeIdx, oldI + 1, newI + 1)

// Copy internal node with one child removed
def Stdlib.Dict.__copyInternalWithRemove<k, v>(oldPtr: RawPtr, oldBitmap: Int64, newBitmap: Int64, removeIdx: Int64) : Dict<k, v> =
    let oldNumChildren = Stdlib.Int64.popcount(oldBitmap) in
    let newNumChildren = oldNumChildren - 1 in
    if newNumChildren == 0 then
        // No children left - return empty
        __empty_dict<k, v>()
    else
        let newNode = Stdlib.Dict.__allocInternal(newBitmap, newNumChildren) in
        Stdlib.Dict.__copyChildrenExcluding<k, v>(oldPtr, newNode, oldNumChildren, removeIdx, 0, 0)

// Remove helper - recursive removal
def Stdlib.Dict.__removeHelper<k, v>(node: Dict<k, v>, key: k, keyHash: Int64, level: Int64) : Dict<k, v> =
    if __dict_is_null<k, v>(node) then
        // Empty - key not found, return empty
        __empty_dict<k, v>()
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            // Leaf node
            let storedKey = __raw_get<k>(ptr, 0) in
            if __key_eq<k>(storedKey, key) then
                // Found the key - return empty to remove it
                __empty_dict<k, v>()
            else
                // Different key - not found, return unchanged
                node
        else if tag == 1 then
            // Internal node
            let chunk = Stdlib.Dict.hashChunk(keyHash, level) in
            let bitmap = __raw_get<Int64>(ptr, 0) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
                let oldChild = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
                let newChild = Stdlib.Dict.__removeHelper<k, v>(oldChild, key, keyHash, level + 1) in
                if __dict_is_null<k, v>(newChild) then
                    // Child was removed - need to update this node
                    let numChildren = Stdlib.Int64.popcount(bitmap) in
                    if numChildren == 1 then
                        // This was the only child - return empty
                        __empty_dict<k, v>()
                    else if numChildren == 2 then
                        // Two children, one being removed - check if we can collapse
                        // Get the other child index (0 if we're removing 1, 1 if removing 0)
                        let otherIdx = 1 - idx in
                        let otherChild = __raw_get<Dict<k, v>>(ptr, 8 + (otherIdx * 8)) in
                        let otherTag = Stdlib.Dict.__getTag<k, v>(otherChild) in
                        if otherTag == 2 then
                            // Other child is a leaf - collapse to it
                            otherChild
                        else
                            // Other child is internal - can't collapse, create new node
                            let newBitmap = Stdlib.Dict.clearBit(bitmap, chunk) in
                            Stdlib.Dict.__copyInternalWithRemove<k, v>(ptr, bitmap, newBitmap, idx)
                    else
                        // More than 2 children - create new node without removed child
                        let newBitmap = Stdlib.Dict.clearBit(bitmap, chunk) in
                        Stdlib.Dict.__copyInternalWithRemove<k, v>(ptr, bitmap, newBitmap, idx)
                else
                    // Child was modified (but not removed) - update
                    Stdlib.Dict.__copyInternalWithUpdate<k, v>(ptr, bitmap, idx, newChild)
            else
                // Bit not set - key not in this subtree
                node
        else
            // Unknown tag - return unchanged
            node

def Stdlib.Dict.remove<k, v>(dict: Dict<k, v>, key: k) : Dict<k, v> =
    Stdlib.Dict.__removeHelper<k, v>(dict, key, __hash<k>(key), 0)


// =============================================================================
// Dict Utility Functions (Generic)
// =============================================================================

// Check if dict is empty
def Stdlib.Dict.isEmpty<k, v>(dict: Dict<k, v>) : Bool =
    __dict_is_null<k, v>(dict)

// Check if dict contains a key
def Stdlib.Dict.contains<k, v>(dict: Dict<k, v>, key: k) : Bool =
    Stdlib.Dict.__containsHelper<k, v>(dict, key, __hash<k>(key), 0)

def Stdlib.Dict.__containsHelper<k, v>(node: Dict<k, v>, key: k, keyHash: Int64, level: Int64) : Bool =
    if __dict_is_null<k, v>(node) then
        false
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            // Leaf node
            let storedKey = __raw_get<k>(ptr, 0) in
            __key_eq<k>(storedKey, key)
        else if tag == 1 then
            // Internal node
            let chunk = Stdlib.Dict.hashChunk(keyHash, level) in
            let bitmap = __raw_get<Int64>(ptr, 0) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
                let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
                Stdlib.Dict.__containsHelper<k, v>(child, key, keyHash, level + 1)
            else
                false
        else
            false

// Count entries in dict
def Stdlib.Dict.size<k, v>(dict: Dict<k, v>) : Int64 =
    Stdlib.Dict.__sizeHelper<k, v>(dict)

def Stdlib.Dict.__sizeHelper<k, v>(node: Dict<k, v>) : Int64 =
    if __dict_is_null<k, v>(node) then
        0
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            1
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__countChildren<k, v>(ptr, bitmap, 0)
        else
            0

def Stdlib.Dict.__countChildren<k, v>(ptr: RawPtr, bitmap: Int64, bit: Int64) : Int64 =
    if bit >= 64 then
        0
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        Stdlib.Dict.__sizeHelper<k, v>(child) + Stdlib.Dict.__countChildren<k, v>(ptr, bitmap, bit + 1)
    else
        Stdlib.Dict.__countChildren<k, v>(ptr, bitmap, bit + 1)

// =============================================================================
// Dict Enumeration (Generic)
// =============================================================================

// Get all keys from dict
def Stdlib.Dict.keys<k, v>(dict: Dict<k, v>) : List<k> =
    Stdlib.Dict.__keysHelper<k, v>(dict, [])

def Stdlib.Dict.__keysHelper<k, v>(node: Dict<k, v>, acc: List<k>) : List<k> =
    if __dict_is_null<k, v>(node) then
        acc
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            [key, ...acc]
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__collectKeysFromChildren<k, v>(ptr, bitmap, 0, acc)
        else
            acc

def Stdlib.Dict.__collectKeysFromChildren<k, v>(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: List<k>) : List<k> =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__keysHelper<k, v>(child, acc) in
        Stdlib.Dict.__collectKeysFromChildren<k, v>(ptr, bitmap, bit + 1, newAcc)
    else
        Stdlib.Dict.__collectKeysFromChildren<k, v>(ptr, bitmap, bit + 1, acc)

// Get all values from dict
def Stdlib.Dict.values<k, v>(dict: Dict<k, v>) : List<v> =
    Stdlib.Dict.__valuesHelper<k, v>(dict, [])

def Stdlib.Dict.__valuesHelper<k, v>(node: Dict<k, v>, acc: List<v>) : List<v> =
    if __dict_is_null<k, v>(node) then
        acc
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let value = __raw_get<v>(ptr, 8) in
            [value, ...acc]
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__collectValuesFromChildren<k, v>(ptr, bitmap, 0, acc)
        else
            acc

def Stdlib.Dict.__collectValuesFromChildren<k, v>(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: List<v>) : List<v> =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__valuesHelper<k, v>(child, acc) in
        Stdlib.Dict.__collectValuesFromChildren<k, v>(ptr, bitmap, bit + 1, newAcc)
    else
        Stdlib.Dict.__collectValuesFromChildren<k, v>(ptr, bitmap, bit + 1, acc)

// Get all entries from dict as key-value tuples
def Stdlib.Dict.entries<k, v>(dict: Dict<k, v>) : List<(k, v)> =
    Stdlib.Dict.__entriesHelper<k, v>(dict, [])

def Stdlib.Dict.__entriesHelper<k, v>(node: Dict<k, v>, acc: List<(k, v)>) : List<(k, v)> =
    if __dict_is_null<k, v>(node) then
        acc
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            let value = __raw_get<v>(ptr, 8) in
            [(key, value), ...acc]
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__collectEntriesFromChildren<k, v>(ptr, bitmap, 0, acc)
        else
            acc

def Stdlib.Dict.__collectEntriesFromChildren<k, v>(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: List<(k, v)>) : List<(k, v)> =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__entriesHelper<k, v>(child, acc) in
        Stdlib.Dict.__collectEntriesFromChildren<k, v>(ptr, bitmap, bit + 1, newAcc)
    else
        Stdlib.Dict.__collectEntriesFromChildren<k, v>(ptr, bitmap, bit + 1, acc)

// Fold over all entries in the dictionary
def Stdlib.Dict.fold<k, v, a>(dict: Dict<k, v>, init: a, f: (a, k, v) -> a) : a =
    Stdlib.Dict.__foldHelper<k, v, a>(dict, init, f)

def Stdlib.Dict.__foldHelper<k, v, a>(node: Dict<k, v>, acc: a, f: (a, k, v) -> a) : a =
    if __dict_is_null<k, v>(node) then
        acc
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            let value = __raw_get<v>(ptr, 8) in
            f(acc, key, value)
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__foldChildren<k, v, a>(ptr, bitmap, 0, acc, f)
        else
            acc

def Stdlib.Dict.__foldChildren<k, v, a>(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: a, f: (a, k, v) -> a) : a =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__foldHelper<k, v, a>(child, acc, f) in
        Stdlib.Dict.__foldChildren<k, v, a>(ptr, bitmap, bit + 1, newAcc, f)
    else
        Stdlib.Dict.__foldChildren<k, v, a>(ptr, bitmap, bit + 1, acc, f)

// Map over all values in the dictionary
def Stdlib.Dict.map<k, v, w>(dict: Dict<k, v>, f: (k, v) -> w) : Dict<k, w> =
    Stdlib.Dict.__mapHelper<k, v, w>(dict, f)

def Stdlib.Dict.__mapHelper<k, v, w>(node: Dict<k, v>, f: (k, v) -> w) : Dict<k, w> =
    if __dict_is_null<k, v>(node) then
        __empty_dict<k, w>()
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            let value = __raw_get<v>(ptr, 8) in
            let newValue = f(key, value) in
            Stdlib.Dict.__allocLeaf<k, w>(key, newValue)
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            let numChildren = Stdlib.Int64.popcount(bitmap) in
            let newPtr = Stdlib.Dict.__allocInternal(bitmap, numChildren) in
            Stdlib.Dict.__mapChildren<k, v, w>(ptr, newPtr, bitmap, 0, numChildren, f)
        else
            __empty_dict<k, w>()

def Stdlib.Dict.__mapChildren<k, v, w>(oldPtr: RawPtr, newPtr: RawPtr, bitmap: Int64, idx: Int64, numChildren: Int64, f: (k, v) -> w) : Dict<k, w> =
    if idx >= numChildren then
        Stdlib.Dict.__setTag<k, w>(newPtr, 1)
    else
        let child = __raw_get<Dict<k, v>>(oldPtr, 8 + (idx * 8)) in
        let mappedChild = Stdlib.Dict.__mapHelper<k, v, w>(child, f) in
        let _ = __raw_set<Dict<k, w>>(newPtr, 8 + (idx * 8), mappedChild) in
        Stdlib.Dict.__mapChildren<k, v, w>(oldPtr, newPtr, bitmap, idx + 1, numChildren, f)

// Filter entries in the dictionary
def Stdlib.Dict.filter<k, v>(dict: Dict<k, v>, f: (k, v) -> Bool) : Dict<k, v> =
    Stdlib.Dict.__filterHelper<k, v>(dict, Stdlib.Dict.empty<k, v>(), f)

def Stdlib.Dict.__filterHelper<k, v>(node: Dict<k, v>, acc: Dict<k, v>, f: (k, v) -> Bool) : Dict<k, v> =
    if __dict_is_null<k, v>(node) then
        acc
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            let value = __raw_get<v>(ptr, 8) in
            if f(key, value) then Stdlib.Dict.set<k, v>(acc, key, value) else acc
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__filterChildren<k, v>(ptr, bitmap, 0, acc, f)
        else
            acc

def Stdlib.Dict.__filterChildren<k, v>(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: Dict<k, v>, f: (k, v) -> Bool) : Dict<k, v> =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__filterHelper<k, v>(child, acc, f) in
        Stdlib.Dict.__filterChildren<k, v>(ptr, bitmap, bit + 1, newAcc, f)
    else
        Stdlib.Dict.__filterChildren<k, v>(ptr, bitmap, bit + 1, acc, f)

// =============================================================================
// Dict.merge - Combine two dictionaries
// =============================================================================
// Second dictionary's values win on key conflicts

def Stdlib.Dict.merge<k, v>(dict1: Dict<k, v>, dict2: Dict<k, v>) : Dict<k, v> =
    Stdlib.Dict.__mergeHelper<k, v>(dict2, dict1)

def Stdlib.Dict.__mergeHelper<k, v>(source: Dict<k, v>, target: Dict<k, v>) : Dict<k, v> =
    if __dict_is_null<k, v>(source) then
        target
    else
        let tag = Stdlib.Dict.__getTag<k, v>(source) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(source) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            let value = __raw_get<v>(ptr, 8) in
            Stdlib.Dict.set<k, v>(target, key, value)
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__mergeChildren<k, v>(ptr, bitmap, 0, target)
        else
            target

def Stdlib.Dict.__mergeChildren<k, v>(ptr: RawPtr, bitmap: Int64, bit: Int64, target: Dict<k, v>) : Dict<k, v> =
    if bit >= 64 then
        target
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newTarget = Stdlib.Dict.__mergeHelper<k, v>(child, target) in
        Stdlib.Dict.__mergeChildren<k, v>(ptr, bitmap, bit + 1, newTarget)
    else
        Stdlib.Dict.__mergeChildren<k, v>(ptr, bitmap, bit + 1, target)

// =============================================================================
// Dict.fromList - Construct dictionary from list of pairs
// =============================================================================

def Stdlib.Dict.fromList<k, v>(pairs: List<(k, v)>) : Dict<k, v> =
    Stdlib.Dict.__fromListHelper<k, v>(pairs, Stdlib.Dict.empty<k, v>())

def Stdlib.Dict.__fromListHelper<k, v>(pairs: List<(k, v)>, acc: Dict<k, v>) : Dict<k, v> =
    match pairs with
    | [] -> acc
    | [pair, ...rest] ->
        let key = Stdlib.Tuple2.first<k, v>(pair) in
        let value = Stdlib.Tuple2.second<k, v>(pair) in
        Stdlib.Dict.__fromListHelper<k, v>(rest, Stdlib.Dict.set<k, v>(acc, key, value))

// =============================================================================
// Dict.getOrDefault - Get value with fallback
// =============================================================================

def Stdlib.Dict.getOrDefault<k, v>(dict: Dict<k, v>, key: k, default: v) : v =
    Stdlib.Option.withDefault<v>(Stdlib.Dict.get<k, v>(dict, key), default)

// ============================================================================
// Stdlib.Uuid - UUID v4 generation
// ============================================================================

// Helper: convert nibble (0-15) to hex char
def Stdlib.Uuid.__nibbleToHex(n: Int64) : String =
    match n with
    | 0 -> "0" | 1 -> "1" | 2 -> "2" | 3 -> "3"
    | 4 -> "4" | 5 -> "5" | 6 -> "6" | 7 -> "7"
    | 8 -> "8" | 9 -> "9" | 10 -> "a" | 11 -> "b"
    | 12 -> "c" | 13 -> "d" | 14 -> "e" | 15 -> "f"
    | _ -> "?"

// Helper: convert byte (from int64 at shift position) to 2 hex chars
def Stdlib.Uuid.__byteToHex(value: Int64, shift: Int64) : String =
    let byte = (value >> shift) & 255 in
    let hi = (byte >> 4) & 15 in
    let lo = byte & 15 in
    Stdlib.Uuid.__nibbleToHex(hi) ++ Stdlib.Uuid.__nibbleToHex(lo)

// Generate UUID v4: xxxxxxxx-xxxx-4xxx-Nxxx-xxxxxxxxxxxx
// where N is 8, 9, a, or b (variant bits)
def Stdlib.Uuid.generate() : String =
    let high = Stdlib.Random.int64() in
    let low = Stdlib.Random.int64() in
    // Set version (4) in byte 6: clear upper nibble, set to 4
    // Using XOR since we cleared the bits first with AND
    // Mask -61441 = 0xFFFFFFFFFFFF0FFF (clears bits 12-15)
    // Version 16384 = 0x4000 (sets bit 14 for version 4)
    let highWithVersion = (high & (-61441)) ^ 16384 in
    // Set variant (10xx) in byte 8: clear upper 2 bits, set to 10
    // Mask 4611686018427387903 = 0x3FFFFFFFFFFFFFFF (clears top 2 bits)
    // Variant -9223372036854775808 = 0x8000000000000000 (sets top bit)
    let lowWithVariant = (low & 4611686018427387903) ^ (-9223372036854775808) in
    // Format: 8-4-4-4-12 hex chars
    // bytes 0-3 (bits 32-63 of high)
    Stdlib.Uuid.__byteToHex(highWithVersion, 56) ++
    Stdlib.Uuid.__byteToHex(highWithVersion, 48) ++
    Stdlib.Uuid.__byteToHex(highWithVersion, 40) ++
    Stdlib.Uuid.__byteToHex(highWithVersion, 32) ++ "-" ++
    // bytes 4-5 (bits 16-31 of high)
    Stdlib.Uuid.__byteToHex(highWithVersion, 24) ++
    Stdlib.Uuid.__byteToHex(highWithVersion, 16) ++ "-" ++
    // bytes 6-7 (bits 0-15 of high) - contains version
    Stdlib.Uuid.__byteToHex(highWithVersion, 8) ++
    Stdlib.Uuid.__byteToHex(highWithVersion, 0) ++ "-" ++
    // bytes 8-9 (bits 48-63 of low) - contains variant
    Stdlib.Uuid.__byteToHex(lowWithVariant, 56) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 48) ++ "-" ++
    // bytes 10-15 (bits 0-47 of low)
    Stdlib.Uuid.__byteToHex(lowWithVariant, 40) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 32) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 24) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 16) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 8) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 0)

// =============================================================================
// Stdlib.Bytes - Byte array operations
// =============================================================================
// Memory layout: [length:8 bytes][data:N bytes][refcount:8 bytes]
// Same layout as String for consistency

// Get the length of a byte array
def Stdlib.Bytes.length(b: Bytes) : Int64 =
    __raw_get<Int64>(__int64_to_rawptr(__bytes_to_int64(b)), 0)

// Get the byte at a given index (0-based)
// Returns the byte as an Int64 (0-255)
def Stdlib.Bytes.get(b: Bytes, index: Int64) : Int64 =
    __raw_get_byte(__int64_to_rawptr(__bytes_to_int64(b)), index + 8)

// Create a new byte array with a byte set at the given index
// Returns a new Bytes (immutable update)
def Stdlib.Bytes.set(b: Bytes, index: Int64, value: Int64) : Bytes =
    let len = Stdlib.Bytes.length(b) in
    if index < 0 || index >= len then
        b  // Out of bounds, return unchanged
    else
        // Allocate: 8 (length) + len (data) + 8 (refcount)
        let totalSize = 16 + len in
        let ptr = __raw_alloc(totalSize) in
        // Write length at offset 0
        let _ = __raw_set<Int64>(ptr, 0, len) in
        // Copy bytes - use srcPtr approach
        let srcPtr = __int64_to_rawptr(__bytes_to_int64(b)) in
        let _ = Stdlib.Bytes.__copyLoop(srcPtr, ptr, 8, len) in
        // Update the byte at index
        let _ = __raw_set_byte(ptr, 8 + index, value) in
        // Write refcount = 1 at end
        let _ = __raw_set<Int64>(ptr, 8 + len, 1) in
        __int64_to_bytes(__rawptr_to_int64(ptr))

// Internal: Copy loop with 2 pointers sharing same offset
def Stdlib.Bytes.__copyLoop(src: RawPtr, dest: RawPtr, offset: Int64, remaining: Int64) : Unit =
    if remaining <= 0 then
        ()
    else
        let byte = __raw_get_byte(src, offset) in
        let _ = __raw_set_byte(dest, offset, byte) in
        Stdlib.Bytes.__copyLoop(src, dest, offset + 1, remaining - 1)

// Create a byte array of given size
// Note: Memory is typically zeroed by the OS, but not guaranteed
def Stdlib.Bytes.create(size: Int64) : Bytes =
    if size <= 0 then
        // Create empty bytes
        let ptr = __raw_alloc(16) in
        let _ = __raw_set<Int64>(ptr, 0, 0) in  // length = 0
        let _ = __raw_set<Int64>(ptr, 8, 1) in  // refcount = 1
        __int64_to_bytes(__rawptr_to_int64(ptr))
    else
        // Allocate: 8 (length) + size (data) + 8 (refcount)
        let totalSize = 16 + size in
        let ptr = __raw_alloc(totalSize) in
        // Write length at offset 0
        let _ = __raw_set<Int64>(ptr, 0, size) in
        // Write refcount = 1 at end
        let _ = __raw_set<Int64>(ptr, 8 + size, 1) in
        __int64_to_bytes(__rawptr_to_int64(ptr))

// Create bytes from a list of Int64 values (each 0-255)
def Stdlib.Bytes.fromList(list: List<Int64>) : Bytes =
    let len = Stdlib.List.length<Int64>(list) in
    if len == 0 then
        Stdlib.Bytes.create(0)
    else
        let totalSize = 16 + len in
        let ptr = __raw_alloc(totalSize) in
        let _ = __raw_set<Int64>(ptr, 0, len) in
        // Use a helper with fewer args
        let _ = Stdlib.Bytes.__writeListHelper(ptr, list, 8) in
        let _ = __raw_set<Int64>(ptr, 8 + len, 1) in
        __int64_to_bytes(__rawptr_to_int64(ptr))

// Helper: write list of bytes starting at offset
def Stdlib.Bytes.__writeListHelper(ptr: RawPtr, list: List<Int64>, offset: Int64) : Int64 =
    match list with
    | [] -> offset
    | [b, ...rest] ->
        let _ = __raw_set_byte(ptr, offset, b) in
        Stdlib.Bytes.__writeListHelper(ptr, rest, offset + 1)

// Convert bytes to a list of Int64 values (each 0-255)
// Build list by iterating through bytes
def Stdlib.Bytes.toList(b: Bytes) : List<Int64> =
    let len = Stdlib.Bytes.length(b) in
    if len == 0 then
        []
    else
        // Build list in reverse then reverse at end
        Stdlib.Bytes.__toListHelper(b, len - 1, [])

def Stdlib.Bytes.__toListHelper(b: Bytes, index: Int64, acc: List<Int64>) : List<Int64> =
    if index < 0 then
        acc
    else
        let byte = Stdlib.Bytes.get(b, index) in
        Stdlib.Bytes.__toListHelper(b, index - 1, [byte, ...acc])
