// Stdlib.dark - Standard Library Functions
//
// These functions are automatically included in all Dark programs.
// They provide the built-in Stdlib modules.

// Stdlib.Int64 - Integer operations

def Stdlib.Int64.add(a: Int64, b: Int64) : Int64 = a + b

def Stdlib.Int64.sub(a: Int64, b: Int64) : Int64 = a - b

def Stdlib.Int64.mul(a: Int64, b: Int64) : Int64 = a * b

def Stdlib.Int64.div(a: Int64, b: Int64) : Int64 = a / b

def Stdlib.Int64.max(a: Int64, b: Int64) : Int64 = if a > b then a else b

def Stdlib.Int64.min(a: Int64, b: Int64) : Int64 = if a < b then a else b

def Stdlib.Int64.mod(a: Int64, b: Int64) : Int64 = a % b

def Stdlib.Int64.absoluteValue(a: Int64) : Int64 = if a < 0 then 0 - a else a

def Stdlib.Int64.negate(a: Int64) : Int64 = 0 - a

def Stdlib.Int64.power(base: Int64, exponent: Int64) : Int64 =
    if exponent == 0 then 1
    else if exponent == 1 then base
    else base * Stdlib.Int64.power(base, exponent - 1)

def Stdlib.Int64.clamp(value: Int64, limitA: Int64, limitB: Int64) : Int64 =
    let lower = Stdlib.Int64.min(limitA, limitB) in
    let upper = Stdlib.Int64.max(limitA, limitB) in
    Stdlib.Int64.max(lower, Stdlib.Int64.min(upper, value))

def Stdlib.Int64.greaterThan(a: Int64, b: Int64) : Bool = a > b

def Stdlib.Int64.greaterThanOrEqualTo(a: Int64, b: Int64) : Bool = a >= b

def Stdlib.Int64.lessThan(a: Int64, b: Int64) : Bool = a < b

def Stdlib.Int64.lessThanOrEqualTo(a: Int64, b: Int64) : Bool = a <= b

// Bitwise operations
def Stdlib.Int64.bitwiseAnd(a: Int64, b: Int64) : Int64 = a & b

def Stdlib.Int64.bitwiseXor(a: Int64, b: Int64) : Int64 = a ^ b

def Stdlib.Int64.shiftLeft(a: Int64, shift: Int64) : Int64 = a << shift

def Stdlib.Int64.shiftRight(a: Int64, shift: Int64) : Int64 = a >> shift

// Count number of set bits (population count)
// Uses parallel bit counting algorithm (Brian Kernighan / SWAR)
def Stdlib.Int64.popcount(x: Int64) : Int64 =
    // Constants (in decimal):
    // 0x5555555555555555 = 6148914691236517205
    // 0x3333333333333333 = 3689348814741910323
    // 0x0F0F0F0F0F0F0F0F = 1085102592571150095
    // 0x0101010101010101 = 72340172838076673
    let mask1 = 6148914691236517205 in
    let mask2 = 3689348814741910323 in
    let mask3 = 1085102592571150095 in
    let mult = 72340172838076673 in
    let x = x - ((x >> 1) & mask1) in
    let x = (x & mask2) + ((x >> 2) & mask2) in
    let x = (x + (x >> 4)) & mask3 in
    (x * mult) >> 56

// Convert a single digit (0-9) to its string representation
def Stdlib.Int64.digitToString(n: Int64) : String =
    match n with
    | 0 -> "0"
    | 1 -> "1"
    | 2 -> "2"
    | 3 -> "3"
    | 4 -> "4"
    | 5 -> "5"
    | 6 -> "6"
    | 7 -> "7"
    | 8 -> "8"
    | 9 -> "9"
    | _ -> "?"

// Convert an integer to its string representation
def Stdlib.Int64.toString(n: Int64) : String =
    if n < 0 then "-" ++ Stdlib.Int64.toString(0 - n)
    else if n < 10 then Stdlib.Int64.digitToString(n)
    else Stdlib.Int64.toString(n / 10) ++ Stdlib.Int64.digitToString(n % 10)

// Stdlib.Bool - Boolean operations

def Stdlib.Bool.not(b: Bool) : Bool = !b

def Stdlib.Bool.and(a: Bool, b: Bool) : Bool = a && b

def Stdlib.Bool.or(a: Bool, b: Bool) : Bool = a || b

def Stdlib.Bool.xor(a: Bool, b: Bool) : Bool = if a then !b else b

def Stdlib.Bool.toString(b: Bool) : String = if b then "true" else "false"

// Stdlib.Tuple2 - 2-tuple operations

def Stdlib.Tuple2.create<a, b>(first: a, second: b) : (a, b) = (first, second)

def Stdlib.Tuple2.first<a, b>(t: (a, b)) : a = match t with | (x, y) -> x

def Stdlib.Tuple2.second<a, b>(t: (a, b)) : b = match t with | (x, y) -> y

def Stdlib.Tuple2.swap<a, b>(t: (a, b)) : (b, a) = match t with | (x, y) -> (y, x)

def Stdlib.Tuple2.mapFirst<a, b, c>(fn: (a) -> c, t: (a, b)) : (c, b) =
    match t with | (x, y) -> (fn(x), y)

def Stdlib.Tuple2.mapSecond<a, b, c>(fn: (b) -> c, t: (a, b)) : (a, c) =
    match t with | (x, y) -> (x, fn(y))

def Stdlib.Tuple2.mapBoth<a, b, c, d>(fnFirst: (a) -> c, fnSecond: (b) -> d, t: (a, b)) : (c, d) =
    match t with | (x, y) -> (fnFirst(x), fnSecond(y))

// Stdlib.Tuple3 - 3-tuple operations

def Stdlib.Tuple3.create<a, b, c>(first: a, second: b, third: c) : (a, b, c) = (first, second, third)

def Stdlib.Tuple3.first<a, b, c>(t: (a, b, c)) : a = match t with | (x, y, z) -> x

def Stdlib.Tuple3.second<a, b, c>(t: (a, b, c)) : b = match t with | (x, y, z) -> y

def Stdlib.Tuple3.third<a, b, c>(t: (a, b, c)) : c = match t with | (x, y, z) -> z

def Stdlib.Tuple3.mapFirst<a, b, c, d>(fn: (a) -> d, t: (a, b, c)) : (d, b, c) =
    match t with | (x, y, z) -> (fn(x), y, z)

def Stdlib.Tuple3.mapSecond<a, b, c, d>(fn: (b) -> d, t: (a, b, c)) : (a, d, c) =
    match t with | (x, y, z) -> (x, fn(y), z)

def Stdlib.Tuple3.mapThird<a, b, c, d>(fn: (c) -> d, t: (a, b, c)) : (a, b, d) =
    match t with | (x, y, z) -> (x, y, fn(z))

def Stdlib.Tuple3.mapAllThree<a, b, c, d, e, f>(fnFirst: (a) -> d, fnSecond: (b) -> e, fnThird: (c) -> f, t: (a, b, c)) : (d, e, f) =
    match t with | (x, y, z) -> (fnFirst(x), fnSecond(y), fnThird(z))

// Stdlib.Result - Result type for error handling
type Stdlib.Result.Result<t, e> = Ok of t | Error of e

// Check if result is Ok
def Stdlib.Result.isOk<t, e>(result: Stdlib.Result.Result<t, e>) : Bool =
    match result with
    | Ok(_) -> true
    | Error(_) -> false

// Check if result is Error
def Stdlib.Result.isError<t, e>(result: Stdlib.Result.Result<t, e>) : Bool =
    match result with
    | Ok(_) -> false
    | Error(_) -> true

// Get the Ok value or return a default
def Stdlib.Result.withDefault<t, e>(result: Stdlib.Result.Result<t, e>, default: t) : t =
    match result with
    | Ok(v) -> v
    | Error(_) -> default

// Transform the Ok value with a function
def Stdlib.Result.map<t, u, e>(result: Stdlib.Result.Result<t, e>, fn: (t) -> u) : Stdlib.Result.Result<u, e> =
    match result with
    | Ok(v) -> Ok(fn(v))
    | Error(err) -> Error(err)

// Transform the Error value with a function
// TODO: Blocked - constructor type inference doesn't use return type annotation
// The Error(fn(err)) gets type Result<t,e> from input, not Result<t,f> from return
// def Stdlib.Result.mapError<t, e, f>(fn: (e) -> f, result: Stdlib.Result.Result<t, e>) : Stdlib.Result.Result<t, f> =
//     match result with
//     | Ok(v) -> Ok(v)
//     | Error(err) -> Error(fn(err))

// Chain Result computations
def Stdlib.Result.andThen<t, u, e>(result: Stdlib.Result.Result<t, e>, fn: (t) -> Stdlib.Result.Result<u, e>) : Stdlib.Result.Result<u, e> =
    match result with
    | Ok(v) -> fn(v)
    | Error(err) -> Error(err)

// Stdlib.Option - Optional values
type Stdlib.Option.Option<t> = Some of t | None

// Check if option has a value
def Stdlib.Option.isSome<t>(opt: Stdlib.Option.Option<t>) : Bool =
    match opt with
    | Some(_) -> true
    | None -> false

// Check if option is empty
def Stdlib.Option.isNone<t>(opt: Stdlib.Option.Option<t>) : Bool =
    match opt with
    | Some(_) -> false
    | None -> true

// Get the value or return a default
def Stdlib.Option.withDefault<t>(opt: Stdlib.Option.Option<t>, default: t) : t =
    match opt with
    | Some(v) -> v
    | None -> default

// Transform the value with a function if present
def Stdlib.Option.map<t, u>(opt: Stdlib.Option.Option<t>, fn: (t) -> u) : Stdlib.Option.Option<u> =
    match opt with
    | Some(v) -> Some(fn(v))
    | None -> None

// Chain Option computations
def Stdlib.Option.andThen<t, u>(opt: Stdlib.Option.Option<t>, fn: (t) -> Stdlib.Option.Option<u>) : Stdlib.Option.Option<u> =
    match opt with
    | Some(v) -> fn(v)
    | None -> None

// Convert Option to a single-element or empty list
def Stdlib.Option.toList<t>(opt: Stdlib.Option.Option<t>) : List<t> =
    match opt with
    | Some(v) -> [v]
    | None -> []

// Stdlib.List - List operations
// Lists are represented as: Nil = 0, Cons = [tag=1, head, tail]

// Check if list is empty
def Stdlib.List.isEmpty<t>(list: List<t>) : Bool =
    match list with
    | [] -> true
    | _ -> false

// Get the length of a list
def Stdlib.List.length<t>(list: List<t>) : Int64 =
    match list with
    | [] -> 0
    | [h, ...rest] -> 1 + Stdlib.List.length<t>(rest)

// Create a single-element list
def Stdlib.List.singleton<t>(value: t) : List<t> = [value]

// Prepend an element to a list
def Stdlib.List.push<t>(list: List<t>, value: t) : List<t> = [value, ...list]

// Apply a function to each element of a list
def Stdlib.List.map<a, b>(list: List<a>, fn: (a) -> b) : List<b> =
    match list with
    | [] -> []
    | [h, ...t] -> [fn(h), ...Stdlib.List.map<a, b>(t, fn)]

// Keep only elements that satisfy a predicate
def Stdlib.List.filter<a>(list: List<a>, fn: (a) -> Bool) : List<a> =
    match list with
    | [] -> []
    | [h, ...t] ->
        if fn(h) then [h, ...Stdlib.List.filter<a>(t, fn)]
        else Stdlib.List.filter<a>(t, fn)

// Append an element to the end of a list
def Stdlib.List.pushBack<a>(list: List<a>, value: a) : List<a> =
    match list with
    | [] -> [value]
    | [h, ...t] -> [h, ...Stdlib.List.pushBack<a>(t, value)]

// Concatenate two lists
def Stdlib.List.append<a>(list1: List<a>, list2: List<a>) : List<a> =
    match list1 with
    | [] -> list2
    | [h, ...t] -> [h, ...Stdlib.List.append<a>(t, list2)]

// Reverse a list
def Stdlib.List.reverse<a>(list: List<a>) : List<a> =
    Stdlib.List.__reverseHelper<a>(list, [])

def Stdlib.List.__reverseHelper<a>(list: List<a>, acc: List<a>) : List<a> =
    match list with
    | [] -> acc
    | [h, ...t] -> Stdlib.List.__reverseHelper<a>(t, [h, ...acc])

// Fold left (reduce) over a list
def Stdlib.List.fold<a, b>(list: List<a>, init: b, fn: (b, a) -> b) : b =
    match list with
    | [] -> init
    | [h, ...t] -> Stdlib.List.fold<a, b>(t, fn(init, h), fn)

// Get head of list or return None
def Stdlib.List.head<a>(list: List<a>) : Stdlib.Option.Option<a> =
    match list with
    | [] -> None
    | [h, ...t] -> Some(h)

// Get tail of list or return None
// TODO: Blocked by parser - can't handle nested generics like Stdlib.Option.Option<List<a>>
// def Stdlib.List.tail<a>(list: List<a>) : Stdlib.Option.Option<List<a>> =
//     match list with
//     | [] -> None
//     | [h, ...t] -> Some(t)

// Get element at index (0-based)
def Stdlib.List.getAt<a>(list: List<a>, index: Int64) : Stdlib.Option.Option<a> =
    if index < 0 then None
    else match list with
    | [] -> None
    | [h, ...t] -> if index == 0 then Some(h) else Stdlib.List.getAt<a>(t, index - 1)

// Find first element satisfying a predicate
def Stdlib.List.findFirst<a>(list: List<a>, fn: (a) -> Bool) : Stdlib.Option.Option<a> =
    match list with
    | [] -> None
    | [h, ...t] -> if fn(h) then Some(h) else Stdlib.List.findFirst<a>(t, fn)

// Take first n elements
def Stdlib.List.take<a>(list: List<a>, n: Int64) : List<a> =
    if n <= 0 then []
    else match list with
    | [] -> []
    | [h, ...t] -> [h, ...Stdlib.List.take<a>(t, n - 1)]

// Drop first n elements
def Stdlib.List.drop<a>(list: List<a>, n: Int64) : List<a> =
    if n <= 0 then list
    else match list with
    | [] -> []
    | [h, ...t] -> Stdlib.List.drop<a>(t, n - 1)

// Stdlib.String - String operations

// Newline constant (nullary function)
def Stdlib.String.newline() : String = "\n"

// Append two strings
def Stdlib.String.append(s1: String, s2: String) : String = s1 ++ s2

// Prepend first string to second
def Stdlib.String.prepend(s2: String, s1: String) : String = s1 ++ s2

// TODO: Most String functions require runtime builtins that don't exist yet
// length, isEmpty, toUppercase, toLowercase, contains, startsWith, endsWith,
// trim, slice, first, last, reverse, replaceAll, etc.

// =============================================================================
// Stdlib.Dict - Immutable Dictionary using HAMT (Hash Array Mapped Trie)
// =============================================================================

// HAMT internal helper functions for working with bitmaps
// These are the building blocks for the Dict implementation

// Get 6-bit chunk of hash at given level (0-10)
// For a 64-bit hash, there are up to 11 levels (6 bits per level)
def Stdlib.Dict.hashChunk(hash: Int64, level: Int64) : Int64 =
    (hash >> (level * 6)) & 63

// Check if bit is set in bitmap
def Stdlib.Dict.hasBit(bitmap: Int64, bit: Int64) : Bool =
    ((bitmap >> bit) & 1) == 1

// Count bits below position in bitmap (for compressed array index)
def Stdlib.Dict.childIndex(bitmap: Int64, bit: Int64) : Int64 =
    Stdlib.Int64.popcount(bitmap & ((1 << bit) - 1))

// Set a bit in bitmap
def Stdlib.Dict.setBit(bitmap: Int64, bit: Int64) : Int64 =
    bitmap ^ (1 << bit)

// Clear a bit in bitmap (for remove)
// Note: ~x = (-1) ^ x (XOR with all ones)
def Stdlib.Dict.clearBit(bitmap: Int64, bit: Int64) : Int64 =
    bitmap & (((0 - 1)) ^ (1 << bit))

// =============================================================================
// Pointer tagging helpers
// =============================================================================
// We use the low 2 bits of pointers for tags (since 8-byte alignment gives us 3 free bits)
// Tag 0: Empty (NULL)
// Tag 1: Internal node (bitmap + children)
// Tag 2: Leaf node (key + value)
// Tag 3: Collision node (multiple entries with same hash prefix) - not yet implemented

// Get tag from a tagged pointer
def Stdlib.Dict.__getTag(ptr: Int64) : Int64 =
    ptr & 3

// Clear tag bits to get actual pointer
// Note: ~3 = -4 (all bits set except lowest 2)
def Stdlib.Dict.__clearTag(ptr: Int64) : Int64 =
    ptr & (0 - 4)

// Set tag on a pointer (assumes ptr has no existing tag)
def Stdlib.Dict.__setTag(ptr: Int64, tag: Int64) : Int64 =
    ptr ^ tag

// Allocate a leaf node: [key:8][value:8] = 16 bytes
def Stdlib.Dict.__allocLeaf(key: Int64, value: Int64) : Int64 =
    let ptr = __raw_alloc(16) in
    let _ = __raw_set(ptr, 0, key) in
    let _ = __raw_set(ptr, 8, value) in
    Stdlib.Dict.__setTag(__rawptr_to_int64(ptr), 2)

// Allocate an internal node: [bitmap:8][children...] = 8 + 8*numChildren bytes
def Stdlib.Dict.__allocInternal(bitmap: Int64, numChildren: Int64) : RawPtr =
    let ptr = __raw_alloc(8 + (numChildren * 8)) in
    let _ = __raw_set(ptr, 0, bitmap) in
    ptr

// =============================================================================
// Dict.empty - returns an empty dictionary
// =============================================================================
// Empty is represented as 0 (NULL with tag 0)
def Stdlib.Dict.empty() : Int64 = 0

// =============================================================================
// Dict.get - lookup a key in the dictionary
// =============================================================================
// Returns the value if found (as Int64), or -1 if not found
// TODO: Should return Option<V> once we have proper Option support

// Get helper - recursive lookup
def Stdlib.Dict.__getHelper(node: Int64, key: Int64, level: Int64) : Int64 =
    if node == 0 then
        // Empty - key not found
        0 - 1
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            // Leaf node
            let storedKey = __raw_get(ptr, 0) in
            if storedKey == key then
                __raw_get(ptr, 8)
            else
                0 - 1
        else if tag == 1 then
            // Internal node
            let chunk = Stdlib.Dict.hashChunk(key, level) in
            let bitmap = __raw_get(ptr, 0) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
                let child = __raw_get(ptr, 8 + (idx * 8)) in
                Stdlib.Dict.__getHelper(child, key, level + 1)
            else
                0 - 1
        else
            // Unknown tag (collision node not yet implemented)
            0 - 1

def Stdlib.Dict.get(dict: Int64, key: Int64) : Int64 =
    Stdlib.Dict.__getHelper(dict, key, 0)

// =============================================================================
// Dict.set - insert or update a key-value pair
// =============================================================================
// Returns a new dictionary with the key-value pair added/updated

// Set helper - recursive insert
def Stdlib.Dict.__setHelper(node: Int64, key: Int64, value: Int64, level: Int64) : Int64 =
    if node == 0 then
        // Empty - create a new leaf
        Stdlib.Dict.__allocLeaf(key, value)
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            // Leaf node - check if same key or need to expand
            let storedKey = __raw_get(ptr, 0) in
            if storedKey == key then
                // Same key - replace value (create new leaf)
                Stdlib.Dict.__allocLeaf(key, value)
            else
                // Different key - need to expand to internal node
                let storedValue = __raw_get(ptr, 8) in
                Stdlib.Dict.__expandLeaf(storedKey, storedValue, key, value, level)
        else if tag == 1 then
            // Internal node - recurse into appropriate child
            let chunk = Stdlib.Dict.hashChunk(key, level) in
            let bitmap = __raw_get(ptr, 0) in
            let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                // Child exists - update it
                let oldChild = __raw_get(ptr, 8 + (idx * 8)) in
                let newChild = Stdlib.Dict.__setHelper(oldChild, key, value, level + 1) in
                Stdlib.Dict.__copyInternalWithUpdate(ptr, bitmap, idx, newChild)
            else
                // No child at this position - insert new leaf
                let newLeaf = Stdlib.Dict.__allocLeaf(key, value) in
                let newBitmap = Stdlib.Dict.setBit(bitmap, chunk) in
                Stdlib.Dict.__copyInternalWithInsert(ptr, bitmap, newBitmap, idx, newLeaf)
        else
            // Unknown tag - return node unchanged
            node

// Expand a leaf to an internal node when two keys collide
def Stdlib.Dict.__expandLeaf(key1: Int64, val1: Int64, key2: Int64, val2: Int64, level: Int64) : Int64 =
    let chunk1 = Stdlib.Dict.hashChunk(key1, level) in
    let chunk2 = Stdlib.Dict.hashChunk(key2, level) in
    if chunk1 == chunk2 then
        // Same chunk - need to go deeper
        if level >= 10 then
            // Max depth reached - just keep key2 (overwrites key1)
            // TODO: Implement collision nodes
            Stdlib.Dict.__allocLeaf(key2, val2)
        else
            // Create internal node with single child (recursive case)
            let child = Stdlib.Dict.__expandLeaf(key1, val1, key2, val2, level + 1) in
            let bitmap = Stdlib.Dict.setBit(0, chunk1) in
            let newNode = Stdlib.Dict.__allocInternal(bitmap, 1) in
            let _ = __raw_set(newNode, 8, child) in
            Stdlib.Dict.__setTag(__rawptr_to_int64(newNode), 1)
    else
        // Different chunks - create internal node with both leaves
        let leaf1 = Stdlib.Dict.__allocLeaf(key1, val1) in
        let leaf2 = Stdlib.Dict.__allocLeaf(key2, val2) in
        let bitmap = Stdlib.Dict.setBit(Stdlib.Dict.setBit(0, chunk1), chunk2) in
        let newNode = Stdlib.Dict.__allocInternal(bitmap, 2) in
        // Store children in order of their chunks
        if chunk1 < chunk2 then
            let _ = __raw_set(newNode, 8, leaf1) in
            let _ = __raw_set(newNode, 16, leaf2) in
            Stdlib.Dict.__setTag(__rawptr_to_int64(newNode), 1)
        else
            let _ = __raw_set(newNode, 8, leaf2) in
            let _ = __raw_set(newNode, 16, leaf1) in
            Stdlib.Dict.__setTag(__rawptr_to_int64(newNode), 1)

// Copy internal node with one child updated
def Stdlib.Dict.__copyInternalWithUpdate(oldPtr: RawPtr, bitmap: Int64, updateIdx: Int64, newChild: Int64) : Int64 =
    let numChildren = Stdlib.Int64.popcount(bitmap) in
    let newNode = Stdlib.Dict.__allocInternal(bitmap, numChildren) in
    // Copy all children, replacing the one at updateIdx
    Stdlib.Dict.__copyChildren(oldPtr, newNode, numChildren, updateIdx, newChild, 0)

// Copy children from old node to new node, updating one
def Stdlib.Dict.__copyChildren(oldPtr: RawPtr, newPtr: RawPtr, numChildren: Int64, updateIdx: Int64, newChild: Int64, i: Int64) : Int64 =
    if i >= numChildren then
        Stdlib.Dict.__setTag(__rawptr_to_int64(newPtr), 1)
    else
        let offset = 8 + (i * 8) in
        if i == updateIdx then
            let _ = __raw_set(newPtr, offset, newChild) in
            Stdlib.Dict.__copyChildren(oldPtr, newPtr, numChildren, updateIdx, newChild, i + 1)
        else
            let child = __raw_get(oldPtr, offset) in
            let _ = __raw_set(newPtr, offset, child) in
            Stdlib.Dict.__copyChildren(oldPtr, newPtr, numChildren, updateIdx, newChild, i + 1)

// Copy internal node with a new child inserted at position
def Stdlib.Dict.__copyInternalWithInsert(oldPtr: RawPtr, oldBitmap: Int64, newBitmap: Int64, insertIdx: Int64, newChild: Int64) : Int64 =
    let oldNumChildren = Stdlib.Int64.popcount(oldBitmap) in
    let newNumChildren = oldNumChildren + 1 in
    let newNode = Stdlib.Dict.__allocInternal(newBitmap, newNumChildren) in
    // Copy children, inserting new one at insertIdx
    Stdlib.Dict.__copyChildrenWithInsert(oldPtr, newNode, oldNumChildren, insertIdx, newChild, 0, 0)

// Copy children from old node to new node, inserting one
def Stdlib.Dict.__copyChildrenWithInsert(oldPtr: RawPtr, newPtr: RawPtr, oldNumChildren: Int64, insertIdx: Int64, newChild: Int64, oldI: Int64, newI: Int64) : Int64 =
    if newI == insertIdx then
        // Insert the new child here
        let offset = 8 + (newI * 8) in
        let _ = __raw_set(newPtr, offset, newChild) in
        Stdlib.Dict.__copyChildrenWithInsert(oldPtr, newPtr, oldNumChildren, insertIdx, newChild, oldI, newI + 1)
    else if oldI >= oldNumChildren then
        Stdlib.Dict.__setTag(__rawptr_to_int64(newPtr), 1)
    else
        // Copy from old node
        let oldOffset = 8 + (oldI * 8) in
        let newOffset = 8 + (newI * 8) in
        let child = __raw_get(oldPtr, oldOffset) in
        let _ = __raw_set(newPtr, newOffset, child) in
        Stdlib.Dict.__copyChildrenWithInsert(oldPtr, newPtr, oldNumChildren, insertIdx, newChild, oldI + 1, newI + 1)

def Stdlib.Dict.set(dict: Int64, key: Int64, value: Int64) : Int64 =
    Stdlib.Dict.__setHelper(dict, key, value, 0)

// =============================================================================
// Dict.remove - remove a key from the dictionary
// =============================================================================
// Returns a new dictionary without the key (or unchanged if key not present)

// Copy internal node excluding one child
def Stdlib.Dict.__copyChildrenExcluding(oldPtr: RawPtr, newPtr: RawPtr, oldNumChildren: Int64, excludeIdx: Int64, oldI: Int64, newI: Int64) : Int64 =
    if oldI >= oldNumChildren then
        Stdlib.Dict.__setTag(__rawptr_to_int64(newPtr), 1)
    else if oldI == excludeIdx then
        // Skip this child
        Stdlib.Dict.__copyChildrenExcluding(oldPtr, newPtr, oldNumChildren, excludeIdx, oldI + 1, newI)
    else
        // Copy this child
        let oldOffset = 8 + (oldI * 8) in
        let newOffset = 8 + (newI * 8) in
        let child = __raw_get(oldPtr, oldOffset) in
        let _ = __raw_set(newPtr, newOffset, child) in
        Stdlib.Dict.__copyChildrenExcluding(oldPtr, newPtr, oldNumChildren, excludeIdx, oldI + 1, newI + 1)

// Copy internal node with one child removed
def Stdlib.Dict.__copyInternalWithRemove(oldPtr: RawPtr, oldBitmap: Int64, newBitmap: Int64, removeIdx: Int64) : Int64 =
    let oldNumChildren = Stdlib.Int64.popcount(oldBitmap) in
    let newNumChildren = oldNumChildren - 1 in
    if newNumChildren == 0 then
        // No children left - return empty
        0
    else
        let newNode = Stdlib.Dict.__allocInternal(newBitmap, newNumChildren) in
        Stdlib.Dict.__copyChildrenExcluding(oldPtr, newNode, oldNumChildren, removeIdx, 0, 0)

// Remove helper - recursive removal
def Stdlib.Dict.__removeHelper(node: Int64, key: Int64, level: Int64) : Int64 =
    if node == 0 then
        // Empty - key not found, return empty
        0
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            // Leaf node
            let storedKey = __raw_get(ptr, 0) in
            if storedKey == key then
                // Found the key - return empty to remove it
                0
            else
                // Different key - not found, return unchanged
                node
        else if tag == 1 then
            // Internal node
            let chunk = Stdlib.Dict.hashChunk(key, level) in
            let bitmap = __raw_get(ptr, 0) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
                let oldChild = __raw_get(ptr, 8 + (idx * 8)) in
                let newChild = Stdlib.Dict.__removeHelper(oldChild, key, level + 1) in
                if newChild == 0 then
                    // Child was removed - need to update this node
                    let numChildren = Stdlib.Int64.popcount(bitmap) in
                    if numChildren == 1 then
                        // This was the only child - return empty
                        0
                    else if numChildren == 2 then
                        // Two children, one being removed - check if we can collapse
                        // Get the other child index (0 if we're removing 1, 1 if removing 0)
                        let otherIdx = 1 - idx in
                        let otherChild = __raw_get(ptr, 8 + (otherIdx * 8)) in
                        let otherTag = Stdlib.Dict.__getTag(otherChild) in
                        if otherTag == 2 then
                            // Other child is a leaf - collapse to it
                            otherChild
                        else
                            // Other child is internal - can't collapse, create new node
                            let newBitmap = Stdlib.Dict.clearBit(bitmap, chunk) in
                            Stdlib.Dict.__copyInternalWithRemove(ptr, bitmap, newBitmap, idx)
                    else
                        // More than 2 children - create new node without removed child
                        let newBitmap = Stdlib.Dict.clearBit(bitmap, chunk) in
                        Stdlib.Dict.__copyInternalWithRemove(ptr, bitmap, newBitmap, idx)
                else if newChild == oldChild then
                    // Child unchanged - return unchanged
                    node
                else
                    // Child was modified (but not removed) - update
                    Stdlib.Dict.__copyInternalWithUpdate(ptr, bitmap, idx, newChild)
            else
                // Bit not set - key not in this subtree
                node
        else
            // Unknown tag - return unchanged
            node

def Stdlib.Dict.remove(dict: Int64, key: Int64) : Int64 =
    Stdlib.Dict.__removeHelper(dict, key, 0)

// =============================================================================
// String-keyed Dict functions
// =============================================================================
// These variants support String keys instead of Int64 keys.
// They manage reference counting for string keys stored in the Dict.

// Allocate a leaf node with string key: [keyPtr:8][value:8] = 16 bytes
// Increments refcount on the key since Dict now owns a reference to it
def Stdlib.Dict.__allocLeaf_str(key: String, value: Int64) : Int64 =
    let ptr = __raw_alloc(16) in
    let _ = __raw_set(ptr, 0, __string_to_int64(key)) in
    let _ = __raw_set(ptr, 8, value) in
    let _ = __refcount_inc_string(key) in
    Stdlib.Dict.__setTag(__rawptr_to_int64(ptr), 2)

// Get helper for string keys - recursive lookup
def Stdlib.Dict.__getHelper_str(node: Int64, key: String, keyHash: Int64, level: Int64) : Int64 =
    if node == 0 then
        // Empty - key not found
        0 - 1
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            // Leaf node
            let storedKeyPtr = __raw_get(ptr, 0) in
            let storedKey = __int64_to_string(storedKeyPtr) in
            if __string_eq(storedKey, key) then
                __raw_get(ptr, 8)
            else
                0 - 1
        else if tag == 1 then
            // Internal node
            let chunk = Stdlib.Dict.hashChunk(keyHash, level) in
            let bitmap = __raw_get(ptr, 0) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
                let child = __raw_get(ptr, 8 + (idx * 8)) in
                Stdlib.Dict.__getHelper_str(child, key, keyHash, level + 1)
            else
                0 - 1
        else
            // Unknown tag
            0 - 1

def Stdlib.Dict.get_str(dict: Int64, key: String) : Int64 =
    let keyHash = __string_hash(key) in
    Stdlib.Dict.__getHelper_str(dict, key, keyHash, 0)

// Expand a leaf to an internal node when two string keys collide
def Stdlib.Dict.__expandLeaf_str(key1: String, val1: Int64, key2: String, val2: Int64, level: Int64) : Int64 =
    let hash1 = __string_hash(key1) in
    let hash2 = __string_hash(key2) in
    let chunk1 = Stdlib.Dict.hashChunk(hash1, level) in
    let chunk2 = Stdlib.Dict.hashChunk(hash2, level) in
    if chunk1 == chunk2 then
        // Same chunk - need to go deeper
        if level >= 10 then
            // Max depth reached - just keep key2 (overwrites key1)
            // Decrement refcount on key1 since it's being removed
            let _ = __refcount_dec_string(key1) in
            Stdlib.Dict.__allocLeaf_str(key2, val2)
        else
            // Create internal node with single child (recursive case)
            let child = Stdlib.Dict.__expandLeaf_str(key1, val1, key2, val2, level + 1) in
            let bitmap = Stdlib.Dict.setBit(0, chunk1) in
            let newNode = Stdlib.Dict.__allocInternal(bitmap, 1) in
            let _ = __raw_set(newNode, 8, child) in
            Stdlib.Dict.__setTag(__rawptr_to_int64(newNode), 1)
    else
        // Different chunks - create internal node with both leaves
        let leaf1 = Stdlib.Dict.__allocLeaf_str(key1, val1) in
        let leaf2 = Stdlib.Dict.__allocLeaf_str(key2, val2) in
        let bitmap = Stdlib.Dict.setBit(Stdlib.Dict.setBit(0, chunk1), chunk2) in
        let newNode = Stdlib.Dict.__allocInternal(bitmap, 2) in
        // Store children in order of their chunks
        if chunk1 < chunk2 then
            let _ = __raw_set(newNode, 8, leaf1) in
            let _ = __raw_set(newNode, 16, leaf2) in
            Stdlib.Dict.__setTag(__rawptr_to_int64(newNode), 1)
        else
            let _ = __raw_set(newNode, 8, leaf2) in
            let _ = __raw_set(newNode, 16, leaf1) in
            Stdlib.Dict.__setTag(__rawptr_to_int64(newNode), 1)

// Set helper for string keys - recursive insert
def Stdlib.Dict.__setHelper_str(node: Int64, key: String, value: Int64, keyHash: Int64, level: Int64) : Int64 =
    if node == 0 then
        // Empty - create a new leaf
        Stdlib.Dict.__allocLeaf_str(key, value)
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            // Leaf node - check if same key or need to expand
            let storedKeyPtr = __raw_get(ptr, 0) in
            let storedKey = __int64_to_string(storedKeyPtr) in
            if __string_eq(storedKey, key) then
                // Same key - replace value (create new leaf)
                // Decrement old key's refcount (it's being replaced)
                let _ = __refcount_dec_string(storedKey) in
                Stdlib.Dict.__allocLeaf_str(key, value)
            else
                // Different key - need to expand to internal node
                let storedValue = __raw_get(ptr, 8) in
                Stdlib.Dict.__expandLeaf_str(storedKey, storedValue, key, value, level)
        else if tag == 1 then
            // Internal node - recurse into appropriate child
            let chunk = Stdlib.Dict.hashChunk(keyHash, level) in
            let bitmap = __raw_get(ptr, 0) in
            let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                // Child exists - update it
                let oldChild = __raw_get(ptr, 8 + (idx * 8)) in
                let newChild = Stdlib.Dict.__setHelper_str(oldChild, key, value, keyHash, level + 1) in
                Stdlib.Dict.__copyInternalWithUpdate(ptr, bitmap, idx, newChild)
            else
                // No child at this position - insert new leaf
                let newLeaf = Stdlib.Dict.__allocLeaf_str(key, value) in
                let newBitmap = Stdlib.Dict.setBit(bitmap, chunk) in
                Stdlib.Dict.__copyInternalWithInsert(ptr, bitmap, newBitmap, idx, newLeaf)
        else
            // Unknown tag - return node unchanged
            node

def Stdlib.Dict.set_str(dict: Int64, key: String, value: Int64) : Int64 =
    let keyHash = __string_hash(key) in
    Stdlib.Dict.__setHelper_str(dict, key, value, keyHash, 0)

// Remove helper for string keys
def Stdlib.Dict.__removeHelper_str(node: Int64, key: String, keyHash: Int64, level: Int64) : Int64 =
    if node == 0 then
        0
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            let storedKeyPtr = __raw_get(ptr, 0) in
            let storedKey = __int64_to_string(storedKeyPtr) in
            if __string_eq(storedKey, key) then
                let _ = __refcount_dec_string(storedKey) in
                0
            else
                node
        else if tag == 1 then
            // Internal node
            let chunk = Stdlib.Dict.hashChunk(keyHash, level) in
            let bitmap = __raw_get(ptr, 0) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
                let oldChild = __raw_get(ptr, 8 + (idx * 8)) in
                let newChild = Stdlib.Dict.__removeHelper_str(oldChild, key, keyHash, level + 1) in
                if newChild == 0 then
                    // Child was removed - need to update this node
                    let numChildren = Stdlib.Int64.popcount(bitmap) in
                    if numChildren == 1 then
                        // This was the only child - return empty
                        0
                    else if numChildren == 2 then
                        // Two children, one being removed - check if we can collapse
                        let otherIdx = 1 - idx in
                        let otherChild = __raw_get(ptr, 8 + (otherIdx * 8)) in
                        let otherTag = Stdlib.Dict.__getTag(otherChild) in
                        if otherTag == 2 then
                            // Other child is a leaf - collapse to it
                            otherChild
                        else
                            // Other child is internal - can't collapse
                            let newBitmap = Stdlib.Dict.clearBit(bitmap, chunk) in
                            Stdlib.Dict.__copyInternalWithRemove(ptr, bitmap, newBitmap, idx)
                    else
                        // More than 2 children - create new node without removed child
                        let newBitmap = Stdlib.Dict.clearBit(bitmap, chunk) in
                        Stdlib.Dict.__copyInternalWithRemove(ptr, bitmap, newBitmap, idx)
                else if newChild == oldChild then
                    // Child unchanged - return unchanged
                    node
                else
                    // Child was modified (but not removed) - update
                    Stdlib.Dict.__copyInternalWithUpdate(ptr, bitmap, idx, newChild)
            else
                // Bit not set - key not in this subtree
                node
        else
            // Unknown tag - return unchanged
            node

def Stdlib.Dict.remove_str(dict: Int64, key: String) : Int64 =
    let keyHash = __string_hash(key) in
    Stdlib.Dict.__removeHelper_str(dict, key, keyHash, 0)

// =============================================================================
// Dict cleanup for string keys
// =============================================================================
// When a Dict with string keys is freed, we need to traverse the entire HAMT
// and decrement refcounts on all stored string keys, then free the nodes.

// Cleanup a leaf node - decrement key refcount and free
def Stdlib.Dict.__cleanupLeaf_str(ptr: RawPtr) : Unit =
    let keyPtr = __raw_get(ptr, 0) in
    let key = __int64_to_string(keyPtr) in
    let _ = __refcount_dec_string(key) in
    __raw_free(ptr)

// Helper to clean a single child node inline
def Stdlib.Dict.__cleanupChild_str(child: Int64) : Unit =
    if child == 0 then
        ()
    else
        let childTag = Stdlib.Dict.__getTag(child) in
        let childPtr = __int64_to_rawptr(Stdlib.Dict.__clearTag(child)) in
        if childTag == 2 then
            // Leaf - clean it up
            Stdlib.Dict.__cleanupLeaf_str(childPtr)
        else if childTag == 1 then
            // Internal - recursively clean its children first
            let childBitmap = __raw_get(childPtr, 0) in
            let _ = Stdlib.Dict.__cleanupInternalChildren_str(childPtr, childBitmap, 0) in
            __raw_free(childPtr)
        else
            ()

// Cleanup internal node's children one by one
def Stdlib.Dict.__cleanupInternalChildren_str(ptr: RawPtr, bitmap: Int64, bit: Int64) : Unit =
    if bit >= 64 then
        ()
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get(ptr, 8 + (idx * 8)) in
        let _ = Stdlib.Dict.__cleanupChild_str(child) in
        Stdlib.Dict.__cleanupInternalChildren_str(ptr, bitmap, bit + 1)
    else
        Stdlib.Dict.__cleanupInternalChildren_str(ptr, bitmap, bit + 1)

// Main cleanup function - traverses entire HAMT and frees all nodes
def Stdlib.Dict.__cleanup_str(node: Int64) : Unit =
    if node == 0 then
        ()
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            // Leaf node - decrement key refcount and free node
            Stdlib.Dict.__cleanupLeaf_str(ptr)
        else if tag == 1 then
            // Internal node - recurse on all children, then free
            let bitmap = __raw_get(ptr, 0) in
            let _ = Stdlib.Dict.__cleanupInternalChildren_str(ptr, bitmap, 0) in
            __raw_free(ptr)
        else
            ()

// ============ Dict Utility Functions ============

// Check if dict is empty (works for both int and string-keyed)
def Stdlib.Dict.isEmpty(dict: Int64) : Bool = dict == 0

// Check if dict contains an int key
def Stdlib.Dict.contains(dict: Int64, key: Int64) : Bool =
    Stdlib.Dict.get(dict, key) != -1

// Check if dict contains a string key
def Stdlib.Dict.contains_str(dict: Int64, key: String) : Bool =
    Stdlib.Dict.get_str(dict, key) != -1

// Count entries in dict (works for both int and string-keyed)
def Stdlib.Dict.size(dict: Int64) : Int64 =
    Stdlib.Dict.__sizeHelper(dict)

def Stdlib.Dict.__sizeHelper(node: Int64) : Int64 =
    if node == 0 then
        0
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            1
        else if tag == 1 then
            let bitmap = __raw_get(ptr, 0) in
            Stdlib.Dict.__countChildren(ptr, bitmap, 0)
        else
            0

def Stdlib.Dict.__countChildren(ptr: RawPtr, bitmap: Int64, bit: Int64) : Int64 =
    if bit >= 64 then
        0
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get(ptr, 8 + (idx * 8)) in
        Stdlib.Dict.__sizeHelper(child) + Stdlib.Dict.__countChildren(ptr, bitmap, bit + 1)
    else
        Stdlib.Dict.__countChildren(ptr, bitmap, bit + 1)

// ============ Dict Enumeration (Int64-keyed) ============

// Get all keys from dict
def Stdlib.Dict.keys(dict: Int64) : List<Int64> =
    Stdlib.Dict.__keysHelper(dict, [])

def Stdlib.Dict.__keysHelper(node: Int64, acc: List<Int64>) : List<Int64> =
    if node == 0 then
        acc
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            let key = __raw_get(ptr, 0) in
            [key, ...acc]
        else if tag == 1 then
            let bitmap = __raw_get(ptr, 0) in
            Stdlib.Dict.__collectKeysFromChildren(ptr, bitmap, 0, acc)
        else
            acc

def Stdlib.Dict.__collectKeysFromChildren(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: List<Int64>) : List<Int64> =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__keysHelper(child, acc) in
        Stdlib.Dict.__collectKeysFromChildren(ptr, bitmap, bit + 1, newAcc)
    else
        Stdlib.Dict.__collectKeysFromChildren(ptr, bitmap, bit + 1, acc)

// Get all values from dict
def Stdlib.Dict.values(dict: Int64) : List<Int64> =
    Stdlib.Dict.__valuesHelper(dict, [])

def Stdlib.Dict.__valuesHelper(node: Int64, acc: List<Int64>) : List<Int64> =
    if node == 0 then
        acc
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            let value = __raw_get(ptr, 8) in
            [value, ...acc]
        else if tag == 1 then
            let bitmap = __raw_get(ptr, 0) in
            Stdlib.Dict.__collectValuesFromChildren(ptr, bitmap, 0, acc)
        else
            acc

def Stdlib.Dict.__collectValuesFromChildren(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: List<Int64>) : List<Int64> =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__valuesHelper(child, acc) in
        Stdlib.Dict.__collectValuesFromChildren(ptr, bitmap, bit + 1, newAcc)
    else
        Stdlib.Dict.__collectValuesFromChildren(ptr, bitmap, bit + 1, acc)

// Get all key-value pairs from dict
def Stdlib.Dict.entries(dict: Int64) : List<(Int64, Int64)> =
    Stdlib.Dict.__entriesHelper(dict, [])

def Stdlib.Dict.__entriesHelper(node: Int64, acc: List<(Int64, Int64)>) : List<(Int64, Int64)> =
    if node == 0 then
        acc
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            let key = __raw_get(ptr, 0) in
            let value = __raw_get(ptr, 8) in
            [(key, value), ...acc]
        else if tag == 1 then
            let bitmap = __raw_get(ptr, 0) in
            Stdlib.Dict.__collectEntriesFromChildren(ptr, bitmap, 0, acc)
        else
            acc

def Stdlib.Dict.__collectEntriesFromChildren(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: List<(Int64, Int64)>) : List<(Int64, Int64)> =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__entriesHelper(child, acc) in
        Stdlib.Dict.__collectEntriesFromChildren(ptr, bitmap, bit + 1, newAcc)
    else
        Stdlib.Dict.__collectEntriesFromChildren(ptr, bitmap, bit + 1, acc)

// ============ Dict Enumeration (String-keyed) ============

// Get all string keys from dict
def Stdlib.Dict.keys_str(dict: Int64) : List<String> =
    Stdlib.Dict.__keysHelper_str(dict, [])

def Stdlib.Dict.__keysHelper_str(node: Int64, acc: List<String>) : List<String> =
    if node == 0 then
        acc
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            let keyPtr = __raw_get(ptr, 0) in
            let key = __int64_to_string(keyPtr) in
            [key, ...acc]
        else if tag == 1 then
            let bitmap = __raw_get(ptr, 0) in
            Stdlib.Dict.__collectKeysFromChildren_str(ptr, bitmap, 0, acc)
        else
            acc

def Stdlib.Dict.__collectKeysFromChildren_str(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: List<String>) : List<String> =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__keysHelper_str(child, acc) in
        Stdlib.Dict.__collectKeysFromChildren_str(ptr, bitmap, bit + 1, newAcc)
    else
        Stdlib.Dict.__collectKeysFromChildren_str(ptr, bitmap, bit + 1, acc)

// Get all values from string-keyed dict (values are still Int64)
def Stdlib.Dict.values_str(dict: Int64) : List<Int64> =
    Stdlib.Dict.values(dict)

// Get all key-value pairs from string-keyed dict
def Stdlib.Dict.entries_str(dict: Int64) : List<(String, Int64)> =
    Stdlib.Dict.__entriesHelper_str(dict, [])

def Stdlib.Dict.__entriesHelper_str(node: Int64, acc: List<(String, Int64)>) : List<(String, Int64)> =
    if node == 0 then
        acc
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            let keyPtr = __raw_get(ptr, 0) in
            let key = __int64_to_string(keyPtr) in
            let value = __raw_get(ptr, 8) in
            [(key, value), ...acc]
        else if tag == 1 then
            let bitmap = __raw_get(ptr, 0) in
            Stdlib.Dict.__collectEntriesFromChildren_str(ptr, bitmap, 0, acc)
        else
            acc

def Stdlib.Dict.__collectEntriesFromChildren_str(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: List<(String, Int64)>) : List<(String, Int64)> =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__entriesHelper_str(child, acc) in
        Stdlib.Dict.__collectEntriesFromChildren_str(ptr, bitmap, bit + 1, newAcc)
    else
        Stdlib.Dict.__collectEntriesFromChildren_str(ptr, bitmap, bit + 1, acc)

// ============ Dict Functional Operations (Int64-keyed) ============

// Fold over all entries in dict (non-generic version for Int64 accumulator)
def Stdlib.Dict.fold(dict: Int64, init: Int64, fn: (Int64, Int64, Int64) -> Int64) : Int64 =
    Stdlib.Dict.__foldHelper(dict, init, fn)

def Stdlib.Dict.__foldHelper(node: Int64, acc: Int64, fn: (Int64, Int64, Int64) -> Int64) : Int64 =
    if node == 0 then
        acc
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            let key = __raw_get(ptr, 0) in
            let value = __raw_get(ptr, 8) in
            fn(acc, key, value)
        else if tag == 1 then
            let bitmap = __raw_get(ptr, 0) in
            Stdlib.Dict.__foldChildren(ptr, bitmap, 0, acc, fn)
        else
            acc

def Stdlib.Dict.__foldChildren(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: Int64, fn: (Int64, Int64, Int64) -> Int64) : Int64 =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__foldHelper(child, acc, fn) in
        Stdlib.Dict.__foldChildren(ptr, bitmap, bit + 1, newAcc, fn)
    else
        Stdlib.Dict.__foldChildren(ptr, bitmap, bit + 1, acc, fn)

// Map over values in dict, keeping keys the same
def Stdlib.Dict.map(dict: Int64, fn: (Int64) -> Int64) : Int64 =
    Stdlib.Dict.__mapHelper(dict, fn)

def Stdlib.Dict.__mapHelper(node: Int64, fn: (Int64) -> Int64) : Int64 =
    if node == 0 then
        0
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            let key = __raw_get(ptr, 0) in
            let value = __raw_get(ptr, 8) in
            Stdlib.Dict.__allocLeaf(key, fn(value))
        else if tag == 1 then
            let bitmap = __raw_get(ptr, 0) in
            let numChildren = Stdlib.Int64.popcount(bitmap) in
            let newNode = Stdlib.Dict.__allocInternal(bitmap, numChildren) in
            let _ = Stdlib.Dict.__mapChildren(ptr, newNode, bitmap, 0, fn) in
            Stdlib.Dict.__setTag(__rawptr_to_int64(newNode), 1)
        else
            0

def Stdlib.Dict.__mapChildren(oldPtr: RawPtr, newPtr: RawPtr, bitmap: Int64, bit: Int64, fn: (Int64) -> Int64) : Unit =
    if bit >= 64 then
        ()
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get(oldPtr, 8 + (idx * 8)) in
        let newChild = Stdlib.Dict.__mapHelper(child, fn) in
        let _ = __raw_set(newPtr, 8 + (idx * 8), newChild) in
        Stdlib.Dict.__mapChildren(oldPtr, newPtr, bitmap, bit + 1, fn)
    else
        Stdlib.Dict.__mapChildren(oldPtr, newPtr, bitmap, bit + 1, fn)

// Filter entries in dict based on predicate
def Stdlib.Dict.filter(dict: Int64, fn: (Int64, Int64) -> Bool) : Int64 =
    Stdlib.Dict.__filterHelper(dict, Stdlib.Dict.empty(), fn)

def Stdlib.Dict.__filterHelper(node: Int64, acc: Int64, fn: (Int64, Int64) -> Bool) : Int64 =
    if node == 0 then
        acc
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            let key = __raw_get(ptr, 0) in
            let value = __raw_get(ptr, 8) in
            if fn(key, value) then Stdlib.Dict.set(acc, key, value) else acc
        else if tag == 1 then
            let bitmap = __raw_get(ptr, 0) in
            Stdlib.Dict.__filterChildren(ptr, bitmap, 0, acc, fn)
        else
            acc

def Stdlib.Dict.__filterChildren(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: Int64, fn: (Int64, Int64) -> Bool) : Int64 =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__filterHelper(child, acc, fn) in
        Stdlib.Dict.__filterChildren(ptr, bitmap, bit + 1, newAcc, fn)
    else
        Stdlib.Dict.__filterChildren(ptr, bitmap, bit + 1, acc, fn)

// ============ Dict Functional Operations (String-keyed) ============

// Fold over all entries in string-keyed dict
def Stdlib.Dict.fold_str(dict: Int64, init: Int64, fn: (Int64, String, Int64) -> Int64) : Int64 =
    Stdlib.Dict.__foldHelper_str(dict, init, fn)

def Stdlib.Dict.__foldHelper_str(node: Int64, acc: Int64, fn: (Int64, String, Int64) -> Int64) : Int64 =
    if node == 0 then
        acc
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            let keyPtr = __raw_get(ptr, 0) in
            let key = __int64_to_string(keyPtr) in
            let value = __raw_get(ptr, 8) in
            fn(acc, key, value)
        else if tag == 1 then
            let bitmap = __raw_get(ptr, 0) in
            Stdlib.Dict.__foldChildren_str(ptr, bitmap, 0, acc, fn)
        else
            acc

def Stdlib.Dict.__foldChildren_str(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: Int64, fn: (Int64, String, Int64) -> Int64) : Int64 =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__foldHelper_str(child, acc, fn) in
        Stdlib.Dict.__foldChildren_str(ptr, bitmap, bit + 1, newAcc, fn)
    else
        Stdlib.Dict.__foldChildren_str(ptr, bitmap, bit + 1, acc, fn)

// Map over values in string-keyed dict
def Stdlib.Dict.map_str(dict: Int64, fn: (Int64) -> Int64) : Int64 =
    Stdlib.Dict.__mapHelper_str(dict, fn)

def Stdlib.Dict.__mapHelper_str(node: Int64, fn: (Int64) -> Int64) : Int64 =
    if node == 0 then
        0
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            let keyPtr = __raw_get(ptr, 0) in
            let key = __int64_to_string(keyPtr) in
            let value = __raw_get(ptr, 8) in
            Stdlib.Dict.__allocLeaf_str(key, fn(value))
        else if tag == 1 then
            let bitmap = __raw_get(ptr, 0) in
            let numChildren = Stdlib.Int64.popcount(bitmap) in
            let newNode = Stdlib.Dict.__allocInternal(bitmap, numChildren) in
            let _ = Stdlib.Dict.__mapChildren_str(ptr, newNode, bitmap, 0, fn) in
            Stdlib.Dict.__setTag(__rawptr_to_int64(newNode), 1)
        else
            0

def Stdlib.Dict.__mapChildren_str(oldPtr: RawPtr, newPtr: RawPtr, bitmap: Int64, bit: Int64, fn: (Int64) -> Int64) : Unit =
    if bit >= 64 then
        ()
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get(oldPtr, 8 + (idx * 8)) in
        let newChild = Stdlib.Dict.__mapHelper_str(child, fn) in
        let _ = __raw_set(newPtr, 8 + (idx * 8), newChild) in
        Stdlib.Dict.__mapChildren_str(oldPtr, newPtr, bitmap, bit + 1, fn)
    else
        Stdlib.Dict.__mapChildren_str(oldPtr, newPtr, bitmap, bit + 1, fn)

// Filter entries in string-keyed dict
def Stdlib.Dict.filter_str(dict: Int64, fn: (String, Int64) -> Bool) : Int64 =
    Stdlib.Dict.__filterHelper_str(dict, Stdlib.Dict.empty(), fn)

def Stdlib.Dict.__filterHelper_str(node: Int64, acc: Int64, fn: (String, Int64) -> Bool) : Int64 =
    if node == 0 then
        acc
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            let keyPtr = __raw_get(ptr, 0) in
            let key = __int64_to_string(keyPtr) in
            let value = __raw_get(ptr, 8) in
            if fn(key, value) then Stdlib.Dict.set_str(acc, key, value) else acc
        else if tag == 1 then
            let bitmap = __raw_get(ptr, 0) in
            Stdlib.Dict.__filterChildren_str(ptr, bitmap, 0, acc, fn)
        else
            acc

def Stdlib.Dict.__filterChildren_str(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: Int64, fn: (String, Int64) -> Bool) : Int64 =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__filterHelper_str(child, acc, fn) in
        Stdlib.Dict.__filterChildren_str(ptr, bitmap, bit + 1, newAcc, fn)
    else
        Stdlib.Dict.__filterChildren_str(ptr, bitmap, bit + 1, acc, fn)
