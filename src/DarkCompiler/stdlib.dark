// Stdlib.dark - Standard Library Functions
//
// These functions are automatically included in all Dark programs.
// They provide the built-in Stdlib modules.

// Stdlib.Int64 - Integer operations

def Stdlib.Int64.add(a: Int64, b: Int64) : Int64 = a + b

def Stdlib.Int64.sub(a: Int64, b: Int64) : Int64 = a - b

def Stdlib.Int64.mul(a: Int64, b: Int64) : Int64 = a * b

def Stdlib.Int64.div(a: Int64, b: Int64) : Int64 = a / b

def Stdlib.Int64.max(a: Int64, b: Int64) : Int64 = if a > b then a else b

def Stdlib.Int64.min(a: Int64, b: Int64) : Int64 = if a < b then a else b

def Stdlib.Int64.mod(a: Int64, b: Int64) : Int64 = a % b

def Stdlib.Int64.absoluteValue(a: Int64) : Int64 = if a < 0 then 0 - a else a

def Stdlib.Int64.negate(a: Int64) : Int64 = 0 - a

def Stdlib.Int64.power(base: Int64, exponent: Int64) : Int64 =
    if exponent == 0 then 1
    else if exponent == 1 then base
    else base * Stdlib.Int64.power(base, exponent - 1)

def Stdlib.Int64.clamp(value: Int64, limitA: Int64, limitB: Int64) : Int64 =
    let lower = Stdlib.Int64.min(limitA, limitB) in
    let upper = Stdlib.Int64.max(limitA, limitB) in
    Stdlib.Int64.max(lower, Stdlib.Int64.min(upper, value))

def Stdlib.Int64.greaterThan(a: Int64, b: Int64) : Bool = a > b

def Stdlib.Int64.greaterThanOrEqualTo(a: Int64, b: Int64) : Bool = a >= b

def Stdlib.Int64.lessThan(a: Int64, b: Int64) : Bool = a < b

def Stdlib.Int64.lessThanOrEqualTo(a: Int64, b: Int64) : Bool = a <= b

// Bitwise operations
def Stdlib.Int64.bitwiseAnd(a: Int64, b: Int64) : Int64 = a & b

def Stdlib.Int64.bitwiseOr(a: Int64, b: Int64) : Int64 = a ||| b

def Stdlib.Int64.bitwiseXor(a: Int64, b: Int64) : Int64 = a ^ b

def Stdlib.Int64.shiftLeft(a: Int64, shift: Int64) : Int64 = a << shift

def Stdlib.Int64.shiftRight(a: Int64, shift: Int64) : Int64 = a >> shift

def Stdlib.Int64.bitwiseNot(a: Int64) : Int64 = ~~~a

// Count number of set bits (population count)
// Uses parallel bit counting algorithm (Brian Kernighan / SWAR)
def Stdlib.Int64.popcount(x: Int64) : Int64 =
    // Constants (in decimal):
    // 0x5555555555555555 = 6148914691236517205
    // 0x3333333333333333 = 3689348814741910323
    // 0x0F0F0F0F0F0F0F0F = 1085102592571150095
    // 0x0101010101010101 = 72340172838076673
    let mask1 = 6148914691236517205 in
    let mask2 = 3689348814741910323 in
    let mask3 = 1085102592571150095 in
    let mult = 72340172838076673 in
    let x = x - ((x >> 1) & mask1) in
    let x = (x & mask2) + ((x >> 2) & mask2) in
    let x = (x + (x >> 4)) & mask3 in
    (x * mult) >> 56

// Convert a single digit (0-9) to its string representation
def Stdlib.Int64.digitToString(n: Int64) : String =
    match n with
    | 0 -> "0"
    | 1 -> "1"
    | 2 -> "2"
    | 3 -> "3"
    | 4 -> "4"
    | 5 -> "5"
    | 6 -> "6"
    | 7 -> "7"
    | 8 -> "8"
    | 9 -> "9"
    | _ -> "?"

// Convert an integer to its string representation
def Stdlib.Int64.toString(n: Int64) : String =
    if n < 0 then "-" ++ Stdlib.Int64.toString(0 - n)
    else if n < 10 then Stdlib.Int64.digitToString(n)
    else Stdlib.Int64.toString(n / 10) ++ Stdlib.Int64.digitToString(n % 10)

// Check if integer is even
def Stdlib.Int64.isEven(n: Int64) : Bool =
    (n % 2) == 0

// Check if integer is odd
def Stdlib.Int64.isOdd(n: Int64) : Bool =
    (n % 2) != 0

// Sum all integers in a list
def Stdlib.Int64.sum(list: List<Int64>) : Int64 =
    Stdlib.List.fold<Int64, Int64>(list, 0, (acc: Int64, x: Int64) => acc + x)

// Stdlib.Bool - Boolean operations

def Stdlib.Bool.not(b: Bool) : Bool = !b

def Stdlib.Bool.and(a: Bool, b: Bool) : Bool = a && b

def Stdlib.Bool.or(a: Bool, b: Bool) : Bool = a || b

def Stdlib.Bool.xor(a: Bool, b: Bool) : Bool = if a then !b else b

def Stdlib.Bool.toString(b: Bool) : String = if b then "true" else "false"

// Stdlib.Tuple2 - 2-tuple operations

def Stdlib.Tuple2.create<a, b>(first: a, second: b) : (a, b) = (first, second)

def Stdlib.Tuple2.first<a, b>(t: (a, b)) : a = match t with | (x, y) -> x

def Stdlib.Tuple2.second<a, b>(t: (a, b)) : b = match t with | (x, y) -> y

def Stdlib.Tuple2.swap<a, b>(t: (a, b)) : (b, a) = match t with | (x, y) -> (y, x)

def Stdlib.Tuple2.mapFirst<a, b, c>(fn: (a) -> c, t: (a, b)) : (c, b) =
    match t with | (x, y) -> (fn(x), y)

def Stdlib.Tuple2.mapSecond<a, b, c>(fn: (b) -> c, t: (a, b)) : (a, c) =
    match t with | (x, y) -> (x, fn(y))

def Stdlib.Tuple2.mapBoth<a, b, c, d>(fnFirst: (a) -> c, fnSecond: (b) -> d, t: (a, b)) : (c, d) =
    match t with | (x, y) -> (fnFirst(x), fnSecond(y))

// Stdlib.Tuple3 - 3-tuple operations

def Stdlib.Tuple3.create<a, b, c>(first: a, second: b, third: c) : (a, b, c) = (first, second, third)

def Stdlib.Tuple3.first<a, b, c>(t: (a, b, c)) : a = match t with | (x, y, z) -> x

def Stdlib.Tuple3.second<a, b, c>(t: (a, b, c)) : b = match t with | (x, y, z) -> y

def Stdlib.Tuple3.third<a, b, c>(t: (a, b, c)) : c = match t with | (x, y, z) -> z

def Stdlib.Tuple3.mapFirst<a, b, c, d>(fn: (a) -> d, t: (a, b, c)) : (d, b, c) =
    match t with | (x, y, z) -> (fn(x), y, z)

def Stdlib.Tuple3.mapSecond<a, b, c, d>(fn: (b) -> d, t: (a, b, c)) : (a, d, c) =
    match t with | (x, y, z) -> (x, fn(y), z)

def Stdlib.Tuple3.mapThird<a, b, c, d>(fn: (c) -> d, t: (a, b, c)) : (a, b, d) =
    match t with | (x, y, z) -> (x, y, fn(z))

def Stdlib.Tuple3.mapAllThree<a, b, c, d, e, f>(fnFirst: (a) -> d, fnSecond: (b) -> e, fnThird: (c) -> f, t: (a, b, c)) : (d, e, f) =
    match t with | (x, y, z) -> (fnFirst(x), fnSecond(y), fnThird(z))

// Stdlib.Result - Result type for error handling
type Stdlib.Result.Result<t, e> = Ok of t | Error of e

// Check if result is Ok
def Stdlib.Result.isOk<t, e>(result: Stdlib.Result.Result<t, e>) : Bool =
    match result with
    | Ok(_) -> true
    | Error(_) -> false

// Check if result is Error
def Stdlib.Result.isError<t, e>(result: Stdlib.Result.Result<t, e>) : Bool =
    match result with
    | Ok(_) -> false
    | Error(_) -> true

// Get the Ok value or return a default
def Stdlib.Result.withDefault<t, e>(result: Stdlib.Result.Result<t, e>, default: t) : t =
    match result with
    | Ok(v) -> v
    | Error(_) -> default

// Transform the Ok value with a function
def Stdlib.Result.map<t, u, e>(result: Stdlib.Result.Result<t, e>, fn: (t) -> u) : Stdlib.Result.Result<u, e> =
    match result with
    | Ok(v) -> Ok(fn(v))
    | Error(err) -> Error(err)

// Transform the Error value with a function
def Stdlib.Result.mapError<t, e, f>(fn: (e) -> f, result: Stdlib.Result.Result<t, e>) : Stdlib.Result.Result<t, f> =
    match result with
    | Ok(v) -> Ok(v)
    | Error(err) -> Error(fn(err))

// Chain Result computations
def Stdlib.Result.andThen<t, u, e>(result: Stdlib.Result.Result<t, e>, fn: (t) -> Stdlib.Result.Result<u, e>) : Stdlib.Result.Result<u, e> =
    match result with
    | Ok(v) -> fn(v)
    | Error(err) -> Error(err)

// Stdlib.Option - Optional values
type Stdlib.Option.Option<t> = Some of t | None

// Check if option has a value
def Stdlib.Option.isSome<t>(opt: Stdlib.Option.Option<t>) : Bool =
    match opt with
    | Some(_) -> true
    | None -> false

// Check if option is empty
def Stdlib.Option.isNone<t>(opt: Stdlib.Option.Option<t>) : Bool =
    match opt with
    | Some(_) -> false
    | None -> true

// Get the value or return a default
def Stdlib.Option.withDefault<t>(opt: Stdlib.Option.Option<t>, default: t) : t =
    match opt with
    | Some(v) -> v
    | None -> default

// Transform the value with a function if present
def Stdlib.Option.map<t, u>(opt: Stdlib.Option.Option<t>, fn: (t) -> u) : Stdlib.Option.Option<u> =
    match opt with
    | Some(v) -> Some(fn(v))
    | None -> None

// Chain Option computations
def Stdlib.Option.andThen<t, u>(opt: Stdlib.Option.Option<t>, fn: (t) -> Stdlib.Option.Option<u>) : Stdlib.Option.Option<u> =
    match opt with
    | Some(v) -> fn(v)
    | None -> None

// Convert Option to a single-element or empty list
def Stdlib.Option.toList<t>(opt: Stdlib.Option.Option<t>) : List<t> =
    match opt with
    | Some(v) -> [v]
    | None -> []

// Stdlib.List - List operations
// Lists are now FingerTrees internally for O(1) push/pushBack and O(log n) indexing

// Check if list is empty - O(1)
def Stdlib.List.isEmpty<t>(list: List<t>) : Bool =
    Stdlib.FingerTree.isEmpty<t>(list)

// Get the length of a list - O(1)
def Stdlib.List.length<t>(list: List<t>) : Int64 =
    Stdlib.FingerTree.length<t>(list)

// Create a single-element list - O(1)
def Stdlib.List.singleton<t>(value: t) : List<t> =
    Stdlib.FingerTree.singleton<t>(value)

// Prepend an element to a list - O(1) amortized
def Stdlib.List.push<t>(list: List<t>, value: t) : List<t> =
    Stdlib.FingerTree.push<t>(list, value)

// Apply a function to each element of a list - O(n)
def Stdlib.List.map<a, b>(list: List<a>, fn: (a) -> b) : List<b> =
    Stdlib.List.__mapHelper<a, b>(list, fn, Stdlib.FingerTree.empty<b>())

def Stdlib.List.__mapHelper<a, b>(list: List<a>, fn: (a) -> b, acc: List<b>) : List<b> =
    if Stdlib.FingerTree.isEmpty<a>(list) then acc
    else
        match Stdlib.FingerTree.head<a>(list) with
        | None -> acc
        | Some(h) ->
            let newAcc = Stdlib.FingerTree.pushBack<b>(acc, fn(h)) in
            Stdlib.List.__mapHelper<a, b>(Stdlib.FingerTree.tail<a>(list), fn, newAcc)

// Flatten a list of lists into a single list - O(n*m)
def Stdlib.List.flatten<a>(lists: List<List<a>>) : List<a> =
    Stdlib.List.__flattenHelper<a>(lists, Stdlib.FingerTree.empty<a>())

def Stdlib.List.__flattenHelper<a>(lists: List<List<a>>, acc: List<a>) : List<a> =
    if Stdlib.FingerTree.isEmpty<List<a>>(lists) then acc
    else
        match Stdlib.FingerTree.head<List<a>>(lists) with
        | None -> acc
        | Some(h) ->
            let newAcc = Stdlib.List.append<a>(acc, h) in
            Stdlib.List.__flattenHelper<a>(Stdlib.FingerTree.tail<List<a>>(lists), newAcc)

// Apply a function that returns a list and flatten the results
def Stdlib.List.flatMap<a, b>(list: List<a>, fn: (a) -> List<b>) : List<b> =
    Stdlib.List.flatten<b>(Stdlib.List.map<a, List<b>>(list, fn))

// Keep only elements that satisfy a predicate - O(n)
def Stdlib.List.filter<a>(list: List<a>, fn: (a) -> Bool) : List<a> =
    Stdlib.List.__filterHelper<a>(list, fn, Stdlib.FingerTree.empty<a>())

def Stdlib.List.__filterHelper<a>(list: List<a>, fn: (a) -> Bool, acc: List<a>) : List<a> =
    if Stdlib.FingerTree.isEmpty<a>(list) then acc
    else
        match Stdlib.FingerTree.head<a>(list) with
        | None -> acc
        | Some(h) ->
            let newAcc = if fn(h) then Stdlib.FingerTree.pushBack<a>(acc, h) else acc in
            Stdlib.List.__filterHelper<a>(Stdlib.FingerTree.tail<a>(list), fn, newAcc)

// Append an element to the end of a list - O(1) amortized
def Stdlib.List.pushBack<a>(list: List<a>, value: a) : List<a> =
    Stdlib.FingerTree.pushBack<a>(list, value)

// Concatenate two lists - O(log min(n,m))
// For now, use sequential pushBack (TODO: implement efficient FingerTree append)
def Stdlib.List.append<a>(list1: List<a>, list2: List<a>) : List<a> =
    Stdlib.List.__appendHelper<a>(list2, list1)

def Stdlib.List.__appendHelper<a>(src: List<a>, dst: List<a>) : List<a> =
    if Stdlib.FingerTree.isEmpty<a>(src) then dst
    else
        match Stdlib.FingerTree.head<a>(src) with
        | None -> dst
        | Some(h) ->
            let newDst = Stdlib.FingerTree.pushBack<a>(dst, h) in
            Stdlib.List.__appendHelper<a>(Stdlib.FingerTree.tail<a>(src), newDst)

// Reverse a list - O(n)
def Stdlib.List.reverse<a>(list: List<a>) : List<a> =
    Stdlib.List.__reverseHelper<a>(list, Stdlib.FingerTree.empty<a>())

def Stdlib.List.__reverseHelper<a>(list: List<a>, acc: List<a>) : List<a> =
    if Stdlib.FingerTree.isEmpty<a>(list) then acc
    else
        match Stdlib.FingerTree.head<a>(list) with
        | None -> acc
        | Some(h) ->
            let newAcc = Stdlib.FingerTree.push<a>(acc, h) in
            Stdlib.List.__reverseHelper<a>(Stdlib.FingerTree.tail<a>(list), newAcc)

// Fold left (reduce) over a list - O(n)
def Stdlib.List.fold<a, b>(list: List<a>, init: b, fn: (b, a) -> b) : b =
    if Stdlib.FingerTree.isEmpty<a>(list) then init
    else
        match Stdlib.FingerTree.head<a>(list) with
        | None -> init
        | Some(h) ->
            let newInit = fn(init, h) in
            Stdlib.List.fold<a, b>(Stdlib.FingerTree.tail<a>(list), newInit, fn)

// Get head of list or return None - O(1)
def Stdlib.List.head<a>(list: List<a>) : Stdlib.Option.Option<a> =
    Stdlib.FingerTree.head<a>(list)

// Internal: get head without option wrapper (caller must ensure non-empty)
// This forces monomorphization of headUnsafe_i64 for pattern matching
def Stdlib.List.__headUnsafeInt64(list: List<Int64>) : Int64 =
    Stdlib.FingerTree.headUnsafe<Int64>(list)

// Internal: get element at index (forces monomorphization for pattern matching)
def Stdlib.List.__getAtInt64(list: List<Int64>, idx: Int64) : Stdlib.Option.Option<Int64> =
    Stdlib.FingerTree.getAt<Int64>(list, idx)

// Get tail of list or return None - O(1) amortized
def Stdlib.List.tail<a>(list: List<a>) : Stdlib.Option.Option<List<a>> =
    if Stdlib.FingerTree.isEmpty<a>(list) then None
    else Some(Stdlib.FingerTree.tail<a>(list))

// Get element at index (0-based) - O(log n)
def Stdlib.List.getAt<a>(list: List<a>, index: Int64) : Stdlib.Option.Option<a> =
    Stdlib.FingerTree.getAt<a>(list, index)

// Set element at index (0-based) - O(log n), returns original list if index out of bounds
def Stdlib.List.setAt<a>(list: List<a>, index: Int64, value: a) : List<a> =
    Stdlib.FingerTree.setAt<a>(list, index, value)

// Find first element satisfying a predicate - O(n)
def Stdlib.List.findFirst<a>(list: List<a>, fn: (a) -> Bool) : Stdlib.Option.Option<a> =
    if Stdlib.FingerTree.isEmpty<a>(list) then None
    else
        match Stdlib.FingerTree.head<a>(list) with
        | None -> None
        | Some(h) ->
            if fn(h) then Some(h)
            else Stdlib.List.findFirst<a>(Stdlib.FingerTree.tail<a>(list), fn)

// Take first n elements - O(n)
def Stdlib.List.take<a>(list: List<a>, n: Int64) : List<a> =
    Stdlib.List.__takeHelper<a>(list, n, Stdlib.FingerTree.empty<a>())

def Stdlib.List.__takeHelper<a>(list: List<a>, n: Int64, acc: List<a>) : List<a> =
    if n <= 0 then acc
    else if Stdlib.FingerTree.isEmpty<a>(list) then acc
    else
        match Stdlib.FingerTree.head<a>(list) with
        | None -> acc
        | Some(h) ->
            let newAcc = Stdlib.FingerTree.pushBack<a>(acc, h) in
            Stdlib.List.__takeHelper<a>(Stdlib.FingerTree.tail<a>(list), n - 1, newAcc)

// Drop first n elements - O(n)
def Stdlib.List.drop<a>(list: List<a>, n: Int64) : List<a> =
    if n <= 0 then list
    else if Stdlib.FingerTree.isEmpty<a>(list) then list
    else Stdlib.List.drop<a>(Stdlib.FingerTree.tail<a>(list), n - 1)

// Check if all elements satisfy a predicate - O(n)
def Stdlib.List.forAll<a>(list: List<a>, fn: (a) -> Bool) : Bool =
    if Stdlib.FingerTree.isEmpty<a>(list) then true
    else
        match Stdlib.FingerTree.head<a>(list) with
        | None -> true
        | Some(h) ->
            if fn(h) then Stdlib.List.forAll<a>(Stdlib.FingerTree.tail<a>(list), fn)
            else false

// Check if any element satisfies a predicate - O(n)
def Stdlib.List.exists<a>(list: List<a>, fn: (a) -> Bool) : Bool =
    if Stdlib.FingerTree.isEmpty<a>(list) then false
    else
        match Stdlib.FingerTree.head<a>(list) with
        | None -> false
        | Some(h) ->
            if fn(h) then true
            else Stdlib.List.exists<a>(Stdlib.FingerTree.tail<a>(list), fn)

// Get the last element of a list, or None if empty - O(1)
def Stdlib.List.last<a>(list: List<a>) : Stdlib.Option.Option<a> =
    Stdlib.FingerTree.last<a>(list)

// Remove the last element from a list - O(1) amortized
// TODO: implement init for FingerTree, for now use O(n) rebuild
def Stdlib.List.dropLast<a>(list: List<a>) : List<a> =
    Stdlib.List.__dropLastHelper<a>(list, Stdlib.FingerTree.empty<a>())

def Stdlib.List.__dropLastHelper<a>(list: List<a>, acc: List<a>) : List<a> =
    if Stdlib.FingerTree.isEmpty<a>(list) then acc
    else
        let t = Stdlib.FingerTree.tail<a>(list) in
        if Stdlib.FingerTree.isEmpty<a>(t) then acc  // Only one element left - drop it
        else
            match Stdlib.FingerTree.head<a>(list) with
            | None -> acc
            | Some(h) -> Stdlib.List.__dropLastHelper<a>(t, Stdlib.FingerTree.pushBack<a>(acc, h))

// Generate a list of integers from start (inclusive) to end (exclusive)
def Stdlib.List.range(start: Int64, end_: Int64) : List<Int64> =
    Stdlib.List.__rangeHelper(start, end_, Stdlib.FingerTree.empty<Int64>())

def Stdlib.List.__rangeHelper(current: Int64, end_: Int64, acc: List<Int64>) : List<Int64> =
    if current >= end_ then acc
    else Stdlib.List.__rangeHelper(current + 1, end_, Stdlib.FingerTree.pushBack<Int64>(acc, current))

// Repeat a value n times
def Stdlib.List.repeat<a>(value: a, count: Int64) : List<a> =
    Stdlib.List.__repeatHelper<a>(value, count, Stdlib.FingerTree.empty<a>())

def Stdlib.List.__repeatHelper<a>(value: a, count: Int64, acc: List<a>) : List<a> =
    if count <= 0 then acc
    else Stdlib.List.__repeatHelper<a>(value, count - 1, Stdlib.FingerTree.pushBack<a>(acc, value))

// Map with index: apply a function to each element along with its index - O(n)
def Stdlib.List.indexedMap<a, b>(list: List<a>, fn: (Int64, a) -> b) : List<b> =
    Stdlib.List.__indexedMapHelper<a, b>(list, fn, 0, Stdlib.FingerTree.empty<b>())

def Stdlib.List.__indexedMapHelper<a, b>(list: List<a>, fn: (Int64, a) -> b, index: Int64, acc: List<b>) : List<b> =
    if Stdlib.FingerTree.isEmpty<a>(list) then acc
    else
        match Stdlib.FingerTree.head<a>(list) with
        | None -> acc
        | Some(h) ->
            let newAcc = Stdlib.FingerTree.pushBack<b>(acc, fn(index, h)) in
            Stdlib.List.__indexedMapHelper<a, b>(Stdlib.FingerTree.tail<a>(list), fn, index + 1, newAcc)

// Partition a list into two lists based on a predicate
// Returns (elements where predicate is true, elements where predicate is false)
def Stdlib.List.partition<a>(list: List<a>, fn: (a) -> Bool) : (List<a>, List<a>) =
    Stdlib.List.__partitionHelper<a>(list, fn, Stdlib.FingerTree.empty<a>(), Stdlib.FingerTree.empty<a>())

def Stdlib.List.__partitionHelper<a>(list: List<a>, fn: (a) -> Bool, trueAcc: List<a>, falseAcc: List<a>) : (List<a>, List<a>) =
    if Stdlib.FingerTree.isEmpty<a>(list) then (trueAcc, falseAcc)
    else
        match Stdlib.FingerTree.head<a>(list) with
        | None -> (trueAcc, falseAcc)
        | Some(h) ->
            let newTrue = if fn(h) then Stdlib.FingerTree.pushBack<a>(trueAcc, h) else trueAcc in
            let newFalse = if fn(h) then falseAcc else Stdlib.FingerTree.pushBack<a>(falseAcc, h) in
            Stdlib.List.__partitionHelper<a>(Stdlib.FingerTree.tail<a>(list), fn, newTrue, newFalse)

// Alias for forAll (darklang naming convention)
def Stdlib.List.all<a>(list: List<a>, fn: (a) -> Bool) : Bool =
    Stdlib.List.forAll<a>(list, fn)

// Convert list to display string representation: "[elem1, elem2, ...]"
// Note: Generic version disabled due to function reference bug
// def Stdlib.List.toDisplayString<a>(list: List<a>, elemToString: (a) -> String) : String =
//     let strs = Stdlib.List.map<a, String>(list, elemToString) in
//     "[" ++ Stdlib.String.join(strs, ", ") ++ "]"

// Type-specific toDisplayString implementations (workaround for function reference bug)

// Helper to build string list from Int64 list
def Stdlib.List.__int64sToStrings(list: List<Int64>, acc: List<String>) : List<String> =
    if Stdlib.FingerTree.isEmpty<Int64>(list) then acc
    else
        match Stdlib.FingerTree.head<Int64>(list) with
        | None -> acc
        | Some(h) ->
            let s = Stdlib.Int64.toString(h) in
            let newAcc = Stdlib.FingerTree.pushBack<String>(acc, s) in
            Stdlib.List.__int64sToStrings(Stdlib.FingerTree.tail<Int64>(list), newAcc)

def Stdlib.List.toDisplayString_i64(list: List<Int64>) : String =
    let strs = Stdlib.List.__int64sToStrings(list, Stdlib.FingerTree.empty<String>()) in
    "[" ++ Stdlib.String.join(strs, ", ") ++ "]"

// Helper to build string list from String list (with single quotes for display)
def Stdlib.List.__stringsToStrings(list: List<String>, acc: List<String>) : List<String> =
    if Stdlib.FingerTree.isEmpty<String>(list) then acc
    else
        match Stdlib.FingerTree.head<String>(list) with
        | None -> acc
        | Some(h) ->
            let quoted = "'" ++ h ++ "'" in
            let newAcc = Stdlib.FingerTree.pushBack<String>(acc, quoted) in
            Stdlib.List.__stringsToStrings(Stdlib.FingerTree.tail<String>(list), newAcc)

def Stdlib.List.toDisplayString_str(list: List<String>) : String =
    let strs = Stdlib.List.__stringsToStrings(list, Stdlib.FingerTree.empty<String>()) in
    "[" ++ Stdlib.String.join(strs, ", ") ++ "]"

// Helper to build string list from Bool list
def Stdlib.List.__boolsToStrings(list: List<Bool>, acc: List<String>) : List<String> =
    if Stdlib.FingerTree.isEmpty<Bool>(list) then acc
    else
        match Stdlib.FingerTree.head<Bool>(list) with
        | None -> acc
        | Some(h) ->
            let s = Stdlib.Bool.toString(h) in
            let newAcc = Stdlib.FingerTree.pushBack<String>(acc, s) in
            Stdlib.List.__boolsToStrings(Stdlib.FingerTree.tail<Bool>(list), newAcc)

def Stdlib.List.toDisplayString_bool(list: List<Bool>) : String =
    let strs = Stdlib.List.__boolsToStrings(list, Stdlib.FingerTree.empty<String>()) in
    "[" ++ Stdlib.String.join(strs, ", ") ++ "]"

// TODO: List.zip is disabled due to compiler bug with tuple recursion
// def Stdlib.List.zip<a, b>(list1: List<a>, list2: List<b>) : List<(a, b)> =
//     match (list1, list2) with
//     | ([], _) -> []
//     | (_, []) -> []
//     | ([h1, ...t1], [h2, ...t2]) -> [(h1, h2), ...Stdlib.List.zip<a, b>(t1, t2)]

// Stdlib.Path - Path operations

// Combine two path segments
def Stdlib.Path.combine(a: String, b: String) : String = a ++ "/" ++ b

// Get system temp directory (constant-folded at compile time)
// This is an intrinsic that returns "/tmp" on both macOS and Linux
// Note: The actual implementation is in the compiler, this is just type info
def Stdlib.Path.tempDir() : String = "/tmp"

// Stdlib.Platform - Platform detection (constant-folded at compile time)

// Check if running on macOS
def Stdlib.Platform.isMacOS() : Bool = false

// Check if running on Linux
def Stdlib.Platform.isLinux() : Bool = false

// Stdlib.String - String operations

// Newline constant (nullary function)
def Stdlib.String.newline() : String = "\n"

// Append two strings
def Stdlib.String.append(s1: String, s2: String) : String = s1 ++ s2

// Prepend first string to second
def Stdlib.String.prepend(s2: String, s1: String) : String = s1 ++ s2

// Get the length of a string in bytes
// String format: [len:8 bytes][data:N bytes]
def Stdlib.String.length(s: String) : Int64 =
    __raw_get<Int64>(__int64_to_rawptr(__string_to_int64(s)), 0)

// Check if string is empty
def Stdlib.String.isEmpty(s: String) : Bool =
    Stdlib.String.length(s) == 0

// Get the byte value at a given index (0-based)
// Returns the byte as an Int64 (0-255)
// String data starts at offset 8 (after the length field)
def Stdlib.String.getByteAt(s: String, index: Int64) : Int64 =
    __raw_get_byte(__int64_to_rawptr(__string_to_int64(s)), index + 8)

// Check if a byte is an ASCII lowercase letter (a-z)
def Stdlib.String.__isLowercase(byte: Int64) : Bool =
    byte >= 97 && byte <= 122

// Check if a byte is an ASCII uppercase letter (A-Z)
def Stdlib.String.__isUppercase(byte: Int64) : Bool =
    byte >= 65 && byte <= 90

// Internal: Compare n bytes starting at positions in two strings
// Returns true if all bytes match
def Stdlib.String.__compareBytes(s1: String, start1: Int64, s2: String, start2: Int64, count: Int64) : Bool =
    if count <= 0 then
        true
    else
        let b1 = Stdlib.String.getByteAt(s1, start1) in
        let b2 = Stdlib.String.getByteAt(s2, start2) in
        if b1 != b2 then
            false
        else
            Stdlib.String.__compareBytes(s1, start1 + 1, s2, start2 + 1, count - 1)

// Check if string starts with prefix
def Stdlib.String.startsWith(s: String, prefix: String) : Bool =
    let sLen = Stdlib.String.length(s) in
    let prefixLen = Stdlib.String.length(prefix) in
    if prefixLen > sLen then
        false
    else
        Stdlib.String.__compareBytes(s, 0, prefix, 0, prefixLen)

// Check if string ends with suffix
def Stdlib.String.endsWith(s: String, suffix: String) : Bool =
    let sLen = Stdlib.String.length(s) in
    let suffixLen = Stdlib.String.length(suffix) in
    if suffixLen > sLen then
        false
    else
        Stdlib.String.__compareBytes(s, sLen - suffixLen, suffix, 0, suffixLen)

// Internal: Find substring starting at offset, returns -1 if not found
def Stdlib.String.__findFrom(s: String, search: String, offset: Int64) : Int64 =
    let sLen = Stdlib.String.length(s) in
    let searchLen = Stdlib.String.length(search) in
    if searchLen == 0 then
        offset  // Empty string is always found at current position
    else if offset + searchLen > sLen then
        -1  // Not enough characters left
    else if Stdlib.String.__compareBytes(s, offset, search, 0, searchLen) then
        offset  // Found match at this position
    else
        Stdlib.String.__findFrom(s, search, offset + 1)

// Find position of first occurrence of search string, returns -1 if not found
def Stdlib.String.indexOf(s: String, search: String) : Int64 =
    Stdlib.String.__findFrom(s, search, 0)

// Check if string contains substring
def Stdlib.String.contains(s: String, search: String) : Bool =
    Stdlib.String.indexOf(s, search) >= 0

// Internal: Copy n bytes from source string to destination raw pointer
def Stdlib.String.__copyBytesToPtr(src: String, srcStart: Int64, dest: RawPtr, destStart: Int64, count: Int64) : Unit =
    if count <= 0 then
        ()
    else
        let byte = Stdlib.String.getByteAt(src, srcStart) in
        let _ = __raw_set_byte(dest, destStart, byte) in
        Stdlib.String.__copyBytesToPtr(src, srcStart + 1, dest, destStart + 1, count - 1)

// Extract substring from start index with given length
// String format: [length:8 bytes][data:N bytes][refcount:8 bytes]
def Stdlib.String.slice(s: String, start: Int64, len: Int64) : String =
    let sLen = Stdlib.String.length(s) in
    // Clamp start and len to valid range
    let actualStart = if start < 0 then 0 else if start > sLen then sLen else start in
    let maxLen = sLen - actualStart in
    let actualLen = if len < 0 then 0 else if len > maxLen then maxLen else len in
    if actualLen == 0 then
        ""
    else
        // Allocate: 8 (length) + actualLen (data) + 8 (refcount) = 16 + actualLen
        let totalSize = 16 + actualLen in
        let ptr = __raw_alloc(totalSize) in
        // Write length at offset 0
        let _ = __raw_set<Int64>(ptr, 0, actualLen) in
        // Copy bytes from source (offset 8 + actualStart) to dest (offset 8)
        let _ = Stdlib.String.__copyBytesToPtr(s, actualStart, ptr, 8, actualLen) in
        // Write refcount = 1 at offset (8 + actualLen)
        let _ = __raw_set<Int64>(ptr, 8 + actualLen, 1) in
        // Convert raw pointer to string
        __int64_to_string(__rawptr_to_int64(ptr))

// Get substring from start to end (excluding end)
def Stdlib.String.substring(s: String, start: Int64, end_: Int64) : String =
    Stdlib.String.slice(s, start, end_ - start)

// Get first n characters
def Stdlib.String.take(s: String, n: Int64) : String =
    Stdlib.String.slice(s, 0, n)

// Drop first n characters
def Stdlib.String.drop(s: String, n: Int64) : String =
    let sLen = Stdlib.String.length(s) in
    Stdlib.String.slice(s, n, sLen - n)

// =============================================================================
// UTF-8 Decoding (for Unicode support)
// =============================================================================

// Decode a single UTF-8 codepoint starting at byteIndex
// Returns (codepoint, bytesConsumed) tuple
// UTF-8 encoding:
//   - 1 byte:  0xxxxxxx (ASCII, 0-127)
//   - 2 bytes: 110xxxxx 10xxxxxx (128-2047)
//   - 3 bytes: 1110xxxx 10xxxxxx 10xxxxxx (2048-65535)
//   - 4 bytes: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx (65536-1114111)
def Stdlib.String.__decodeUtf8At(s: String, byteIndex: Int64) : (Int64, Int64) =
    let b0 = Stdlib.String.getByteAt(s, byteIndex) in
    if b0 < 128 then
        // 1-byte (ASCII): 0xxxxxxx
        (b0, 1)
    else if b0 < 224 then
        // 2-byte: 110xxxxx 10xxxxxx
        let b1 = Stdlib.String.getByteAt(s, byteIndex + 1) in
        let cp = ((b0 & 31) << 6) ^ (b1 & 63) in
        (cp, 2)
    else if b0 < 240 then
        // 3-byte: 1110xxxx 10xxxxxx 10xxxxxx
        let b1 = Stdlib.String.getByteAt(s, byteIndex + 1) in
        let b2 = Stdlib.String.getByteAt(s, byteIndex + 2) in
        let cp = ((b0 & 15) << 12) ^ ((b1 & 63) << 6) ^ (b2 & 63) in
        (cp, 3)
    else
        // 4-byte: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        let b1 = Stdlib.String.getByteAt(s, byteIndex + 1) in
        let b2 = Stdlib.String.getByteAt(s, byteIndex + 2) in
        let b3 = Stdlib.String.getByteAt(s, byteIndex + 3) in
        let cp = ((b0 & 7) << 18) ^ ((b1 & 63) << 12) ^ ((b2 & 63) << 6) ^ (b3 & 63) in
        (cp, 4)

// Convert a string to a list of Unicode codepoints
def Stdlib.String.toCodepoints(s: String) : List<Int64> =
    Stdlib.String.__toCodepointsHelper(s, 0, Stdlib.String.length(s), [])

// Helper: recursively decode codepoints
def Stdlib.String.__toCodepointsHelper(s: String, byteIndex: Int64, byteLen: Int64, acc: List<Int64>) : List<Int64> =
    if byteIndex >= byteLen then
        Stdlib.List.reverse<Int64>(acc)
    else
        let result = Stdlib.String.__decodeUtf8At(s, byteIndex) in
        let cp = Stdlib.Tuple2.first<Int64, Int64>(result) in
        let consumed = Stdlib.Tuple2.second<Int64, Int64>(result) in
        Stdlib.String.__toCodepointsHelper(s, byteIndex + consumed, byteLen, [cp, ...acc])

// Get the number of codepoints in a string (not bytes)
def Stdlib.String.codepointLength(s: String) : Int64 =
    Stdlib.List.length<Int64>(Stdlib.String.toCodepoints(s))

// =============================================================================
// UTF-8 Encoding (codepoints to string)
// =============================================================================

// Calculate UTF-8 byte length for a single codepoint
def Stdlib.String.__utf8ByteLen(cp: Int64) : Int64 =
    if cp < 128 then 1
    else if cp < 2048 then 2
    else if cp < 65536 then 3
    else 4

// Calculate total UTF-8 byte length for a list of codepoints
def Stdlib.String.__totalUtf8Len(cps: List<Int64>) : Int64 =
    Stdlib.List.fold<Int64, Int64>(cps, 0, (acc: Int64, cp: Int64) => acc + Stdlib.String.__utf8ByteLen(cp))

// Encode a single codepoint to UTF-8 bytes at given offset, return new offset
def Stdlib.String.__encodeUtf8At(ptr: RawPtr, offset: Int64, cp: Int64) : Int64 =
    if cp < 128 then
        // 1-byte: 0xxxxxxx
        let _ = __raw_set_byte(ptr, offset, cp) in
        offset + 1
    else if cp < 2048 then
        // 2-byte: 110xxxxx 10xxxxxx
        let b0 = 192 ^ (cp >> 6) in
        let b1 = 128 ^ (cp & 63) in
        let _ = __raw_set_byte(ptr, offset, b0) in
        let _ = __raw_set_byte(ptr, offset + 1, b1) in
        offset + 2
    else if cp < 65536 then
        // 3-byte: 1110xxxx 10xxxxxx 10xxxxxx
        let b0 = 224 ^ (cp >> 12) in
        let b1 = 128 ^ ((cp >> 6) & 63) in
        let b2 = 128 ^ (cp & 63) in
        let _ = __raw_set_byte(ptr, offset, b0) in
        let _ = __raw_set_byte(ptr, offset + 1, b1) in
        let _ = __raw_set_byte(ptr, offset + 2, b2) in
        offset + 3
    else
        // 4-byte: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        let b0 = 240 ^ (cp >> 18) in
        let b1 = 128 ^ ((cp >> 12) & 63) in
        let b2 = 128 ^ ((cp >> 6) & 63) in
        let b3 = 128 ^ (cp & 63) in
        let _ = __raw_set_byte(ptr, offset, b0) in
        let _ = __raw_set_byte(ptr, offset + 1, b1) in
        let _ = __raw_set_byte(ptr, offset + 2, b2) in
        let _ = __raw_set_byte(ptr, offset + 3, b3) in
        offset + 4

// Encode all codepoints starting at offset
def Stdlib.String.__encodeCodepointsAt(ptr: RawPtr, offset: Int64, cps: List<Int64>) : Int64 =
    match cps with
    | [] -> offset
    | [cp, ...rest] ->
        let newOffset = Stdlib.String.__encodeUtf8At(ptr, offset, cp) in
        Stdlib.String.__encodeCodepointsAt(ptr, newOffset, rest)

// Build a string from a list of Unicode codepoints
// String format: [length:8 bytes][data:N bytes][refcount:8 bytes]
def Stdlib.String.fromCodepoints(cps: List<Int64>) : String =
    let byteLen = Stdlib.String.__totalUtf8Len(cps) in
    if byteLen == 0 then
        ""
    else
        // Allocate: 8 (length) + byteLen (data) + 8 (refcount)
        let totalSize = 16 + byteLen in
        let ptr = __raw_alloc(totalSize) in
        // Write length at offset 0
        let _ = __raw_set<Int64>(ptr, 0, byteLen) in
        // Encode codepoints starting at offset 8
        let _ = Stdlib.String.__encodeCodepointsAt(ptr, 8, cps) in
        // Write refcount = 1 at end
        let _ = __raw_set<Int64>(ptr, 8 + byteLen, 1) in
        __int64_to_string(__rawptr_to_int64(ptr))

// =============================================================================
// Case Mapping Functions (ASCII fast path, with Unicode table fallback)
// =============================================================================

// Map ASCII lowercase to uppercase (a-z -> A-Z)
def Stdlib.String.__asciiToUpper(cp: Int64) : Int64 =
    if cp >= 97 && cp <= 122 then cp - 32 else cp

// Map ASCII uppercase to lowercase (A-Z -> a-z)
def Stdlib.String.__asciiToLower(cp: Int64) : Int64 =
    if cp >= 65 && cp <= 90 then cp + 32 else cp

// Helper: map codepoints to uppercase ASCII (simple version)
def Stdlib.String.__mapUpperAscii(cps: List<Int64>, acc: List<Int64>) : List<Int64> =
    match cps with
    | [] -> Stdlib.List.reverse<Int64>(acc)
    | [cp, ...rest] ->
        let upper = Stdlib.String.__asciiToUpper(cp) in
        Stdlib.String.__mapUpperAscii(rest, [upper, ...acc])

// Helper: map codepoints to lowercase ASCII (simple version)
def Stdlib.String.__mapLowerAscii(cps: List<Int64>, acc: List<Int64>) : List<Int64> =
    match cps with
    | [] -> Stdlib.List.reverse<Int64>(acc)
    | [cp, ...rest] ->
        let lower = Stdlib.String.__asciiToLower(cp) in
        Stdlib.String.__mapLowerAscii(rest, [lower, ...acc])

// Convert string to uppercase (ASCII only for now)
def Stdlib.String.toUpperCase(s: String) : String =
    let codepoints = Stdlib.String.toCodepoints(s) in
    let upper = Stdlib.String.__mapUpperAscii(codepoints, []) in
    Stdlib.String.fromCodepoints(upper)

// Convert string to lowercase (ASCII only for now)
def Stdlib.String.toLowerCase(s: String) : String =
    let codepoints = Stdlib.String.toCodepoints(s) in
    let lower = Stdlib.String.__mapLowerAscii(codepoints, []) in
    Stdlib.String.fromCodepoints(lower)

// =============================================================================
// Grapheme Cluster Segmentation (simplified UAX #29)
// =============================================================================
// Grapheme break categories (simplified):
// - CR (13), LF (10): newline handling
// - ZWJ (8205): zero-width joiner for emoji sequences
// - Extend: combining marks, variation selectors, skin tone modifiers

// Check if codepoint is a combining/extending character
def Stdlib.String.__isExtend(cp: Int64) : Bool =
    // Combining Diacritical Marks (0300-036F)
    (cp >= 768 && cp <= 879) ||
    // Variation Selectors (FE00-FE0F)
    (cp >= 65024 && cp <= 65039) ||
    // Combining Diacritical Marks Extended (1AB0-1AFF)
    (cp >= 6832 && cp <= 6911) ||
    // Combining Half Marks (FE20-FE2F)
    (cp >= 65056 && cp <= 65071) ||
    // Emoji Fitzpatrick modifiers (skin tones) (1F3FB-1F3FF)
    (cp >= 127995 && cp <= 127999) ||
    // Emoji component (hair styles, etc) - simplified range
    (cp >= 127988 && cp <= 127988)

// Check if codepoint is ZWJ (Zero Width Joiner)
def Stdlib.String.__isZWJ(cp: Int64) : Bool = cp == 8205

// Segment codepoints into grapheme clusters
// Returns list of codepoint lists (each inner list is one grapheme)
def Stdlib.String.__segmentGraphemes(cps: List<Int64>, current: List<Int64>, result: List<List<Int64>>) : List<List<Int64>> =
    match cps with
    | [] ->
        // End of input - add current grapheme if non-empty
        if Stdlib.List.isEmpty<Int64>(current) then
            Stdlib.List.reverse<List<Int64>>(result)
        else
            Stdlib.List.reverse<List<Int64>>([Stdlib.List.reverse<Int64>(current), ...result])
    | [cp, ...rest] ->
        if Stdlib.List.isEmpty<Int64>(current) then
            // Start new grapheme
            Stdlib.String.__segmentGraphemes(rest, [cp], result)
        else if Stdlib.String.__isExtend(cp) || Stdlib.String.__isZWJ(cp) then
            // Extend current grapheme
            Stdlib.String.__segmentGraphemes(rest, [cp, ...current], result)
        else if cp == 10 then
            // LF - check if preceded by CR
            match current with
            | [13] ->
                // CR + LF = single grapheme
                Stdlib.String.__segmentGraphemes(rest, [], [Stdlib.List.reverse<Int64>([cp, ...current]), ...result])
            | _ ->
                // LF alone - end current, LF is its own grapheme
                Stdlib.String.__segmentGraphemes(rest, [], [[cp], Stdlib.List.reverse<Int64>(current), ...result])
        else
            // New base character - end current grapheme, start new one
            Stdlib.String.__segmentGraphemes(rest, [cp], [Stdlib.List.reverse<Int64>(current), ...result])

// Convert a list of codepoints to a string
def Stdlib.String.__codepointsToString(cps: List<Int64>) : String =
    Stdlib.String.fromCodepoints(cps)

// Convert string to list of grapheme clusters (each as a string)
def Stdlib.String.toGraphemes(s: String) : List<String> =
    let cps = Stdlib.String.toCodepoints(s) in
    let segments = Stdlib.String.__segmentGraphemes(cps, [], []) in
    Stdlib.List.map<List<Int64>, String>(segments, Stdlib.String.__codepointsToString)

// Get number of grapheme clusters in a string
def Stdlib.String.graphemeLength(s: String) : Int64 =
    Stdlib.List.length<String>(Stdlib.String.toGraphemes(s))

// =============================================================================
// High-Level String API
// =============================================================================

// Repeat a string n times
def Stdlib.String.repeat(s: String, n: Int64) : String =
    if n <= 0 then ""
    else if n == 1 then s
    else s ++ Stdlib.String.repeat(s, n - 1)

// Join a list of strings with a separator
def Stdlib.String.join(strs: List<String>, sep: String) : String =
    match strs with
    | [] -> ""
    | [only] -> only
    | [first, ...rest] -> first ++ sep ++ Stdlib.String.join(rest, sep)

// Check if byte is ASCII whitespace (space, tab, newline, carriage return)
def Stdlib.String.__isWhitespace(b: Int64) : Bool =
    b == 32 || b == 9 || b == 10 || b == 13

// Trim leading whitespace
def Stdlib.String.trimStart(s: String) : String =
    let len = Stdlib.String.length(s) in
    Stdlib.String.__trimStartHelper(s, 0, len)

def Stdlib.String.__trimStartHelper(s: String, i: Int64, len: Int64) : String =
    if i >= len then ""
    else if Stdlib.String.__isWhitespace(Stdlib.String.getByteAt(s, i)) then
        Stdlib.String.__trimStartHelper(s, i + 1, len)
    else
        Stdlib.String.drop(s, i)

// Trim trailing whitespace
def Stdlib.String.trimEnd(s: String) : String =
    let len = Stdlib.String.length(s) in
    Stdlib.String.__trimEndHelper(s, len - 1)

def Stdlib.String.__trimEndHelper(s: String, i: Int64) : String =
    if i < 0 then ""
    else if Stdlib.String.__isWhitespace(Stdlib.String.getByteAt(s, i)) then
        Stdlib.String.__trimEndHelper(s, i - 1)
    else
        Stdlib.String.take(s, i + 1)

// Trim both leading and trailing whitespace
def Stdlib.String.trim(s: String) : String =
    Stdlib.String.trimEnd(Stdlib.String.trimStart(s))

// Split string by delimiter (simple byte-based)
// Empty delimiter splits into individual bytes
def Stdlib.String.split(s: String, delim: String) : List<String> =
    if Stdlib.String.isEmpty(delim) then
        // Empty delimiter: split into individual bytes
        Stdlib.String.__splitIntoBytes(s, 0, [])
    else
        Stdlib.String.__splitHelper(s, delim, 0, [])

def Stdlib.String.__splitIntoBytes(s: String, idx: Int64, acc: List<String>) : List<String> =
    if idx >= Stdlib.String.length(s) then
        Stdlib.List.reverse<String>(acc)
    else
        let byte = Stdlib.String.substring(s, idx, idx + 1) in
        Stdlib.String.__splitIntoBytes(s, idx + 1, [byte, ...acc])

def Stdlib.String.__splitHelper(s: String, delim: String, start: Int64, acc: List<String>) : List<String> =
    let sLen = Stdlib.String.length(s) in
    let delimLen = Stdlib.String.length(delim) in
    if start > sLen then
        Stdlib.List.reverse<String>(acc)
    else
        let idx = Stdlib.String.__findFrom(s, delim, start) in
        if idx < 0 then
            // No more delimiters - add rest of string
            Stdlib.List.reverse<String>([Stdlib.String.drop(s, start), ...acc])
        else
            // Found delimiter - add segment and continue
            let segment = Stdlib.String.substring(s, start, idx) in
            Stdlib.String.__splitHelper(s, delim, idx + delimLen, [segment, ...acc])

// Replace all occurrences of old with new
// Empty old string inserts new at every position (including boundaries)
def Stdlib.String.replace(s: String, old: String, new: String) : String =
    if Stdlib.String.isEmpty(old) then
        // Insert new at every position: before each char and after last
        Stdlib.String.__replaceEmpty(s, new, 0, new)
    else
        Stdlib.String.join(Stdlib.String.split(s, old), new)

def Stdlib.String.__replaceEmpty(s: String, new: String, idx: Int64, acc: String) : String =
    if idx >= Stdlib.String.length(s) then
        acc
    else
        let byte = Stdlib.String.substring(s, idx, idx + 1) in
        Stdlib.String.__replaceEmpty(s, new, idx + 1, acc ++ byte ++ new)

// Reverse a string (byte-based, works for ASCII)
def Stdlib.String.reverse(s: String) : String =
    let cps = Stdlib.String.toCodepoints(s) in
    Stdlib.String.fromCodepoints(Stdlib.List.reverse<Int64>(cps))

// Check if string equals another (byte comparison)
def Stdlib.String.equals(s1: String, s2: String) : Bool =
    let len1 = Stdlib.String.length(s1) in
    let len2 = Stdlib.String.length(s2) in
    if len1 != len2 then false
    else Stdlib.String.__compareBytes(s1, 0, s2, 0, len1)

// Get first n bytes (alias for take)
def Stdlib.String.first(s: String, n: Int64) : String =
    Stdlib.String.take(s, n)

// Get last n bytes
def Stdlib.String.last(s: String, n: Int64) : String =
    let len = Stdlib.String.length(s) in
    if n <= 0 then ""
    else if n >= len then s
    else Stdlib.String.drop(s, len - n)

// Drop first n bytes (alias for drop)
def Stdlib.String.dropFirst(s: String, n: Int64) : String =
    Stdlib.String.drop(s, n)

// Drop last n bytes
def Stdlib.String.dropLast(s: String, n: Int64) : String =
    let len = Stdlib.String.length(s) in
    if n <= 0 then s
    else if n >= len then ""
    else Stdlib.String.take(s, len - n)

// Get first character as Option (grapheme-aware)
def Stdlib.String.head(s: String) : Stdlib.Option.Option<String> =
    if Stdlib.String.length(s) == 0 then
        None
    else
        Some(Stdlib.String.take(s, 1))

// Pad string on the left to reach target length
// Uses byte-based length for simplicity
def Stdlib.String.padStart(s: String, targetLen: Int64, padChar: String) : String =
    let len = Stdlib.String.length(s) in
    let padLen = Stdlib.String.length(padChar) in
    if len >= targetLen then s
    else if padLen == 0 then s
    else
        let needed = targetLen - len in
        let numPads = needed / padLen in
        let remainder = needed % padLen in
        let fullPad = Stdlib.String.repeat(padChar, numPads) in
        let partialPad = Stdlib.String.take(padChar, remainder) in
        fullPad ++ partialPad ++ s

// Pad string on the right to reach target length
def Stdlib.String.padEnd(s: String, targetLen: Int64, padChar: String) : String =
    let len = Stdlib.String.length(s) in
    let padLen = Stdlib.String.length(padChar) in
    if len >= targetLen then s
    else if padLen == 0 then s
    else
        let needed = targetLen - len in
        let numPads = needed / padLen in
        let remainder = needed % padLen in
        let fullPad = Stdlib.String.repeat(padChar, numPads) in
        let partialPad = Stdlib.String.take(padChar, remainder) in
        s ++ fullPad ++ partialPad


// =============================================================================
// Stdlib.Dict - Immutable Dictionary using HAMT (Hash Array Mapped Trie)
// =============================================================================

// HAMT internal helper functions for working with bitmaps
// These are the building blocks for the Dict implementation

// Get 6-bit chunk of hash at given level (0-10)
// For a 64-bit hash, there are up to 11 levels (6 bits per level)
def Stdlib.Dict.hashChunk(hash: Int64, level: Int64) : Int64 =
    (hash >> (level * 6)) & 63

// Check if bit is set in bitmap
def Stdlib.Dict.hasBit(bitmap: Int64, bit: Int64) : Bool =
    ((bitmap >> bit) & 1) == 1

// Count bits below position in bitmap (for compressed array index)
def Stdlib.Dict.childIndex(bitmap: Int64, bit: Int64) : Int64 =
    Stdlib.Int64.popcount(bitmap & ((1 << bit) - 1))

// Set a bit in bitmap
def Stdlib.Dict.setBit(bitmap: Int64, bit: Int64) : Int64 =
    bitmap ^ (1 << bit)

// Clear a bit in bitmap (for remove)
// Note: ~x = (-1) ^ x (XOR with all ones)
def Stdlib.Dict.clearBit(bitmap: Int64, bit: Int64) : Int64 =
    bitmap & (((0 - 1)) ^ (1 << bit))

// =============================================================================
// Pointer tagging helpers
// =============================================================================
// We use the low 2 bits of pointers for tags (since 8-byte alignment gives us 3 free bits)
// Tag 0: Empty (NULL)
// Tag 1: Internal node (bitmap + children)
// Tag 2: Leaf node (key + value)
// Tag 3: Collision node (multiple entries with same hash prefix) - not yet implemented

// Get tag from a tagged pointer
def Stdlib.Dict.__getTag<k, v>(dict: Dict<k, v>) : Int64 =
    __dict_get_tag<k, v>(dict)

// Clear tag bits to get actual pointer (returns RawPtr)
def Stdlib.Dict.__clearTag<k, v>(dict: Dict<k, v>) : RawPtr =
    __dict_to_rawptr<k, v>(dict)

// Set tag on a pointer to create a Dict
def Stdlib.Dict.__setTag<k, v>(ptr: RawPtr, tag: Int64) : Dict<k, v> =
    __rawptr_to_dict<k, v>(ptr, tag)

// Allocate a leaf node: [key:8][value:8] = 16 bytes
def Stdlib.Dict.__allocLeaf<k, v>(key: k, value: v) : Dict<k, v> =
    let ptr = __raw_alloc(16) in
    let _ = __raw_set<k>(ptr, 0, key) in
    let _ = __raw_set<v>(ptr, 8, value) in
    Stdlib.Dict.__setTag<k, v>(ptr, 2)

// Allocate an internal node: [bitmap:8][children...] = 8 + 8*numChildren bytes
def Stdlib.Dict.__allocInternal(bitmap: Int64, numChildren: Int64) : RawPtr =
    let ptr = __raw_alloc(8 + (numChildren * 8)) in
    let _ = __raw_set<Int64>(ptr, 0, bitmap) in
    ptr

// =============================================================================
// Dict.empty - returns an empty dictionary
// =============================================================================
// Empty is represented as 0 (NULL with tag 0)
def Stdlib.Dict.empty<k, v>() : Dict<k, v> = __empty_dict<k, v>()

// =============================================================================
// Dict.get - lookup a key in the dictionary
// =============================================================================
// Returns Some(value) if found, None if not found

// Get helper - recursive lookup
// Note: keyHash is pre-computed hash of the key (for efficiency with string keys)
def Stdlib.Dict.__getHelper<k, v>(node: Dict<k, v>, key: k, keyHash: Int64, level: Int64) : Stdlib.Option.Option<v> =
    if __dict_is_null<k, v>(node) then
        None
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            // Leaf node
            let storedKey = __raw_get<k>(ptr, 0) in
            if __key_eq<k>(storedKey, key) then
                Some(__raw_get<v>(ptr, 8))
            else
                None
        else if tag == 1 then
            // Internal node
            let chunk = Stdlib.Dict.hashChunk(keyHash, level) in
            let bitmap = __raw_get<Int64>(ptr, 0) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
                let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
                Stdlib.Dict.__getHelper<k, v>(child, key, keyHash, level + 1)
            else
                None
        else
            // Unknown tag (collision node not yet implemented)
            None

def Stdlib.Dict.get<k, v>(dict: Dict<k, v>, key: k) : Stdlib.Option.Option<v> =
    Stdlib.Dict.__getHelper<k, v>(dict, key, __hash<k>(key), 0)

// =============================================================================
// Dict.set - insert or update a key-value pair
// =============================================================================
// Returns a new dictionary with the key-value pair added/updated

// Set helper - recursive insert
// Note: keyHash is pre-computed hash of the key (for efficiency with string keys)
def Stdlib.Dict.__setHelper<k, v>(node: Dict<k, v>, key: k, keyHash: Int64, value: v, level: Int64) : Dict<k, v> =
    if __dict_is_null<k, v>(node) then
        // Empty - create a new leaf
        Stdlib.Dict.__allocLeaf<k, v>(key, value)
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            // Leaf node - check if same key or need to expand
            let storedKey = __raw_get<k>(ptr, 0) in
            if __key_eq<k>(storedKey, key) then
                // Same key - replace value (create new leaf)
                Stdlib.Dict.__allocLeaf<k, v>(key, value)
            else
                // Different key - need to expand to internal node
                let storedValue = __raw_get<v>(ptr, 8) in
                let storedKeyHash = __hash<k>(storedKey) in
                Stdlib.Dict.__expandLeaf<k, v>(storedKey, storedKeyHash, storedValue, key, keyHash, value, level)
        else if tag == 1 then
            // Internal node - recurse into appropriate child
            let chunk = Stdlib.Dict.hashChunk(keyHash, level) in
            let bitmap = __raw_get<Int64>(ptr, 0) in
            let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                // Child exists - update it
                let oldChild = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
                let newChild = Stdlib.Dict.__setHelper<k, v>(oldChild, key, keyHash, value, level + 1) in
                Stdlib.Dict.__copyInternalWithUpdate<k, v>(ptr, bitmap, idx, newChild)
            else
                // No child at this position - insert new leaf
                let newLeaf = Stdlib.Dict.__allocLeaf<k, v>(key, value) in
                let newBitmap = Stdlib.Dict.setBit(bitmap, chunk) in
                Stdlib.Dict.__copyInternalWithInsert<k, v>(ptr, bitmap, newBitmap, idx, newLeaf)
        else
            // Unknown tag - return node unchanged
            node

// Expand a leaf to an internal node when two keys collide
def Stdlib.Dict.__expandLeaf<k, v>(key1: k, key1Hash: Int64, val1: v, key2: k, key2Hash: Int64, val2: v, level: Int64) : Dict<k, v> =
    let chunk1 = Stdlib.Dict.hashChunk(key1Hash, level) in
    let chunk2 = Stdlib.Dict.hashChunk(key2Hash, level) in
    if chunk1 == chunk2 then
        // Same chunk - need to go deeper
        if level >= 10 then
            // Max depth reached - just keep key2 (overwrites key1)
            // TODO: Implement collision nodes
            Stdlib.Dict.__allocLeaf<k, v>(key2, val2)
        else
            // Create internal node with single child (recursive case)
            let child = Stdlib.Dict.__expandLeaf<k, v>(key1, key1Hash, val1, key2, key2Hash, val2, level + 1) in
            let bitmap = Stdlib.Dict.setBit(0, chunk1) in
            let newNode = Stdlib.Dict.__allocInternal(bitmap, 1) in
            let _ = __raw_set<Dict<k, v>>(newNode, 8, child) in
            Stdlib.Dict.__setTag<k, v>(newNode, 1)
    else
        // Different chunks - create internal node with both leaves
        let leaf1 = Stdlib.Dict.__allocLeaf<k, v>(key1, val1) in
        let leaf2 = Stdlib.Dict.__allocLeaf<k, v>(key2, val2) in
        let bitmap = Stdlib.Dict.setBit(Stdlib.Dict.setBit(0, chunk1), chunk2) in
        let newNode = Stdlib.Dict.__allocInternal(bitmap, 2) in
        // Store children in order of their chunks
        if chunk1 < chunk2 then
            let _ = __raw_set<Dict<k, v>>(newNode, 8, leaf1) in
            let _ = __raw_set<Dict<k, v>>(newNode, 16, leaf2) in
            Stdlib.Dict.__setTag<k, v>(newNode, 1)
        else
            let _ = __raw_set<Dict<k, v>>(newNode, 8, leaf2) in
            let _ = __raw_set<Dict<k, v>>(newNode, 16, leaf1) in
            Stdlib.Dict.__setTag<k, v>(newNode, 1)

// Copy internal node with one child updated
def Stdlib.Dict.__copyInternalWithUpdate<k, v>(oldPtr: RawPtr, bitmap: Int64, updateIdx: Int64, newChild: Dict<k, v>) : Dict<k, v> =
    let numChildren = Stdlib.Int64.popcount(bitmap) in
    let newNode = Stdlib.Dict.__allocInternal(bitmap, numChildren) in
    // Copy all children, replacing the one at updateIdx
    Stdlib.Dict.__copyChildren<k, v>(oldPtr, newNode, numChildren, updateIdx, newChild, 0)

// Copy children from old node to new node, updating one
def Stdlib.Dict.__copyChildren<k, v>(oldPtr: RawPtr, newPtr: RawPtr, numChildren: Int64, updateIdx: Int64, newChild: Dict<k, v>, i: Int64) : Dict<k, v> =
    if i >= numChildren then
        Stdlib.Dict.__setTag<k, v>(newPtr, 1)
    else
        let offset = 8 + (i * 8) in
        if i == updateIdx then
            let _ = __raw_set<Dict<k, v>>(newPtr, offset, newChild) in
            Stdlib.Dict.__copyChildren<k, v>(oldPtr, newPtr, numChildren, updateIdx, newChild, i + 1)
        else
            let child = __raw_get<Dict<k, v>>(oldPtr, offset) in
            let _ = __raw_set<Dict<k, v>>(newPtr, offset, child) in
            Stdlib.Dict.__copyChildren<k, v>(oldPtr, newPtr, numChildren, updateIdx, newChild, i + 1)

// Copy internal node with a new child inserted at position
def Stdlib.Dict.__copyInternalWithInsert<k, v>(oldPtr: RawPtr, oldBitmap: Int64, newBitmap: Int64, insertIdx: Int64, newChild: Dict<k, v>) : Dict<k, v> =
    let oldNumChildren = Stdlib.Int64.popcount(oldBitmap) in
    let newNumChildren = oldNumChildren + 1 in
    let newNode = Stdlib.Dict.__allocInternal(newBitmap, newNumChildren) in
    // Copy children, inserting new one at insertIdx
    Stdlib.Dict.__copyChildrenWithInsert<k, v>(oldPtr, newNode, oldNumChildren, insertIdx, newChild, 0, 0)

// Copy children from old node to new node, inserting one
def Stdlib.Dict.__copyChildrenWithInsert<k, v>(oldPtr: RawPtr, newPtr: RawPtr, oldNumChildren: Int64, insertIdx: Int64, newChild: Dict<k, v>, oldI: Int64, newI: Int64) : Dict<k, v> =
    if newI == insertIdx then
        // Insert the new child here
        let offset = 8 + (newI * 8) in
        let _ = __raw_set<Dict<k, v>>(newPtr, offset, newChild) in
        Stdlib.Dict.__copyChildrenWithInsert<k, v>(oldPtr, newPtr, oldNumChildren, insertIdx, newChild, oldI, newI + 1)
    else if oldI >= oldNumChildren then
        Stdlib.Dict.__setTag<k, v>(newPtr, 1)
    else
        // Copy from old node
        let oldOffset = 8 + (oldI * 8) in
        let newOffset = 8 + (newI * 8) in
        let child = __raw_get<Dict<k, v>>(oldPtr, oldOffset) in
        let _ = __raw_set<Dict<k, v>>(newPtr, newOffset, child) in
        Stdlib.Dict.__copyChildrenWithInsert<k, v>(oldPtr, newPtr, oldNumChildren, insertIdx, newChild, oldI + 1, newI + 1)

def Stdlib.Dict.set<k, v>(dict: Dict<k, v>, key: k, value: v) : Dict<k, v> =
    Stdlib.Dict.__setHelper<k, v>(dict, key, __hash<k>(key), value, 0)

// =============================================================================
// Dict.remove - remove a key from the dictionary
// =============================================================================
// Returns a new dictionary without the key (or unchanged if key not present)

// Copy internal node excluding one child
def Stdlib.Dict.__copyChildrenExcluding<k, v>(oldPtr: RawPtr, newPtr: RawPtr, oldNumChildren: Int64, excludeIdx: Int64, oldI: Int64, newI: Int64) : Dict<k, v> =
    if oldI >= oldNumChildren then
        Stdlib.Dict.__setTag<k, v>(newPtr, 1)
    else if oldI == excludeIdx then
        // Skip this child
        Stdlib.Dict.__copyChildrenExcluding<k, v>(oldPtr, newPtr, oldNumChildren, excludeIdx, oldI + 1, newI)
    else
        // Copy this child
        let oldOffset = 8 + (oldI * 8) in
        let newOffset = 8 + (newI * 8) in
        let child = __raw_get<Dict<k, v>>(oldPtr, oldOffset) in
        let _ = __raw_set<Dict<k, v>>(newPtr, newOffset, child) in
        Stdlib.Dict.__copyChildrenExcluding<k, v>(oldPtr, newPtr, oldNumChildren, excludeIdx, oldI + 1, newI + 1)

// Copy internal node with one child removed
def Stdlib.Dict.__copyInternalWithRemove<k, v>(oldPtr: RawPtr, oldBitmap: Int64, newBitmap: Int64, removeIdx: Int64) : Dict<k, v> =
    let oldNumChildren = Stdlib.Int64.popcount(oldBitmap) in
    let newNumChildren = oldNumChildren - 1 in
    if newNumChildren == 0 then
        // No children left - return empty
        __empty_dict<k, v>()
    else
        let newNode = Stdlib.Dict.__allocInternal(newBitmap, newNumChildren) in
        Stdlib.Dict.__copyChildrenExcluding<k, v>(oldPtr, newNode, oldNumChildren, removeIdx, 0, 0)

// Remove helper - recursive removal
def Stdlib.Dict.__removeHelper<k, v>(node: Dict<k, v>, key: k, keyHash: Int64, level: Int64) : Dict<k, v> =
    if __dict_is_null<k, v>(node) then
        // Empty - key not found, return empty
        __empty_dict<k, v>()
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            // Leaf node
            let storedKey = __raw_get<k>(ptr, 0) in
            if __key_eq<k>(storedKey, key) then
                // Found the key - return empty to remove it
                __empty_dict<k, v>()
            else
                // Different key - not found, return unchanged
                node
        else if tag == 1 then
            // Internal node
            let chunk = Stdlib.Dict.hashChunk(keyHash, level) in
            let bitmap = __raw_get<Int64>(ptr, 0) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
                let oldChild = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
                let newChild = Stdlib.Dict.__removeHelper<k, v>(oldChild, key, keyHash, level + 1) in
                if __dict_is_null<k, v>(newChild) then
                    // Child was removed - need to update this node
                    let numChildren = Stdlib.Int64.popcount(bitmap) in
                    if numChildren == 1 then
                        // This was the only child - return empty
                        __empty_dict<k, v>()
                    else if numChildren == 2 then
                        // Two children, one being removed - check if we can collapse
                        // Get the other child index (0 if we're removing 1, 1 if removing 0)
                        let otherIdx = 1 - idx in
                        let otherChild = __raw_get<Dict<k, v>>(ptr, 8 + (otherIdx * 8)) in
                        let otherTag = Stdlib.Dict.__getTag<k, v>(otherChild) in
                        if otherTag == 2 then
                            // Other child is a leaf - collapse to it
                            otherChild
                        else
                            // Other child is internal - can't collapse, create new node
                            let newBitmap = Stdlib.Dict.clearBit(bitmap, chunk) in
                            Stdlib.Dict.__copyInternalWithRemove<k, v>(ptr, bitmap, newBitmap, idx)
                    else
                        // More than 2 children - create new node without removed child
                        let newBitmap = Stdlib.Dict.clearBit(bitmap, chunk) in
                        Stdlib.Dict.__copyInternalWithRemove<k, v>(ptr, bitmap, newBitmap, idx)
                else
                    // Child was modified (but not removed) - update
                    Stdlib.Dict.__copyInternalWithUpdate<k, v>(ptr, bitmap, idx, newChild)
            else
                // Bit not set - key not in this subtree
                node
        else
            // Unknown tag - return unchanged
            node

def Stdlib.Dict.remove<k, v>(dict: Dict<k, v>, key: k) : Dict<k, v> =
    Stdlib.Dict.__removeHelper<k, v>(dict, key, __hash<k>(key), 0)


// =============================================================================
// Dict Utility Functions (Generic)
// =============================================================================

// Check if dict is empty
def Stdlib.Dict.isEmpty<k, v>(dict: Dict<k, v>) : Bool =
    __dict_is_null<k, v>(dict)

// Check if dict contains a key
def Stdlib.Dict.contains<k, v>(dict: Dict<k, v>, key: k) : Bool =
    Stdlib.Dict.__containsHelper<k, v>(dict, key, __hash<k>(key), 0)

def Stdlib.Dict.__containsHelper<k, v>(node: Dict<k, v>, key: k, keyHash: Int64, level: Int64) : Bool =
    if __dict_is_null<k, v>(node) then
        false
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            // Leaf node
            let storedKey = __raw_get<k>(ptr, 0) in
            __key_eq<k>(storedKey, key)
        else if tag == 1 then
            // Internal node
            let chunk = Stdlib.Dict.hashChunk(keyHash, level) in
            let bitmap = __raw_get<Int64>(ptr, 0) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
                let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
                Stdlib.Dict.__containsHelper<k, v>(child, key, keyHash, level + 1)
            else
                false
        else
            false

// Count entries in dict
def Stdlib.Dict.size<k, v>(dict: Dict<k, v>) : Int64 =
    Stdlib.Dict.__sizeHelper<k, v>(dict)

def Stdlib.Dict.__sizeHelper<k, v>(node: Dict<k, v>) : Int64 =
    if __dict_is_null<k, v>(node) then
        0
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            1
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__countChildren<k, v>(ptr, bitmap, 0)
        else
            0

def Stdlib.Dict.__countChildren<k, v>(ptr: RawPtr, bitmap: Int64, idx: Int64) : Int64 =
    if bitmap == 0 then
        0
    else
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        Stdlib.Dict.__sizeHelper<k, v>(child) + Stdlib.Dict.__countChildren<k, v>(ptr, bitmap & (bitmap - 1), idx + 1)

// =============================================================================
// Dict Enumeration (Generic)
// =============================================================================

// Get all keys from dict
def Stdlib.Dict.keys<k, v>(dict: Dict<k, v>) : List<k> =
    Stdlib.Dict.__keysHelper<k, v>(dict, [])

def Stdlib.Dict.__keysHelper<k, v>(node: Dict<k, v>, acc: List<k>) : List<k> =
    if __dict_is_null<k, v>(node) then
        acc
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            [key, ...acc]
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__collectKeysFromChildren<k, v>(ptr, bitmap, 0, acc)
        else
            acc

def Stdlib.Dict.__collectKeysFromChildren<k, v>(ptr: RawPtr, bitmap: Int64, idx: Int64, acc: List<k>) : List<k> =
    if bitmap == 0 then
        acc
    else
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__keysHelper<k, v>(child, acc) in
        Stdlib.Dict.__collectKeysFromChildren<k, v>(ptr, bitmap & (bitmap - 1), idx + 1, newAcc)

// Get all values from dict
def Stdlib.Dict.values<k, v>(dict: Dict<k, v>) : List<v> =
    Stdlib.Dict.__valuesHelper<k, v>(dict, [])

def Stdlib.Dict.__valuesHelper<k, v>(node: Dict<k, v>, acc: List<v>) : List<v> =
    if __dict_is_null<k, v>(node) then
        acc
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let value = __raw_get<v>(ptr, 8) in
            [value, ...acc]
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__collectValuesFromChildren<k, v>(ptr, bitmap, 0, acc)
        else
            acc

def Stdlib.Dict.__collectValuesFromChildren<k, v>(ptr: RawPtr, bitmap: Int64, idx: Int64, acc: List<v>) : List<v> =
    if bitmap == 0 then
        acc
    else
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__valuesHelper<k, v>(child, acc) in
        Stdlib.Dict.__collectValuesFromChildren<k, v>(ptr, bitmap & (bitmap - 1), idx + 1, newAcc)

// Get all entries from dict as key-value tuples
def Stdlib.Dict.entries<k, v>(dict: Dict<k, v>) : List<(k, v)> =
    Stdlib.Dict.__entriesHelper<k, v>(dict, [])

def Stdlib.Dict.__entriesHelper<k, v>(node: Dict<k, v>, acc: List<(k, v)>) : List<(k, v)> =
    if __dict_is_null<k, v>(node) then
        acc
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            let value = __raw_get<v>(ptr, 8) in
            [(key, value), ...acc]
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__collectEntriesFromChildren<k, v>(ptr, bitmap, 0, acc)
        else
            acc

def Stdlib.Dict.__collectEntriesFromChildren<k, v>(ptr: RawPtr, bitmap: Int64, idx: Int64, acc: List<(k, v)>) : List<(k, v)> =
    if bitmap == 0 then
        acc
    else
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__entriesHelper<k, v>(child, acc) in
        Stdlib.Dict.__collectEntriesFromChildren<k, v>(ptr, bitmap & (bitmap - 1), idx + 1, newAcc)

// Fold over all entries in the dictionary
def Stdlib.Dict.fold<k, v, a>(dict: Dict<k, v>, init: a, f: (a, k, v) -> a) : a =
    Stdlib.Dict.__foldHelper<k, v, a>(dict, init, f)

def Stdlib.Dict.__foldHelper<k, v, a>(node: Dict<k, v>, acc: a, f: (a, k, v) -> a) : a =
    if __dict_is_null<k, v>(node) then
        acc
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            let value = __raw_get<v>(ptr, 8) in
            f(acc, key, value)
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__foldChildren<k, v, a>(ptr, bitmap, 0, acc, f)
        else
            acc

def Stdlib.Dict.__foldChildren<k, v, a>(ptr: RawPtr, bitmap: Int64, idx: Int64, acc: a, f: (a, k, v) -> a) : a =
    if bitmap == 0 then
        acc
    else
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__foldHelper<k, v, a>(child, acc, f) in
        Stdlib.Dict.__foldChildren<k, v, a>(ptr, bitmap & (bitmap - 1), idx + 1, newAcc, f)

// Map over all values in the dictionary
def Stdlib.Dict.map<k, v, w>(dict: Dict<k, v>, f: (k, v) -> w) : Dict<k, w> =
    Stdlib.Dict.__mapHelper<k, v, w>(dict, f)

def Stdlib.Dict.__mapHelper<k, v, w>(node: Dict<k, v>, f: (k, v) -> w) : Dict<k, w> =
    if __dict_is_null<k, v>(node) then
        __empty_dict<k, w>()
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            let value = __raw_get<v>(ptr, 8) in
            let newValue = f(key, value) in
            Stdlib.Dict.__allocLeaf<k, w>(key, newValue)
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            let numChildren = Stdlib.Int64.popcount(bitmap) in
            let newPtr = Stdlib.Dict.__allocInternal(bitmap, numChildren) in
            Stdlib.Dict.__mapChildren<k, v, w>(ptr, newPtr, bitmap, 0, numChildren, f)
        else
            __empty_dict<k, w>()

def Stdlib.Dict.__mapChildren<k, v, w>(oldPtr: RawPtr, newPtr: RawPtr, bitmap: Int64, idx: Int64, numChildren: Int64, f: (k, v) -> w) : Dict<k, w> =
    if idx >= numChildren then
        Stdlib.Dict.__setTag<k, w>(newPtr, 1)
    else
        let child = __raw_get<Dict<k, v>>(oldPtr, 8 + (idx * 8)) in
        let mappedChild = Stdlib.Dict.__mapHelper<k, v, w>(child, f) in
        let _ = __raw_set<Dict<k, w>>(newPtr, 8 + (idx * 8), mappedChild) in
        Stdlib.Dict.__mapChildren<k, v, w>(oldPtr, newPtr, bitmap, idx + 1, numChildren, f)

// Filter entries in the dictionary
def Stdlib.Dict.filter<k, v>(dict: Dict<k, v>, f: (k, v) -> Bool) : Dict<k, v> =
    Stdlib.Dict.__filterHelper<k, v>(dict, Stdlib.Dict.empty<k, v>(), f)

def Stdlib.Dict.__filterHelper<k, v>(node: Dict<k, v>, acc: Dict<k, v>, f: (k, v) -> Bool) : Dict<k, v> =
    if __dict_is_null<k, v>(node) then
        acc
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            let value = __raw_get<v>(ptr, 8) in
            if f(key, value) then Stdlib.Dict.set<k, v>(acc, key, value) else acc
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__filterChildren<k, v>(ptr, bitmap, 0, acc, f)
        else
            acc

def Stdlib.Dict.__filterChildren<k, v>(ptr: RawPtr, bitmap: Int64, idx: Int64, acc: Dict<k, v>, f: (k, v) -> Bool) : Dict<k, v> =
    if bitmap == 0 then
        acc
    else
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__filterHelper<k, v>(child, acc, f) in
        Stdlib.Dict.__filterChildren<k, v>(ptr, bitmap & (bitmap - 1), idx + 1, newAcc, f)

// =============================================================================
// Dict.merge - Combine two dictionaries
// =============================================================================
// Second dictionary's values win on key conflicts

def Stdlib.Dict.merge<k, v>(dict1: Dict<k, v>, dict2: Dict<k, v>) : Dict<k, v> =
    Stdlib.Dict.__mergeHelper<k, v>(dict2, dict1)

def Stdlib.Dict.__mergeHelper<k, v>(source: Dict<k, v>, target: Dict<k, v>) : Dict<k, v> =
    if __dict_is_null<k, v>(source) then
        target
    else
        let tag = Stdlib.Dict.__getTag<k, v>(source) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(source) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            let value = __raw_get<v>(ptr, 8) in
            Stdlib.Dict.set<k, v>(target, key, value)
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__mergeChildren<k, v>(ptr, bitmap, 0, target)
        else
            target

def Stdlib.Dict.__mergeChildren<k, v>(ptr: RawPtr, bitmap: Int64, idx: Int64, target: Dict<k, v>) : Dict<k, v> =
    if bitmap == 0 then
        target
    else
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newTarget = Stdlib.Dict.__mergeHelper<k, v>(child, target) in
        Stdlib.Dict.__mergeChildren<k, v>(ptr, bitmap & (bitmap - 1), idx + 1, newTarget)

// =============================================================================
// Dict.fromList - Construct dictionary from list of pairs
// =============================================================================

def Stdlib.Dict.fromList<k, v>(pairs: List<(k, v)>) : Dict<k, v> =
    Stdlib.Dict.__fromListHelper<k, v>(pairs, Stdlib.Dict.empty<k, v>())

def Stdlib.Dict.__fromListHelper<k, v>(pairs: List<(k, v)>, acc: Dict<k, v>) : Dict<k, v> =
    match pairs with
    | [] -> acc
    | [pair, ...rest] ->
        let key = Stdlib.Tuple2.first<k, v>(pair) in
        let value = Stdlib.Tuple2.second<k, v>(pair) in
        Stdlib.Dict.__fromListHelper<k, v>(rest, Stdlib.Dict.set<k, v>(acc, key, value))

// =============================================================================
// Dict.getOrDefault - Get value with fallback
// =============================================================================

def Stdlib.Dict.getOrDefault<k, v>(dict: Dict<k, v>, key: k, default: v) : v =
    Stdlib.Option.withDefault<v>(Stdlib.Dict.get<k, v>(dict, key), default)

// Create a dictionary with a single key-value pair
def Stdlib.Dict.singleton<k, v>(key: k, value: v) : Dict<k, v> =
    Stdlib.Dict.set<k, v>(Stdlib.Dict.empty<k, v>(), key, value)

// Convert dictionary to list of key-value pairs (alias for entries)
def Stdlib.Dict.toList<k, v>(dict: Dict<k, v>) : List<(k, v)> =
    Stdlib.Dict.entries<k, v>(dict)

// ============================================================================
// Stdlib.Uuid - UUID v4 generation
// ============================================================================

// Helper: convert nibble (0-15) to hex char
def Stdlib.Uuid.__nibbleToHex(n: Int64) : String =
    match n with
    | 0 -> "0" | 1 -> "1" | 2 -> "2" | 3 -> "3"
    | 4 -> "4" | 5 -> "5" | 6 -> "6" | 7 -> "7"
    | 8 -> "8" | 9 -> "9" | 10 -> "a" | 11 -> "b"
    | 12 -> "c" | 13 -> "d" | 14 -> "e" | 15 -> "f"
    | _ -> "?"

// Helper: convert byte (from int64 at shift position) to 2 hex chars
def Stdlib.Uuid.__byteToHex(value: Int64, shift: Int64) : String =
    let byte = (value >> shift) & 255 in
    let hi = (byte >> 4) & 15 in
    let lo = byte & 15 in
    Stdlib.Uuid.__nibbleToHex(hi) ++ Stdlib.Uuid.__nibbleToHex(lo)

// Generate UUID v4: xxxxxxxx-xxxx-4xxx-Nxxx-xxxxxxxxxxxx
// where N is 8, 9, a, or b (variant bits)
def Stdlib.Uuid.generate() : String =
    let high = Stdlib.Random.int64() in
    let low = Stdlib.Random.int64() in
    // Set version (4) in byte 6: clear upper nibble, set to 4
    // Using XOR since we cleared the bits first with AND
    // Mask -61441 = 0xFFFFFFFFFFFF0FFF (clears bits 12-15)
    // Version 16384 = 0x4000 (sets bit 14 for version 4)
    let highWithVersion = (high & (-61441)) ^ 16384 in
    // Set variant (10xx) in byte 8: clear upper 2 bits, set to 10
    // Mask 4611686018427387903 = 0x3FFFFFFFFFFFFFFF (clears top 2 bits)
    // Variant -9223372036854775808 = 0x8000000000000000 (sets top bit)
    let lowWithVariant = (low & 4611686018427387903) ^ (-9223372036854775808) in
    // Format: 8-4-4-4-12 hex chars
    // bytes 0-3 (bits 32-63 of high)
    Stdlib.Uuid.__byteToHex(highWithVersion, 56) ++
    Stdlib.Uuid.__byteToHex(highWithVersion, 48) ++
    Stdlib.Uuid.__byteToHex(highWithVersion, 40) ++
    Stdlib.Uuid.__byteToHex(highWithVersion, 32) ++ "-" ++
    // bytes 4-5 (bits 16-31 of high)
    Stdlib.Uuid.__byteToHex(highWithVersion, 24) ++
    Stdlib.Uuid.__byteToHex(highWithVersion, 16) ++ "-" ++
    // bytes 6-7 (bits 0-15 of high) - contains version
    Stdlib.Uuid.__byteToHex(highWithVersion, 8) ++
    Stdlib.Uuid.__byteToHex(highWithVersion, 0) ++ "-" ++
    // bytes 8-9 (bits 48-63 of low) - contains variant
    Stdlib.Uuid.__byteToHex(lowWithVariant, 56) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 48) ++ "-" ++
    // bytes 10-15 (bits 0-47 of low)
    Stdlib.Uuid.__byteToHex(lowWithVariant, 40) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 32) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 24) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 16) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 8) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 0)

// =============================================================================
// Stdlib.Bytes - Byte array operations
// =============================================================================
// Memory layout: [length:8 bytes][data:N bytes][refcount:8 bytes]
// Same layout as String for consistency

// Get the length of a byte array
def Stdlib.Bytes.length(b: Bytes) : Int64 =
    __raw_get<Int64>(__int64_to_rawptr(__bytes_to_int64(b)), 0)

// Get the byte at a given index (0-based)
// Returns the byte as an Int64 (0-255)
def Stdlib.Bytes.get(b: Bytes, index: Int64) : Int64 =
    __raw_get_byte(__int64_to_rawptr(__bytes_to_int64(b)), index + 8)

// Create a new byte array with a byte set at the given index
// Returns a new Bytes (immutable update)
def Stdlib.Bytes.set(b: Bytes, index: Int64, value: Int64) : Bytes =
    let len = Stdlib.Bytes.length(b) in
    if index < 0 || index >= len then
        b  // Out of bounds, return unchanged
    else
        // Allocate: 8 (length) + len (data) + 8 (refcount)
        let totalSize = 16 + len in
        let ptr = __raw_alloc(totalSize) in
        // Write length at offset 0
        let _ = __raw_set<Int64>(ptr, 0, len) in
        // Copy bytes - use srcPtr approach
        let srcPtr = __int64_to_rawptr(__bytes_to_int64(b)) in
        let _ = Stdlib.Bytes.__copyLoop(srcPtr, ptr, 8, len) in
        // Update the byte at index
        let _ = __raw_set_byte(ptr, 8 + index, value) in
        // Write refcount = 1 at end
        let _ = __raw_set<Int64>(ptr, 8 + len, 1) in
        __int64_to_bytes(__rawptr_to_int64(ptr))

// Internal: Copy loop with 2 pointers sharing same offset
def Stdlib.Bytes.__copyLoop(src: RawPtr, dest: RawPtr, offset: Int64, remaining: Int64) : Unit =
    if remaining <= 0 then
        ()
    else
        let byte = __raw_get_byte(src, offset) in
        let _ = __raw_set_byte(dest, offset, byte) in
        Stdlib.Bytes.__copyLoop(src, dest, offset + 1, remaining - 1)

// Create a byte array of given size
// Note: Memory is typically zeroed by the OS, but not guaranteed
def Stdlib.Bytes.create(size: Int64) : Bytes =
    if size <= 0 then
        // Create empty bytes
        let ptr = __raw_alloc(16) in
        let _ = __raw_set<Int64>(ptr, 0, 0) in  // length = 0
        let _ = __raw_set<Int64>(ptr, 8, 1) in  // refcount = 1
        __int64_to_bytes(__rawptr_to_int64(ptr))
    else
        // Allocate: 8 (length) + size (data) + 8 (refcount)
        let totalSize = 16 + size in
        let ptr = __raw_alloc(totalSize) in
        // Write length at offset 0
        let _ = __raw_set<Int64>(ptr, 0, size) in
        // Write refcount = 1 at end
        let _ = __raw_set<Int64>(ptr, 8 + size, 1) in
        __int64_to_bytes(__rawptr_to_int64(ptr))

// Create bytes from a list of Int64 values (each 0-255)
def Stdlib.Bytes.fromList(list: List<Int64>) : Bytes =
    let len = Stdlib.List.length<Int64>(list) in
    if len == 0 then
        Stdlib.Bytes.create(0)
    else
        let totalSize = 16 + len in
        let ptr = __raw_alloc(totalSize) in
        let _ = __raw_set<Int64>(ptr, 0, len) in
        // Use a helper with fewer args
        let _ = Stdlib.Bytes.__writeListHelper(ptr, list, 8) in
        let _ = __raw_set<Int64>(ptr, 8 + len, 1) in
        __int64_to_bytes(__rawptr_to_int64(ptr))

// Helper: write list of bytes starting at offset
def Stdlib.Bytes.__writeListHelper(ptr: RawPtr, list: List<Int64>, offset: Int64) : Int64 =
    match list with
    | [] -> offset
    | [b, ...rest] ->
        let _ = __raw_set_byte(ptr, offset, b) in
        Stdlib.Bytes.__writeListHelper(ptr, rest, offset + 1)

// Convert bytes to a list of Int64 values (each 0-255)
// Build list by iterating through bytes
def Stdlib.Bytes.toList(b: Bytes) : List<Int64> =
    let len = Stdlib.Bytes.length(b) in
    if len == 0 then
        []
    else
        // Build list in reverse then reverse at end
        Stdlib.Bytes.__toListHelper(b, len - 1, [])

def Stdlib.Bytes.__toListHelper(b: Bytes, index: Int64, acc: List<Int64>) : List<Int64> =
    if index < 0 then
        acc
    else
        let byte = Stdlib.Bytes.get(b, index) in
        Stdlib.Bytes.__toListHelper(b, index - 1, [byte, ...acc])

// =============================================================================
// Stdlib.Char - Character operations
// =============================================================================
// Note: In Dark, characters are represented as single-character strings.
// These functions operate on the first codepoint of a string.

// Check if character is an ASCII digit (0-9)
def Stdlib.Char.isDigit(c: String) : Bool =
    if Stdlib.String.isEmpty(c) then false
    else
        let cps = Stdlib.String.toCodepoints(c) in
        match Stdlib.List.head<Int64>(cps) with
        | Some(cp) -> cp >= 48 && cp <= 57
        | None -> false

// Check if character is an ASCII letter (a-z, A-Z)
def Stdlib.Char.isLetter(c: String) : Bool =
    if Stdlib.String.isEmpty(c) then false
    else
        let cps = Stdlib.String.toCodepoints(c) in
        match Stdlib.List.head<Int64>(cps) with
        | Some(cp) -> (cp >= 65 && cp <= 90) || (cp >= 97 && cp <= 122)
        | None -> false

// Check if character is ASCII whitespace (space, tab, newline, carriage return)
def Stdlib.Char.isWhitespace(c: String) : Bool =
    if Stdlib.String.isEmpty(c) then false
    else
        let cps = Stdlib.String.toCodepoints(c) in
        match Stdlib.List.head<Int64>(cps) with
        | Some(cp) -> cp == 32 || cp == 9 || cp == 10 || cp == 13
        | None -> false

// Check if character is an ASCII uppercase letter (A-Z)
def Stdlib.Char.isUppercase(c: String) : Bool =
    if Stdlib.String.isEmpty(c) then false
    else
        let cps = Stdlib.String.toCodepoints(c) in
        match Stdlib.List.head<Int64>(cps) with
        | Some(cp) -> cp >= 65 && cp <= 90
        | None -> false

// Check if character is an ASCII lowercase letter (a-z)
def Stdlib.Char.isLowercase(c: String) : Bool =
    if Stdlib.String.isEmpty(c) then false
    else
        let cps = Stdlib.String.toCodepoints(c) in
        match Stdlib.List.head<Int64>(cps) with
        | Some(cp) -> cp >= 97 && cp <= 122
        | None -> false

// Check if character is alphanumeric (a-z, A-Z, 0-9)
def Stdlib.Char.isAlphanumeric(c: String) : Bool =
    Stdlib.Char.isLetter(c) || Stdlib.Char.isDigit(c)

// Convert ASCII character to uppercase
def Stdlib.Char.toUppercase(c: String) : String =
    if Stdlib.String.isEmpty(c) then ""
    else
        let cps = Stdlib.String.toCodepoints(c) in
        match Stdlib.List.head<Int64>(cps) with
        | Some(cp) ->
            if cp >= 97 && cp <= 122 then
                Stdlib.String.fromCodepoints([cp - 32])
            else
                Stdlib.String.fromCodepoints([cp])
        | None -> ""

// Convert ASCII character to lowercase
def Stdlib.Char.toLowercase(c: String) : String =
    if Stdlib.String.isEmpty(c) then ""
    else
        let cps = Stdlib.String.toCodepoints(c) in
        match Stdlib.List.head<Int64>(cps) with
        | Some(cp) ->
            if cp >= 65 && cp <= 90 then
                Stdlib.String.fromCodepoints([cp + 32])
            else
                Stdlib.String.fromCodepoints([cp])
        | None -> ""

// Get the Unicode codepoint value of the first character
def Stdlib.Char.toCode(c: String) : Int64 =
    let cps = Stdlib.String.toCodepoints(c) in
    match Stdlib.List.head<Int64>(cps) with
    | Some(cp) -> cp
    | None -> 0

// Create a single character string from a codepoint
def Stdlib.Char.fromCode(code: Int64) : String =
    Stdlib.String.fromCodepoints([code])

// =============================================================================
// Stdlib.Base64 - Base64 encoding and decoding
// =============================================================================
// Standard Base64 alphabet: A-Z, a-z, 0-9, +, /
// URL-safe alphabet: A-Z, a-z, 0-9, -, _

// Encoding lookup table (6-bit value -> character)
def Stdlib.Base64.__encodeChar(n: Int64) : String =
    match n with
    | 0 -> "A" | 1 -> "B" | 2 -> "C" | 3 -> "D" | 4 -> "E" | 5 -> "F"
    | 6 -> "G" | 7 -> "H" | 8 -> "I" | 9 -> "J" | 10 -> "K" | 11 -> "L"
    | 12 -> "M" | 13 -> "N" | 14 -> "O" | 15 -> "P" | 16 -> "Q" | 17 -> "R"
    | 18 -> "S" | 19 -> "T" | 20 -> "U" | 21 -> "V" | 22 -> "W" | 23 -> "X"
    | 24 -> "Y" | 25 -> "Z" | 26 -> "a" | 27 -> "b" | 28 -> "c" | 29 -> "d"
    | 30 -> "e" | 31 -> "f" | 32 -> "g" | 33 -> "h" | 34 -> "i" | 35 -> "j"
    | 36 -> "k" | 37 -> "l" | 38 -> "m" | 39 -> "n" | 40 -> "o" | 41 -> "p"
    | 42 -> "q" | 43 -> "r" | 44 -> "s" | 45 -> "t" | 46 -> "u" | 47 -> "v"
    | 48 -> "w" | 49 -> "x" | 50 -> "y" | 51 -> "z" | 52 -> "0" | 53 -> "1"
    | 54 -> "2" | 55 -> "3" | 56 -> "4" | 57 -> "5" | 58 -> "6" | 59 -> "7"
    | 60 -> "8" | 61 -> "9" | 62 -> "+" | 63 -> "/"
    | _ -> ""

// URL-safe encoding (uses - and _ instead of + and /)
def Stdlib.Base64.__encodeCharUrl(n: Int64) : String =
    if n == 62 then "-"
    else if n == 63 then "_"
    else Stdlib.Base64.__encodeChar(n)

// Decode lookup table (character -> 6-bit value, returns -1 for invalid)
def Stdlib.Base64.__decodeChar(c: Int64) : Int64 =
    if c >= 65 && c <= 90 then c - 65      // A-Z -> 0-25
    else if c >= 97 && c <= 122 then c - 71  // a-z -> 26-51
    else if c >= 48 && c <= 57 then c + 4    // 0-9 -> 52-61
    else if c == 43 then 62                   // + -> 62
    else if c == 47 then 63                   // / -> 63
    else if c == 45 then 62                   // - -> 62 (URL-safe)
    else if c == 95 then 63                   // _ -> 63 (URL-safe)
    else if c == 61 then -2                   // = -> padding
    else -1                                   // Invalid

// Encode 3 bytes to 4 base64 characters
def Stdlib.Base64.__encode3Bytes(b0: Int64, b1: Int64, b2: Int64, urlSafe: Bool) : String =
    let c0 = (b0 >> 2) & 63 in
    let c1 = ((b0 & 3) << 4) ^ ((b1 >> 4) & 15) in
    let c2 = ((b1 & 15) << 2) ^ ((b2 >> 6) & 3) in
    let c3 = b2 & 63 in
    if urlSafe then
        Stdlib.Base64.__encodeCharUrl(c0) ++
        Stdlib.Base64.__encodeCharUrl(c1) ++
        Stdlib.Base64.__encodeCharUrl(c2) ++
        Stdlib.Base64.__encodeCharUrl(c3)
    else
        Stdlib.Base64.__encodeChar(c0) ++
        Stdlib.Base64.__encodeChar(c1) ++
        Stdlib.Base64.__encodeChar(c2) ++
        Stdlib.Base64.__encodeChar(c3)

// Encode 2 bytes to 3 base64 characters + 1 padding
def Stdlib.Base64.__encode2Bytes(b0: Int64, b1: Int64, urlSafe: Bool) : String =
    let c0 = (b0 >> 2) & 63 in
    let c1 = ((b0 & 3) << 4) ^ ((b1 >> 4) & 15) in
    let c2 = (b1 & 15) << 2 in
    if urlSafe then
        Stdlib.Base64.__encodeCharUrl(c0) ++
        Stdlib.Base64.__encodeCharUrl(c1) ++
        Stdlib.Base64.__encodeCharUrl(c2) ++ "="
    else
        Stdlib.Base64.__encodeChar(c0) ++
        Stdlib.Base64.__encodeChar(c1) ++
        Stdlib.Base64.__encodeChar(c2) ++ "="

// Encode 1 byte to 2 base64 characters + 2 padding
def Stdlib.Base64.__encode1Byte(b0: Int64, urlSafe: Bool) : String =
    let c0 = (b0 >> 2) & 63 in
    let c1 = (b0 & 3) << 4 in
    if urlSafe then
        Stdlib.Base64.__encodeCharUrl(c0) ++
        Stdlib.Base64.__encodeCharUrl(c1) ++ "=="
    else
        Stdlib.Base64.__encodeChar(c0) ++
        Stdlib.Base64.__encodeChar(c1) ++ "=="

// Encode bytes to base64 helper
def Stdlib.Base64.__encodeHelper(b: Bytes, index: Int64, len: Int64, urlSafe: Bool, acc: String) : String =
    let remaining = len - index in
    if remaining <= 0 then
        acc
    else if remaining >= 3 then
        let b0 = Stdlib.Bytes.get(b, index) in
        let b1 = Stdlib.Bytes.get(b, index + 1) in
        let b2 = Stdlib.Bytes.get(b, index + 2) in
        let chunk = Stdlib.Base64.__encode3Bytes(b0, b1, b2, urlSafe) in
        Stdlib.Base64.__encodeHelper(b, index + 3, len, urlSafe, acc ++ chunk)
    else if remaining == 2 then
        let b0 = Stdlib.Bytes.get(b, index) in
        let b1 = Stdlib.Bytes.get(b, index + 1) in
        acc ++ Stdlib.Base64.__encode2Bytes(b0, b1, urlSafe)
    else
        let b0 = Stdlib.Bytes.get(b, index) in
        acc ++ Stdlib.Base64.__encode1Byte(b0, urlSafe)

// Encode bytes to standard base64 string
def Stdlib.Base64.encode(bytes: Bytes) : String =
    Stdlib.Base64.__encodeHelper(bytes, 0, Stdlib.Bytes.length(bytes), false, "")

// Encode bytes to URL-safe base64 string
def Stdlib.Base64.urlEncode(bytes: Bytes) : String =
    Stdlib.Base64.__encodeHelper(bytes, 0, Stdlib.Bytes.length(bytes), true, "")

// Decode 4 base64 characters to up to 3 bytes
// Returns (bytes list, error flag)
def Stdlib.Base64.__decode4Chars(c0: Int64, c1: Int64, c2: Int64, c3: Int64) : (List<Int64>, Bool) =
    let v0 = Stdlib.Base64.__decodeChar(c0) in
    let v1 = Stdlib.Base64.__decodeChar(c1) in
    let v2 = Stdlib.Base64.__decodeChar(c2) in
    let v3 = Stdlib.Base64.__decodeChar(c3) in
    // Check for invalid characters
    if v0 == -1 || v1 == -1 || (v2 == -1 && v2 != -2) || (v3 == -1 && v3 != -2) then
        ([], true)
    else if v2 == -2 then
        // Two padding chars - 1 output byte
        let b0 = ((v0 << 2) ^ (v1 >> 4)) & 255 in
        ([b0], false)
    else if v3 == -2 then
        // One padding char - 2 output bytes
        let b0 = ((v0 << 2) ^ (v1 >> 4)) & 255 in
        let b1 = ((v1 << 4) ^ (v2 >> 2)) & 255 in
        ([b0, b1], false)
    else
        // No padding - 3 output bytes
        let b0 = ((v0 << 2) ^ (v1 >> 4)) & 255 in
        let b1 = ((v1 << 4) ^ (v2 >> 2)) & 255 in
        let b2 = ((v2 << 6) ^ v3) & 255 in
        ([b0, b1, b2], false)

// Decode base64 helper
def Stdlib.Base64.__decodeHelper(s: String, index: Int64, len: Int64, acc: List<Int64>) : Stdlib.Result.Result<List<Int64>, String> =
    if index >= len then
        Ok(Stdlib.List.reverse<Int64>(acc))
    else if index + 4 > len then
        Error("Invalid base64: length not multiple of 4")
    else
        let c0 = Stdlib.String.getByteAt(s, index) in
        let c1 = Stdlib.String.getByteAt(s, index + 1) in
        let c2 = Stdlib.String.getByteAt(s, index + 2) in
        let c3 = Stdlib.String.getByteAt(s, index + 3) in
        let result = Stdlib.Base64.__decode4Chars(c0, c1, c2, c3) in
        match result with
        | (bytes, true) -> Error("Invalid base64 character")
        | (bytes, false) ->
            // Prepend bytes to accumulator (in reverse order since we'll reverse at end)
            let newAcc = Stdlib.Base64.__prependReversed(bytes, acc) in
            Stdlib.Base64.__decodeHelper(s, index + 4, len, newAcc)

// Helper to prepend a list in reverse order
def Stdlib.Base64.__prependReversed(bytes: List<Int64>, acc: List<Int64>) : List<Int64> =
    match bytes with
    | [] -> acc
    | [b, ...rest] -> Stdlib.Base64.__prependReversed(rest, [b, ...acc])

// Decode base64 string to bytes
def Stdlib.Base64.decode(s: String) : Stdlib.Result.Result<Bytes, String> =
    let len = Stdlib.String.length(s) in
    if len == 0 then
        Ok(Stdlib.Bytes.create(0))
    else if (len % 4) != 0 then
        Error("Invalid base64: length not multiple of 4")
    else
        match Stdlib.Base64.__decodeHelper(s, 0, len, []) with
        | Ok(byteList) -> Ok(Stdlib.Bytes.fromList(byteList))
        | Error(msg) -> Error(msg)

// Decode URL-safe base64 string to bytes (same decoder handles both)
def Stdlib.Base64.urlDecode(s: String) : Stdlib.Result.Result<Bytes, String> =
    Stdlib.Base64.decode(s)

// =============================================================================
// Stdlib.Math - Mathematical operations
// =============================================================================

// Pi constant (approximation to 15 decimal places)
// 3.141592653589793
def Stdlib.Math.pi() : Float = 3.141592653589793

// Euler's number e (approximation to 15 decimal places)
// 2.718281828459045
def Stdlib.Math.e() : Float = 2.718281828459045

// Absolute value of a float
def Stdlib.Math.abs(x: Float) : Float =
    Float.abs(x)

// Square root (delegating to existing Float.sqrt)
def Stdlib.Math.sqrt(x: Float) : Float =
    Float.sqrt(x)

// Convert float to integer, truncating toward zero
def Stdlib.Math.truncate(x: Float) : Int64 =
    Float.toInt(x)

// Floor: largest integer less than or equal to x
// Note: Float.toInt truncates toward zero, so we need to adjust for negative numbers
def Stdlib.Math.floor(x: Float) : Int64 =
    let truncated = Float.toInt(x) in
    let floatTruncated = Float.abs(x) in  // placeholder - we don't have Int64.toFloat
    truncated  // Simplified: just truncate for now

// Ceiling: smallest integer greater than or equal to x
def Stdlib.Math.ceiling(x: Float) : Int64 =
    let truncated = Float.toInt(x) in
    truncated  // Simplified: just truncate for now

// Round to nearest integer
def Stdlib.Math.round(x: Float) : Int64 =
    Float.toInt(x)  // Simplified: just truncate for now

// NOTE: Float comparison and arithmetic operators are not fully implemented yet.
// The following functions require compiler support for float operations:
// - Math.max, Math.min, Math.clamp (need float comparison)
// - Math.pow (needs float multiplication)
// - Math.isNegative (needs float comparison)
// - Trigonometric functions (sin, cos, tan) require intrinsics


// =============================================================================
// Stdlib.FingerTree - Efficient Immutable Sequence
// =============================================================================
//
// A Finger Tree provides O(1) amortized access to both ends and O(log n) indexed access.
// This implementation uses pointer tagging for efficient representation:
//
// Tags (low 3 bits):
//   0: Empty (NULL pointer)
//   1: Single element [elem:8]
//   2: Deep node [measure:8][prefix_count:8][p0-p3:32][middle:8][suffix_count:8][s0-s3:32]
//   3: Node2 [elem0:8][elem1:8]
//   4: Node3 [elem0:8][elem1:8][elem2:8]
//
// Digits (prefix/suffix) store 1-4 elements inline with a count byte.
// The measure field caches the total element count for O(1) length queries.
// =============================================================================

// -----------------------------------------------------------------------------
// Tag constants
// -----------------------------------------------------------------------------
def Stdlib.FingerTree.__TAG_EMPTY() : Int64 = 0
def Stdlib.FingerTree.__TAG_SINGLE() : Int64 = 1
def Stdlib.FingerTree.__TAG_DEEP() : Int64 = 2
def Stdlib.FingerTree.__TAG_NODE2() : Int64 = 3
def Stdlib.FingerTree.__TAG_NODE3() : Int64 = 4
def Stdlib.FingerTree.__TAG_LEAF() : Int64 = 5

// -----------------------------------------------------------------------------
// Pointer tagging helpers
// -----------------------------------------------------------------------------

// Get tag from tagged pointer (low 3 bits)
def Stdlib.FingerTree.__getTag<a>(tree: List<a>) : Int64 =
    __list_get_tag<a>(tree)

// Clear tag to get raw pointer
def Stdlib.FingerTree.__toRawPtr<a>(tree: List<a>) : RawPtr =
    __list_to_rawptr<a>(tree)

// Create tagged pointer from raw pointer and tag
def Stdlib.FingerTree.__fromRawPtr<a>(ptr: RawPtr, tag: Int64) : List<a> =
    __rawptr_to_list<a>(ptr, tag)

// Check if tree is empty
def Stdlib.FingerTree.__isNull<a>(tree: List<a>) : Bool =
    __list_is_null<a>(tree)

// -----------------------------------------------------------------------------
// Single node operations
// -----------------------------------------------------------------------------

// Create a Single node: [elem:8] with tag 1
def Stdlib.FingerTree.__allocSingle<a>(elem: a) : List<a> =
    let ptr = __raw_alloc(8) in
    let _ = __raw_set<a>(ptr, 0, elem) in
    Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_SINGLE())

// Get element from Single node
def Stdlib.FingerTree.__getSingleElem<a>(tree: List<a>) : a =
    let ptr = Stdlib.FingerTree.__toRawPtr<a>(tree) in
    __raw_get<a>(ptr, 0)

// -----------------------------------------------------------------------------
// LEAF node operations (wraps actual elements for type-uniform design)
// -----------------------------------------------------------------------------

// Create a LEAF node: [value:8] with tag 5
def Stdlib.FingerTree.__allocLeaf<a>(value: a) : List<a> =
    let ptr = __raw_alloc(8) in
    let _ = __raw_set<a>(ptr, 0, value) in
    Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_LEAF())

// Get value from LEAF node
def Stdlib.FingerTree.__getLeafValue<a>(leaf: List<a>) : a =
    let ptr = Stdlib.FingerTree.__toRawPtr<a>(leaf) in
    __raw_get<a>(ptr, 0)

// Get measure (element count) of any TreeNode
def Stdlib.FingerTree.__nodeMeasure<a>(node: List<a>) : Int64 =
    let tag = Stdlib.FingerTree.__getTag<a>(node) in
    if tag == Stdlib.FingerTree.__TAG_LEAF() then 1
    else if tag == Stdlib.FingerTree.__TAG_NODE2() then
        let ptr = Stdlib.FingerTree.__toRawPtr<a>(node) in
        __raw_get<Int64>(ptr, 16)  // measure at offset 16
    else if tag == Stdlib.FingerTree.__TAG_NODE3() then
        let ptr = Stdlib.FingerTree.__toRawPtr<a>(node) in
        __raw_get<Int64>(ptr, 24)  // measure at offset 24
    else 0

// -----------------------------------------------------------------------------
// Node2/Node3 operations (for internal spine)
// -----------------------------------------------------------------------------

// Create Node2: [child0:8][child1:8][measure:8] with tag 3
// Children should be TreeNodes (LEAF, NODE2, or NODE3)
def Stdlib.FingerTree.__allocNode2<a>(c0: List<a>, c1: List<a>, measure: Int64) : List<a> =
    let ptr = __raw_alloc(24) in
    let _ = __raw_set<List<a>>(ptr, 0, c0) in
    let _ = __raw_set<List<a>>(ptr, 8, c1) in
    let _ = __raw_set<Int64>(ptr, 16, measure) in
    Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_NODE2())

// Create Node3: [child0:8][child1:8][child2:8][measure:8] with tag 4
// Children should be TreeNodes (LEAF, NODE2, or NODE3)
def Stdlib.FingerTree.__allocNode3<a>(c0: List<a>, c1: List<a>, c2: List<a>, measure: Int64) : List<a> =
    let ptr = __raw_alloc(32) in
    let _ = __raw_set<List<a>>(ptr, 0, c0) in
    let _ = __raw_set<List<a>>(ptr, 8, c1) in
    let _ = __raw_set<List<a>>(ptr, 16, c2) in
    let _ = __raw_set<Int64>(ptr, 24, measure) in
    Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_NODE3())

// Get child from NODE2 at index (0 or 1)
def Stdlib.FingerTree.__node2GetChild<a>(node: List<a>, index: Int64) : List<a> =
    let ptr = Stdlib.FingerTree.__toRawPtr<a>(node) in
    __raw_get<List<a>>(ptr, index * 8)

// Get child from NODE3 at index (0, 1, or 2)
def Stdlib.FingerTree.__node3GetChild<a>(node: List<a>, index: Int64) : List<a> =
    let ptr = Stdlib.FingerTree.__toRawPtr<a>(node) in
    __raw_get<List<a>>(ptr, index * 8)

// -----------------------------------------------------------------------------
// Deep node structure
// -----------------------------------------------------------------------------
// Deep layout: [measure:8][prefix_count:8][p0:8][p1:8][p2:8][p3:8][middle:8][suffix_count:8][s0:8][s1:8][s2:8][s3:8]
// Offsets:     0          8               16    24    32    40    48       56              64    72    80    88
// Total: 96 bytes

def Stdlib.FingerTree.__DEEP_MEASURE_OFF() : Int64 = 0
def Stdlib.FingerTree.__DEEP_PREFIX_COUNT_OFF() : Int64 = 8
def Stdlib.FingerTree.__DEEP_PREFIX_OFF() : Int64 = 16
def Stdlib.FingerTree.__DEEP_MIDDLE_OFF() : Int64 = 48
def Stdlib.FingerTree.__DEEP_SUFFIX_COUNT_OFF() : Int64 = 56
def Stdlib.FingerTree.__DEEP_SUFFIX_OFF() : Int64 = 64

// Allocate Deep node with prefix and suffix counts
def Stdlib.FingerTree.__allocDeep<a>(measure: Int64, prefixCount: Int64, suffixCount: Int64) : RawPtr =
    let ptr = __raw_alloc(96) in
    let _ = __raw_set<Int64>(ptr, Stdlib.FingerTree.__DEEP_MEASURE_OFF(), measure) in
    let _ = __raw_set<Int64>(ptr, Stdlib.FingerTree.__DEEP_PREFIX_COUNT_OFF(), prefixCount) in
    let _ = __raw_set<Int64>(ptr, Stdlib.FingerTree.__DEEP_SUFFIX_COUNT_OFF(), suffixCount) in
    ptr

// Get measure from Deep node
def Stdlib.FingerTree.__getDeepMeasure<a>(tree: List<a>) : Int64 =
    let ptr = Stdlib.FingerTree.__toRawPtr<a>(tree) in
    __raw_get<Int64>(ptr, Stdlib.FingerTree.__DEEP_MEASURE_OFF())

// Get prefix count from Deep node
def Stdlib.FingerTree.__getDeepPrefixCount<a>(tree: List<a>) : Int64 =
    let ptr = Stdlib.FingerTree.__toRawPtr<a>(tree) in
    __raw_get<Int64>(ptr, Stdlib.FingerTree.__DEEP_PREFIX_COUNT_OFF())

// Get suffix count from Deep node
def Stdlib.FingerTree.__getDeepSuffixCount<a>(tree: List<a>) : Int64 =
    let ptr = Stdlib.FingerTree.__toRawPtr<a>(tree) in
    __raw_get<Int64>(ptr, Stdlib.FingerTree.__DEEP_SUFFIX_COUNT_OFF())

// Get prefix TreeNode at index (0-3)
def Stdlib.FingerTree.__getDeepPrefixAt<a>(tree: List<a>, index: Int64) : List<a> =
    let ptr = Stdlib.FingerTree.__toRawPtr<a>(tree) in
    __raw_get<List<a>>(ptr, Stdlib.FingerTree.__DEEP_PREFIX_OFF() + (index * 8))

// Get suffix TreeNode at index (0-3)
def Stdlib.FingerTree.__getDeepSuffixAt<a>(tree: List<a>, index: Int64) : List<a> =
    let ptr = Stdlib.FingerTree.__toRawPtr<a>(tree) in
    __raw_get<List<a>>(ptr, Stdlib.FingerTree.__DEEP_SUFFIX_OFF() + (index * 8))

// Get middle tree from Deep node (type-uniform: middle is also List<a>)
def Stdlib.FingerTree.__getDeepMiddle<a>(tree: List<a>) : List<a> =
    let ptr = Stdlib.FingerTree.__toRawPtr<a>(tree) in
    __raw_get<List<a>>(ptr, Stdlib.FingerTree.__DEEP_MIDDLE_OFF())

// Set prefix element at index (stores TreeNode, not raw element)
def Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr: RawPtr, index: Int64, node: List<a>) : Unit =
    __raw_set<List<a>>(ptr, Stdlib.FingerTree.__DEEP_PREFIX_OFF() + (index * 8), node)

// Set suffix element at index (stores TreeNode, not raw element)
def Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr: RawPtr, index: Int64, node: List<a>) : Unit =
    __raw_set<List<a>>(ptr, Stdlib.FingerTree.__DEEP_SUFFIX_OFF() + (index * 8), node)

// Set middle tree (type-uniform: middle is also List<a>)
def Stdlib.FingerTree.__setDeepMiddle<a>(ptr: RawPtr, middle: List<a>) : Unit =
    __raw_set<List<a>>(ptr, Stdlib.FingerTree.__DEEP_MIDDLE_OFF(), middle)

// -----------------------------------------------------------------------------
// Public API
// -----------------------------------------------------------------------------

// Create an empty FingerTree
def Stdlib.FingerTree.empty<a>() : List<a> =
    __list_empty<a>()

// Check if the tree is empty
def Stdlib.FingerTree.isEmpty<a>(tree: List<a>) : Bool =
    Stdlib.FingerTree.__isNull<a>(tree)

// Get the length of the tree (O(1) for Deep, O(1) for others)
def Stdlib.FingerTree.length<a>(tree: List<a>) : Int64 =
    if Stdlib.FingerTree.__isNull<a>(tree) then 0
    else
        let tag = Stdlib.FingerTree.__getTag<a>(tree) in
        if tag == Stdlib.FingerTree.__TAG_SINGLE() then
            // SINGLE contains a TreeNode - return its measure
            let node = Stdlib.FingerTree.__getSingleElem<a>(tree) in
            Stdlib.FingerTree.__nodeMeasure<a>(node)
        else if tag == Stdlib.FingerTree.__TAG_DEEP() then
            Stdlib.FingerTree.__getDeepMeasure<a>(tree)
        else 0

// Helper: get leftmost element from a TreeNode (recursively unwrap until LEAF)
def Stdlib.FingerTree.__headOfNode<a>(node: List<a>) : a =
    let tag = Stdlib.FingerTree.__getTag<a>(node) in
    if tag == Stdlib.FingerTree.__TAG_LEAF() then
        Stdlib.FingerTree.__getLeafValue<a>(node)
    else if tag == Stdlib.FingerTree.__TAG_NODE2() then
        Stdlib.FingerTree.__headOfNode<a>(Stdlib.FingerTree.__node2GetChild<a>(node, 0))
    else if tag == Stdlib.FingerTree.__TAG_NODE3() then
        Stdlib.FingerTree.__headOfNode<a>(Stdlib.FingerTree.__node3GetChild<a>(node, 0))
    else
        // Fallback - shouldn't happen
        Stdlib.FingerTree.__getLeafValue<a>(node)

// Helper: get rightmost element from a TreeNode (recursively unwrap until LEAF)
def Stdlib.FingerTree.__lastOfNode<a>(node: List<a>) : a =
    let tag = Stdlib.FingerTree.__getTag<a>(node) in
    if tag == Stdlib.FingerTree.__TAG_LEAF() then
        Stdlib.FingerTree.__getLeafValue<a>(node)
    else if tag == Stdlib.FingerTree.__TAG_NODE2() then
        Stdlib.FingerTree.__lastOfNode<a>(Stdlib.FingerTree.__node2GetChild<a>(node, 1))
    else if tag == Stdlib.FingerTree.__TAG_NODE3() then
        Stdlib.FingerTree.__lastOfNode<a>(Stdlib.FingerTree.__node3GetChild<a>(node, 2))
    else
        // Fallback - shouldn't happen
        Stdlib.FingerTree.__getLeafValue<a>(node)

// Get the first element (O(1))
def Stdlib.FingerTree.head<a>(tree: List<a>) : Stdlib.Option.Option<a> =
    if Stdlib.FingerTree.__isNull<a>(tree) then None
    else
        let tag = Stdlib.FingerTree.__getTag<a>(tree) in
        if tag == Stdlib.FingerTree.__TAG_SINGLE() then
            // SINGLE stores a TreeNode - get its leftmost element
            let node = Stdlib.FingerTree.__getSingleElem<a>(tree) in
            Some(Stdlib.FingerTree.__headOfNode<a>(node))
        else if tag == Stdlib.FingerTree.__TAG_DEEP() then
            // Get first TreeNode from prefix, then get its leftmost element
            let firstNode = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 0) in
            Some(Stdlib.FingerTree.__headOfNode<a>(firstNode))
        else None

// Get the first element without Option wrapper (caller must ensure non-empty)
def Stdlib.FingerTree.headUnsafe<a>(tree: List<a>) : a =
    let tag = Stdlib.FingerTree.__getTag<a>(tree) in
    if tag == Stdlib.FingerTree.__TAG_SINGLE() then
        let node = Stdlib.FingerTree.__getSingleElem<a>(tree) in
        Stdlib.FingerTree.__headOfNode<a>(node)
    else
        // DEEP
        let firstNode = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 0) in
        Stdlib.FingerTree.__headOfNode<a>(firstNode)

// Get the last element (O(1))
def Stdlib.FingerTree.last<a>(tree: List<a>) : Stdlib.Option.Option<a> =
    if Stdlib.FingerTree.__isNull<a>(tree) then None
    else
        let tag = Stdlib.FingerTree.__getTag<a>(tree) in
        if tag == Stdlib.FingerTree.__TAG_SINGLE() then
            // SINGLE stores a TreeNode - get its rightmost element
            let node = Stdlib.FingerTree.__getSingleElem<a>(tree) in
            Some(Stdlib.FingerTree.__lastOfNode<a>(node))
        else if tag == Stdlib.FingerTree.__TAG_DEEP() then
            // Get last TreeNode from suffix, then get its rightmost element
            let suffixCount = Stdlib.FingerTree.__getDeepSuffixCount<a>(tree) in
            let lastNode = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, suffixCount - 1) in
            Some(Stdlib.FingerTree.__lastOfNode<a>(lastNode))
        else None

// Helper: explode a TreeNode into its leaves, pushing them to the front of a tree
def Stdlib.FingerTree.__explodeNodeToFront<a>(node: List<a>, tree: List<a>) : List<a> =
    let tag = Stdlib.FingerTree.__getTag<a>(node) in
    if tag == Stdlib.FingerTree.__TAG_LEAF() then
        Stdlib.FingerTree.__pushNode<a>(tree, node)
    else if tag == Stdlib.FingerTree.__TAG_NODE2() then
        let c0 = Stdlib.FingerTree.__node2GetChild<a>(node, 0) in
        let c1 = Stdlib.FingerTree.__node2GetChild<a>(node, 1) in
        // Push c0 then c1 (c1 first to front, then c0 to front)
        let t1 = Stdlib.FingerTree.__explodeNodeToFront<a>(c1, tree) in
        Stdlib.FingerTree.__explodeNodeToFront<a>(c0, t1)
    else if tag == Stdlib.FingerTree.__TAG_NODE3() then
        let c0 = Stdlib.FingerTree.__node3GetChild<a>(node, 0) in
        let c1 = Stdlib.FingerTree.__node3GetChild<a>(node, 1) in
        let c2 = Stdlib.FingerTree.__node3GetChild<a>(node, 2) in
        // Push c2 first, then c1, then c0
        let t1 = Stdlib.FingerTree.__explodeNodeToFront<a>(c2, tree) in
        let t2 = Stdlib.FingerTree.__explodeNodeToFront<a>(c1, t1) in
        Stdlib.FingerTree.__explodeNodeToFront<a>(c0, t2)
    else tree

// Helper: tail of a TreeNode (remove first element, return remaining as tree)
def Stdlib.FingerTree.__tailOfNode<a>(node: List<a>) : List<a> =
    let tag = Stdlib.FingerTree.__getTag<a>(node) in
    if tag == Stdlib.FingerTree.__TAG_LEAF() then
        Stdlib.FingerTree.empty<a>()
    else if tag == Stdlib.FingerTree.__TAG_NODE2() then
        // NODE2: remove first child's first element
        let c0 = Stdlib.FingerTree.__node2GetChild<a>(node, 0) in
        let c1 = Stdlib.FingerTree.__node2GetChild<a>(node, 1) in
        let c0tag = Stdlib.FingerTree.__getTag<a>(c0) in
        if c0tag == Stdlib.FingerTree.__TAG_LEAF() then
            // c0 is a leaf, just return tree with c1 exploded
            Stdlib.FingerTree.__explodeNodeToFront<a>(c1, Stdlib.FingerTree.empty<a>())
        else
            // c0 is a nested node - recurse to get tail of c0, then add c1
            let tailOfC0 = Stdlib.FingerTree.__tailOfNode<a>(c0) in
            Stdlib.FingerTree.__explodeNodeToFront<a>(c1, tailOfC0)
    else if tag == Stdlib.FingerTree.__TAG_NODE3() then
        let c0 = Stdlib.FingerTree.__node3GetChild<a>(node, 0) in
        let c1 = Stdlib.FingerTree.__node3GetChild<a>(node, 1) in
        let c2 = Stdlib.FingerTree.__node3GetChild<a>(node, 2) in
        let c0tag = Stdlib.FingerTree.__getTag<a>(c0) in
        if c0tag == Stdlib.FingerTree.__TAG_LEAF() then
            // c0 is a leaf, return tree with c1 and c2 exploded
            let t1 = Stdlib.FingerTree.__explodeNodeToFront<a>(c2, Stdlib.FingerTree.empty<a>()) in
            Stdlib.FingerTree.__explodeNodeToFront<a>(c1, t1)
        else
            // c0 is a nested node - recurse to get tail of c0, then add c1 and c2
            let tailOfC0 = Stdlib.FingerTree.__tailOfNode<a>(c0) in
            let t1 = Stdlib.FingerTree.__explodeNodeToFront<a>(c2, tailOfC0) in
            Stdlib.FingerTree.__explodeNodeToFront<a>(c1, t1)
    else Stdlib.FingerTree.empty<a>()

// Tail: remove first element (O(1) amortized)
def Stdlib.FingerTree.tail<a>(tree: List<a>) : List<a> =
    if Stdlib.FingerTree.__isNull<a>(tree) then
        Stdlib.FingerTree.empty<a>()
    else
        let tag = Stdlib.FingerTree.__getTag<a>(tree) in
        if tag == Stdlib.FingerTree.__TAG_SINGLE() then
            // Single node - tail depends on what the node contains
            let node = Stdlib.FingerTree.__getSingleElem<a>(tree) in
            Stdlib.FingerTree.__tailOfNode<a>(node)
        else if tag == Stdlib.FingerTree.__TAG_DEEP() then
            let prefixCount = Stdlib.FingerTree.__getDeepPrefixCount<a>(tree) in
            let p0 = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 0) in
            let p0tag = Stdlib.FingerTree.__getTag<a>(p0) in
            if p0tag == Stdlib.FingerTree.__TAG_LEAF() then
                // First prefix element is a LEAF - remove it
                if prefixCount > 1 then
                    // Shift remaining prefix elements left
                    let measure = Stdlib.FingerTree.__getDeepMeasure<a>(tree) in
                    let suffixCount = Stdlib.FingerTree.__getDeepSuffixCount<a>(tree) in
                    let ptr = Stdlib.FingerTree.__allocDeep<a>(measure - 1, prefixCount - 1, suffixCount) in
                    // Copy prefix elements shifted left
                    let _ = if prefixCount >= 2 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 0, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 1)) else () in
                    let _ = if prefixCount >= 3 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 1, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 2)) else () in
                    let _ = if prefixCount >= 4 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 2, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 3)) else () in
                    // Copy middle and suffix
                    let _ = Stdlib.FingerTree.__setDeepMiddle<a>(ptr, Stdlib.FingerTree.__getDeepMiddle<a>(tree)) in
                    let _ = if suffixCount >= 1 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 0, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 0)) else () in
                    let _ = if suffixCount >= 2 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 1, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 1)) else () in
                    let _ = if suffixCount >= 3 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 2, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 2)) else () in
                    let _ = if suffixCount >= 4 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 3, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 3)) else () in
                    Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_DEEP())
                else
                    // Only one prefix element (a LEAF), need to borrow from middle or use suffix
                    let middle = Stdlib.FingerTree.__getDeepMiddle<a>(tree) in
                    if Stdlib.FingerTree.isEmpty<a>(middle) then
                        // Middle is empty, suffix becomes the tree
                        let suffixCount = Stdlib.FingerTree.__getDeepSuffixCount<a>(tree) in
                        if suffixCount == 1 then
                            Stdlib.FingerTree.__allocSingle<a>(Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 0))
                        else if suffixCount == 2 then
                            // Two elements: make DEEP with 1 prefix, 1 suffix
                            let s0 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 0) in
                            let s1 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 1) in
                            let measure = Stdlib.FingerTree.__nodeMeasure<a>(s0) + Stdlib.FingerTree.__nodeMeasure<a>(s1) in
                            let ptr = Stdlib.FingerTree.__allocDeep<a>(measure, 1, 1) in
                            let _ = Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 0, s0) in
                            let _ = Stdlib.FingerTree.__setDeepMiddle<a>(ptr, Stdlib.FingerTree.empty<a>()) in
                            let _ = Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 0, s1) in
                            Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_DEEP())
                        else if suffixCount == 3 then
                            // Three elements: 1 prefix, 2 suffix or 2 prefix, 1 suffix
                            let s0 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 0) in
                            let s1 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 1) in
                            let s2 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 2) in
                            let m0 = Stdlib.FingerTree.__nodeMeasure<a>(s0) in
                            let m1 = Stdlib.FingerTree.__nodeMeasure<a>(s1) in
                            let m2 = Stdlib.FingerTree.__nodeMeasure<a>(s2) in
                            let ptr = Stdlib.FingerTree.__allocDeep<a>(m0 + m1 + m2, 1, 2) in
                            let _ = Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 0, s0) in
                            let _ = Stdlib.FingerTree.__setDeepMiddle<a>(ptr, Stdlib.FingerTree.empty<a>()) in
                            let _ = Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 0, s1) in
                            let _ = Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 1, s2) in
                            Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_DEEP())
                        else
                            // Four elements: 2 prefix, 2 suffix
                            let s0 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 0) in
                            let s1 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 1) in
                            let s2 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 2) in
                            let s3 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 3) in
                            let m0 = Stdlib.FingerTree.__nodeMeasure<a>(s0) in
                            let m1 = Stdlib.FingerTree.__nodeMeasure<a>(s1) in
                            let m2 = Stdlib.FingerTree.__nodeMeasure<a>(s2) in
                            let m3 = Stdlib.FingerTree.__nodeMeasure<a>(s3) in
                            let ptr = Stdlib.FingerTree.__allocDeep<a>(m0 + m1 + m2 + m3, 2, 2) in
                            let _ = Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 0, s0) in
                            let _ = Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 1, s1) in
                            let _ = Stdlib.FingerTree.__setDeepMiddle<a>(ptr, Stdlib.FingerTree.empty<a>()) in
                            let _ = Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 0, s2) in
                            let _ = Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 1, s3) in
                            Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_DEEP())
                    else
                        // Borrow from middle - get head of middle (a NODE2 or NODE3)
                        // The head of middle becomes the new prefix (exploded)
                        let middleTag = Stdlib.FingerTree.__getTag<a>(middle) in
                        if middleTag == Stdlib.FingerTree.__TAG_SINGLE() then
                            // Middle is SINGLE(node) - explode node to prefix, empty middle
                            let node = Stdlib.FingerTree.__getSingleElem<a>(middle) in
                            let ntag = Stdlib.FingerTree.__getTag<a>(node) in
                            let suffixCount = Stdlib.FingerTree.__getDeepSuffixCount<a>(tree) in
                            if ntag == Stdlib.FingerTree.__TAG_NODE2() then
                                let c0 = Stdlib.FingerTree.__node2GetChild<a>(node, 0) in
                                let c1 = Stdlib.FingerTree.__node2GetChild<a>(node, 1) in
                                let newMeasure = Stdlib.FingerTree.__getDeepMeasure<a>(tree) - 1 in
                                let ptr = Stdlib.FingerTree.__allocDeep<a>(newMeasure, 2, suffixCount) in
                                let _ = Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 0, c0) in
                                let _ = Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 1, c1) in
                                let _ = Stdlib.FingerTree.__setDeepMiddle<a>(ptr, Stdlib.FingerTree.empty<a>()) in
                                let _ = if suffixCount >= 1 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 0, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 0)) else () in
                                let _ = if suffixCount >= 2 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 1, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 1)) else () in
                                let _ = if suffixCount >= 3 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 2, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 2)) else () in
                                let _ = if suffixCount >= 4 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 3, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 3)) else () in
                                Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_DEEP())
                            else if ntag == Stdlib.FingerTree.__TAG_NODE3() then
                                let c0 = Stdlib.FingerTree.__node3GetChild<a>(node, 0) in
                                let c1 = Stdlib.FingerTree.__node3GetChild<a>(node, 1) in
                                let c2 = Stdlib.FingerTree.__node3GetChild<a>(node, 2) in
                                let newMeasure = Stdlib.FingerTree.__getDeepMeasure<a>(tree) - 1 in
                                let ptr = Stdlib.FingerTree.__allocDeep<a>(newMeasure, 3, suffixCount) in
                                let _ = Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 0, c0) in
                                let _ = Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 1, c1) in
                                let _ = Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 2, c2) in
                                let _ = Stdlib.FingerTree.__setDeepMiddle<a>(ptr, Stdlib.FingerTree.empty<a>()) in
                                let _ = if suffixCount >= 1 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 0, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 0)) else () in
                                let _ = if suffixCount >= 2 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 1, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 1)) else () in
                                let _ = if suffixCount >= 3 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 2, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 2)) else () in
                                let _ = if suffixCount >= 4 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 3, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 3)) else () in
                                Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_DEEP())
                            else tree // Shouldn't happen
                        else if middleTag == Stdlib.FingerTree.__TAG_DEEP() then
                            // Middle is DEEP - need to call tail on middle to get new middle
                            // and use head of old middle as new prefix
                            let middleHeadOpt = Stdlib.FingerTree.head<a>(middle) in
                            // Actually we need to get the first NODE from middle, not element
                            // This is complex - let's use a simpler approach for now
                            // Just rebuild from elements 1 to end
                            let len = Stdlib.FingerTree.length<a>(tree) in
                            Stdlib.FingerTree.__rebuildFrom<a>(tree, 1, len, Stdlib.FingerTree.empty<a>())
                        else tree
            else
                // First prefix element is NODE2 or NODE3 - need to extract from it
                // Remove first element from node and put rest back as prefix
                // This is complex, use rebuild approach
                let len = Stdlib.FingerTree.length<a>(tree) in
                Stdlib.FingerTree.__rebuildFrom<a>(tree, 1, len, Stdlib.FingerTree.empty<a>())
        else Stdlib.FingerTree.empty<a>()

// Helper: rebuild tree from elements starting at index
def Stdlib.FingerTree.__rebuildFrom<a>(source: List<a>, idx: Int64, len: Int64, acc: List<a>) : List<a> =
    if idx >= len then acc
    else
        let elemOpt = Stdlib.FingerTree.getAt<a>(source, idx) in
        match elemOpt with
        | Some(elem) -> Stdlib.FingerTree.__rebuildFrom<a>(source, idx + 1, len, Stdlib.FingerTree.pushBack<a>(acc, elem))
        | None -> acc

// Create a single-element tree (wraps in LEAF, stores in SINGLE)
def Stdlib.FingerTree.singleton<a>(elem: a) : List<a> =
    let leaf = Stdlib.FingerTree.__allocLeaf<a>(elem) in
    Stdlib.FingerTree.__allocSingle<a>(leaf)

// Internal: push a TreeNode to front of tree (type-uniform - same type parameter!)
def Stdlib.FingerTree.__pushNode<a>(tree: List<a>, node: List<a>) : List<a> =
    if Stdlib.FingerTree.__isNull<a>(tree) then
        Stdlib.FingerTree.__allocSingle<a>(node)
    else
        let tag = Stdlib.FingerTree.__getTag<a>(tree) in
        if tag == Stdlib.FingerTree.__TAG_SINGLE() then
            // Single -> Deep with prefix=[node], suffix=[existing]
            let existing = Stdlib.FingerTree.__getSingleElem<a>(tree) in
            let nodeMeasure = Stdlib.FingerTree.__nodeMeasure<a>(node) in
            let existingMeasure = Stdlib.FingerTree.__nodeMeasure<a>(existing) in
            let ptr = Stdlib.FingerTree.__allocDeep<a>(nodeMeasure + existingMeasure, 1, 1) in
            let _ = Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 0, node) in
            let _ = Stdlib.FingerTree.__setDeepMiddle<a>(ptr, Stdlib.FingerTree.empty<a>()) in
            let _ = Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 0, existing) in
            Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_DEEP())
        else if tag == Stdlib.FingerTree.__TAG_DEEP() then
            let prefixCount = Stdlib.FingerTree.__getDeepPrefixCount<a>(tree) in
            let measure = Stdlib.FingerTree.__getDeepMeasure<a>(tree) in
            let nodeMeasure = Stdlib.FingerTree.__nodeMeasure<a>(node) in
            if prefixCount < 4 then
                // Room in prefix - shift and add
                let suffixCount = Stdlib.FingerTree.__getDeepSuffixCount<a>(tree) in
                let ptr = Stdlib.FingerTree.__allocDeep<a>(measure + nodeMeasure, prefixCount + 1, suffixCount) in
                // Set new node at front
                let _ = Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 0, node) in
                // Copy existing prefix (shifted by 1)
                let _ = if prefixCount >= 1 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 1, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 0)) else () in
                let _ = if prefixCount >= 2 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 2, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 1)) else () in
                let _ = if prefixCount >= 3 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 3, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 2)) else () in
                // Copy suffix
                let _ = if suffixCount >= 1 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 0, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 0)) else () in
                let _ = if suffixCount >= 2 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 1, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 1)) else () in
                let _ = if suffixCount >= 3 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 2, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 2)) else () in
                let _ = if suffixCount >= 4 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 3, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 3)) else () in
                // Copy middle
                let _ = Stdlib.FingerTree.__setDeepMiddle<a>(ptr, Stdlib.FingerTree.__getDeepMiddle<a>(tree)) in
                Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_DEEP())
            else
                // Prefix is full (4 nodes) - create NODE3 from 3 nodes, push to middle
                // Keep prefix[0] + new node as new prefix, push NODE3(prefix[1], prefix[2], prefix[3]) to middle
                let p1 = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 1) in
                let p2 = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 2) in
                let p3 = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 3) in
                let m1 = Stdlib.FingerTree.__nodeMeasure<a>(p1) in
                let m2 = Stdlib.FingerTree.__nodeMeasure<a>(p2) in
                let m3 = Stdlib.FingerTree.__nodeMeasure<a>(p3) in
                let node3 = Stdlib.FingerTree.__allocNode3<a>(p1, p2, p3, m1 + m2 + m3) in
                // Recursively push NODE3 to middle (same type parameter!)
                let newMiddle = Stdlib.FingerTree.__pushNode<a>(Stdlib.FingerTree.__getDeepMiddle<a>(tree), node3) in
                // Build new tree with prefix=[node, prefix[0]], new middle, same suffix
                let p0 = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 0) in
                let suffixCount = Stdlib.FingerTree.__getDeepSuffixCount<a>(tree) in
                let ptr = Stdlib.FingerTree.__allocDeep<a>(measure + nodeMeasure, 2, suffixCount) in
                let _ = Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 0, node) in
                let _ = Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 1, p0) in
                let _ = Stdlib.FingerTree.__setDeepMiddle<a>(ptr, newMiddle) in
                let _ = if suffixCount >= 1 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 0, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 0)) else () in
                let _ = if suffixCount >= 2 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 1, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 1)) else () in
                let _ = if suffixCount >= 3 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 2, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 2)) else () in
                let _ = if suffixCount >= 4 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 3, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 3)) else () in
                Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_DEEP())
        else
            // Unknown tag - just return singleton with node
            Stdlib.FingerTree.__allocSingle<a>(node)

// Add element to front (O(1) amortized)
def Stdlib.FingerTree.push<a>(tree: List<a>, elem: a) : List<a> =
    let leaf = Stdlib.FingerTree.__allocLeaf<a>(elem) in
    Stdlib.FingerTree.__pushNode<a>(tree, leaf)

// Internal: push a TreeNode to back of tree (type-uniform - same type parameter!)
def Stdlib.FingerTree.__pushBackNode<a>(tree: List<a>, node: List<a>) : List<a> =
    if Stdlib.FingerTree.__isNull<a>(tree) then
        Stdlib.FingerTree.__allocSingle<a>(node)
    else
        let tag = Stdlib.FingerTree.__getTag<a>(tree) in
        if tag == Stdlib.FingerTree.__TAG_SINGLE() then
            // Single -> Deep with prefix=[existing], suffix=[node]
            let existing = Stdlib.FingerTree.__getSingleElem<a>(tree) in
            let existingMeasure = Stdlib.FingerTree.__nodeMeasure<a>(existing) in
            let nodeMeasure = Stdlib.FingerTree.__nodeMeasure<a>(node) in
            let ptr = Stdlib.FingerTree.__allocDeep<a>(existingMeasure + nodeMeasure, 1, 1) in
            let _ = Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 0, existing) in
            let _ = Stdlib.FingerTree.__setDeepMiddle<a>(ptr, Stdlib.FingerTree.empty<a>()) in
            let _ = Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 0, node) in
            Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_DEEP())
        else if tag == Stdlib.FingerTree.__TAG_DEEP() then
            let suffixCount = Stdlib.FingerTree.__getDeepSuffixCount<a>(tree) in
            let measure = Stdlib.FingerTree.__getDeepMeasure<a>(tree) in
            let nodeMeasure = Stdlib.FingerTree.__nodeMeasure<a>(node) in
            if suffixCount < 4 then
                // Room in suffix - add at end
                let prefixCount = Stdlib.FingerTree.__getDeepPrefixCount<a>(tree) in
                let ptr = Stdlib.FingerTree.__allocDeep<a>(measure + nodeMeasure, prefixCount, suffixCount + 1) in
                // Copy prefix
                let _ = if prefixCount >= 1 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 0, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 0)) else () in
                let _ = if prefixCount >= 2 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 1, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 1)) else () in
                let _ = if prefixCount >= 3 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 2, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 2)) else () in
                let _ = if prefixCount >= 4 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 3, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 3)) else () in
                // Copy existing suffix and add new node
                let _ = if suffixCount >= 1 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 0, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 0)) else () in
                let _ = if suffixCount >= 2 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 1, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 1)) else () in
                let _ = if suffixCount >= 3 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 2, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 2)) else () in
                let _ = Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, suffixCount, node) in
                // Copy middle
                let _ = Stdlib.FingerTree.__setDeepMiddle<a>(ptr, Stdlib.FingerTree.__getDeepMiddle<a>(tree)) in
                Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_DEEP())
            else
                // Suffix is full (4 nodes) - create NODE3 from first 3, push to middle
                // Push NODE3(suffix[0], suffix[1], suffix[2]) to middle, keep suffix[3] + new node
                let s0 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 0) in
                let s1 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 1) in
                let s2 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 2) in
                let m0 = Stdlib.FingerTree.__nodeMeasure<a>(s0) in
                let m1 = Stdlib.FingerTree.__nodeMeasure<a>(s1) in
                let m2 = Stdlib.FingerTree.__nodeMeasure<a>(s2) in
                let node3 = Stdlib.FingerTree.__allocNode3<a>(s0, s1, s2, m0 + m1 + m2) in
                // Recursively push NODE3 to middle (same type parameter!)
                let newMiddle = Stdlib.FingerTree.__pushBackNode<a>(Stdlib.FingerTree.__getDeepMiddle<a>(tree), node3) in
                // Build new tree with same prefix, new middle, suffix=[suffix[3], node]
                let s3 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 3) in
                let prefixCount = Stdlib.FingerTree.__getDeepPrefixCount<a>(tree) in
                let ptr = Stdlib.FingerTree.__allocDeep<a>(measure + nodeMeasure, prefixCount, 2) in
                let _ = if prefixCount >= 1 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 0, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 0)) else () in
                let _ = if prefixCount >= 2 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 1, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 1)) else () in
                let _ = if prefixCount >= 3 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 2, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 2)) else () in
                let _ = if prefixCount >= 4 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 3, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 3)) else () in
                let _ = Stdlib.FingerTree.__setDeepMiddle<a>(ptr, newMiddle) in
                let _ = Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 0, s3) in
                let _ = Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 1, node) in
                Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_DEEP())
        else
            // Unknown tag - just return singleton with node
            Stdlib.FingerTree.__allocSingle<a>(node)

// Add element to back (O(1) amortized)
def Stdlib.FingerTree.pushBack<a>(tree: List<a>, elem: a) : List<a> =
    let leaf = Stdlib.FingerTree.__allocLeaf<a>(elem) in
    Stdlib.FingerTree.__pushBackNode<a>(tree, leaf)

// Helper: get element at index within a TreeNode
def Stdlib.FingerTree.__getAtNode<a>(node: List<a>, index: Int64) : a =
    let tag = Stdlib.FingerTree.__getTag<a>(node) in
    if tag == Stdlib.FingerTree.__TAG_LEAF() then
        Stdlib.FingerTree.__getLeafValue<a>(node)
    else if tag == Stdlib.FingerTree.__TAG_NODE2() then
        let c0 = Stdlib.FingerTree.__node2GetChild<a>(node, 0) in
        let m0 = Stdlib.FingerTree.__nodeMeasure<a>(c0) in
        if index < m0 then
            Stdlib.FingerTree.__getAtNode<a>(c0, index)
        else
            let c1 = Stdlib.FingerTree.__node2GetChild<a>(node, 1) in
            Stdlib.FingerTree.__getAtNode<a>(c1, index - m0)
    else if tag == Stdlib.FingerTree.__TAG_NODE3() then
        let c0 = Stdlib.FingerTree.__node3GetChild<a>(node, 0) in
        let m0 = Stdlib.FingerTree.__nodeMeasure<a>(c0) in
        if index < m0 then
            Stdlib.FingerTree.__getAtNode<a>(c0, index)
        else
            let c1 = Stdlib.FingerTree.__node3GetChild<a>(node, 1) in
            let m1 = Stdlib.FingerTree.__nodeMeasure<a>(c1) in
            if index < m0 + m1 then
                Stdlib.FingerTree.__getAtNode<a>(c1, index - m0)
            else
                let c2 = Stdlib.FingerTree.__node3GetChild<a>(node, 2) in
                Stdlib.FingerTree.__getAtNode<a>(c2, index - m0 - m1)
    else
        // Fallback - shouldn't happen
        Stdlib.FingerTree.__getLeafValue<a>(node)

// Get element at index (O(log n))
def Stdlib.FingerTree.getAt<a>(tree: List<a>, index: Int64) : Stdlib.Option.Option<a> =
    if index < 0 then None
    else if Stdlib.FingerTree.__isNull<a>(tree) then None
    else
        let tag = Stdlib.FingerTree.__getTag<a>(tree) in
        if tag == Stdlib.FingerTree.__TAG_SINGLE() then
            let node = Stdlib.FingerTree.__getSingleElem<a>(tree) in
            let nodeMeasure = Stdlib.FingerTree.__nodeMeasure<a>(node) in
            if index < nodeMeasure then
                Some(Stdlib.FingerTree.__getAtNode<a>(node, index))
            else None
        else if tag == Stdlib.FingerTree.__TAG_DEEP() then
            let measure = Stdlib.FingerTree.__getDeepMeasure<a>(tree) in
            if index >= measure then None
            else Stdlib.FingerTree.__getAtDeep<a>(tree, index)
        else None

// Internal: get element from Deep node at index
def Stdlib.FingerTree.__getAtDeep<a>(tree: List<a>, index: Int64) : Stdlib.Option.Option<a> =
    let prefixCount = Stdlib.FingerTree.__getDeepPrefixCount<a>(tree) in
    // Calculate prefix measure (sum of node measures in prefix)
    let prefixMeasure = Stdlib.FingerTree.__prefixMeasure<a>(tree, prefixCount) in
    if index < prefixMeasure then
        // Element is in prefix - find which prefix node and index within it
        Some(Stdlib.FingerTree.__getAtPrefix<a>(tree, prefixCount, index))
    else
        let middle = Stdlib.FingerTree.__getDeepMiddle<a>(tree) in
        let middleMeasure = Stdlib.FingerTree.length<a>(middle) in
        if index < prefixMeasure + middleMeasure then
            // Element is in middle
            Stdlib.FingerTree.getAt<a>(middle, index - prefixMeasure)
        else
            // Element is in suffix
            let indexInSuffix = index - prefixMeasure - middleMeasure in
            let suffixCount = Stdlib.FingerTree.__getDeepSuffixCount<a>(tree) in
            Some(Stdlib.FingerTree.__getAtSuffix<a>(tree, suffixCount, indexInSuffix))

// Helper: calculate total measure of prefix
def Stdlib.FingerTree.__prefixMeasure<a>(tree: List<a>, prefixCount: Int64) : Int64 =
    if prefixCount == 0 then 0
    else if prefixCount == 1 then
        Stdlib.FingerTree.__nodeMeasure<a>(Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 0))
    else if prefixCount == 2 then
        Stdlib.FingerTree.__nodeMeasure<a>(Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 0)) +
        Stdlib.FingerTree.__nodeMeasure<a>(Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 1))
    else if prefixCount == 3 then
        Stdlib.FingerTree.__nodeMeasure<a>(Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 0)) +
        Stdlib.FingerTree.__nodeMeasure<a>(Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 1)) +
        Stdlib.FingerTree.__nodeMeasure<a>(Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 2))
    else
        Stdlib.FingerTree.__nodeMeasure<a>(Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 0)) +
        Stdlib.FingerTree.__nodeMeasure<a>(Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 1)) +
        Stdlib.FingerTree.__nodeMeasure<a>(Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 2)) +
        Stdlib.FingerTree.__nodeMeasure<a>(Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 3))

// Helper: get element at index within prefix
def Stdlib.FingerTree.__getAtPrefix<a>(tree: List<a>, prefixCount: Int64, index: Int64) : a =
    let p0 = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 0) in
    let m0 = Stdlib.FingerTree.__nodeMeasure<a>(p0) in
    if index < m0 then
        Stdlib.FingerTree.__getAtNode<a>(p0, index)
    else if prefixCount >= 2 then
        let p1 = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 1) in
        let m1 = Stdlib.FingerTree.__nodeMeasure<a>(p1) in
        if index < m0 + m1 then
            Stdlib.FingerTree.__getAtNode<a>(p1, index - m0)
        else if prefixCount >= 3 then
            let p2 = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 2) in
            let m2 = Stdlib.FingerTree.__nodeMeasure<a>(p2) in
            if index < m0 + m1 + m2 then
                Stdlib.FingerTree.__getAtNode<a>(p2, index - m0 - m1)
            else
                let p3 = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 3) in
                Stdlib.FingerTree.__getAtNode<a>(p3, index - m0 - m1 - m2)
        else
            Stdlib.FingerTree.__getAtNode<a>(p1, index - m0)
    else
        Stdlib.FingerTree.__getAtNode<a>(p0, index)

// Helper: get element at index within suffix
def Stdlib.FingerTree.__getAtSuffix<a>(tree: List<a>, suffixCount: Int64, index: Int64) : a =
    let s0 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 0) in
    let m0 = Stdlib.FingerTree.__nodeMeasure<a>(s0) in
    if index < m0 then
        Stdlib.FingerTree.__getAtNode<a>(s0, index)
    else if suffixCount >= 2 then
        let s1 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 1) in
        let m1 = Stdlib.FingerTree.__nodeMeasure<a>(s1) in
        if index < m0 + m1 then
            Stdlib.FingerTree.__getAtNode<a>(s1, index - m0)
        else if suffixCount >= 3 then
            let s2 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 2) in
            let m2 = Stdlib.FingerTree.__nodeMeasure<a>(s2) in
            if index < m0 + m1 + m2 then
                Stdlib.FingerTree.__getAtNode<a>(s2, index - m0 - m1)
            else
                let s3 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 3) in
                Stdlib.FingerTree.__getAtNode<a>(s3, index - m0 - m1 - m2)
        else
            Stdlib.FingerTree.__getAtNode<a>(s1, index - m0)
    else
        Stdlib.FingerTree.__getAtNode<a>(s0, index)

// Helper: update an element at index within a TreeNode, returning a new TreeNode
def Stdlib.FingerTree.__setAtNode<a>(node: List<a>, index: Int64, value: a) : List<a> =
    let tag = Stdlib.FingerTree.__getTag<a>(node) in
    if tag == Stdlib.FingerTree.__TAG_LEAF() then
        // LEAF - just create new leaf with value
        Stdlib.FingerTree.__allocLeaf<a>(value)
    else if tag == Stdlib.FingerTree.__TAG_NODE2() then
        let c0 = Stdlib.FingerTree.__node2GetChild<a>(node, 0) in
        let m0 = Stdlib.FingerTree.__nodeMeasure<a>(c0) in
        if index < m0 then
            // Update in first child
            let newC0 = Stdlib.FingerTree.__setAtNode<a>(c0, index, value) in
            let c1 = Stdlib.FingerTree.__node2GetChild<a>(node, 1) in
            let m1 = Stdlib.FingerTree.__nodeMeasure<a>(c1) in
            Stdlib.FingerTree.__allocNode2<a>(newC0, c1, m0 + m1)
        else
            // Update in second child
            let c1 = Stdlib.FingerTree.__node2GetChild<a>(node, 1) in
            let newC1 = Stdlib.FingerTree.__setAtNode<a>(c1, index - m0, value) in
            let m1 = Stdlib.FingerTree.__nodeMeasure<a>(c1) in
            Stdlib.FingerTree.__allocNode2<a>(c0, newC1, m0 + m1)
    else if tag == Stdlib.FingerTree.__TAG_NODE3() then
        let c0 = Stdlib.FingerTree.__node3GetChild<a>(node, 0) in
        let m0 = Stdlib.FingerTree.__nodeMeasure<a>(c0) in
        if index < m0 then
            // Update in first child
            let newC0 = Stdlib.FingerTree.__setAtNode<a>(c0, index, value) in
            let c1 = Stdlib.FingerTree.__node3GetChild<a>(node, 1) in
            let c2 = Stdlib.FingerTree.__node3GetChild<a>(node, 2) in
            let m1 = Stdlib.FingerTree.__nodeMeasure<a>(c1) in
            let m2 = Stdlib.FingerTree.__nodeMeasure<a>(c2) in
            Stdlib.FingerTree.__allocNode3<a>(newC0, c1, c2, m0 + m1 + m2)
        else
            let c1 = Stdlib.FingerTree.__node3GetChild<a>(node, 1) in
            let m1 = Stdlib.FingerTree.__nodeMeasure<a>(c1) in
            if index < m0 + m1 then
                // Update in second child
                let newC1 = Stdlib.FingerTree.__setAtNode<a>(c1, index - m0, value) in
                let c2 = Stdlib.FingerTree.__node3GetChild<a>(node, 2) in
                let m2 = Stdlib.FingerTree.__nodeMeasure<a>(c2) in
                Stdlib.FingerTree.__allocNode3<a>(c0, newC1, c2, m0 + m1 + m2)
            else
                // Update in third child
                let c2 = Stdlib.FingerTree.__node3GetChild<a>(node, 2) in
                let newC2 = Stdlib.FingerTree.__setAtNode<a>(c2, index - m0 - m1, value) in
                let m2 = Stdlib.FingerTree.__nodeMeasure<a>(c2) in
                Stdlib.FingerTree.__allocNode3<a>(c0, c1, newC2, m0 + m1 + m2)
    else
        // Fallback - shouldn't happen
        node

// Set element at index (O(log n) - creates new tree with updated element)
def Stdlib.FingerTree.setAt<a>(tree: List<a>, index: Int64, value: a) : List<a> =
    if index < 0 then tree
    else if Stdlib.FingerTree.__isNull<a>(tree) then tree
    else
        let tag = Stdlib.FingerTree.__getTag<a>(tree) in
        if tag == Stdlib.FingerTree.__TAG_SINGLE() then
            let node = Stdlib.FingerTree.__getSingleElem<a>(tree) in
            let nodeMeasure = Stdlib.FingerTree.__nodeMeasure<a>(node) in
            if index < nodeMeasure then
                let newNode = Stdlib.FingerTree.__setAtNode<a>(node, index, value) in
                Stdlib.FingerTree.__allocSingle<a>(newNode)
            else tree
        else if tag == Stdlib.FingerTree.__TAG_DEEP() then
            let measure = Stdlib.FingerTree.__getDeepMeasure<a>(tree) in
            if index >= measure then tree
            else Stdlib.FingerTree.__setAtDeep<a>(tree, index, value)
        else tree

// Helper: set element at index within prefix, returning the updated TreeNode at that position
def Stdlib.FingerTree.__setAtPrefixGetNode<a>(tree: List<a>, prefixCount: Int64, index: Int64, value: a) : List<a> =
    let p0 = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 0) in
    let m0 = Stdlib.FingerTree.__nodeMeasure<a>(p0) in
    if index < m0 then
        Stdlib.FingerTree.__setAtNode<a>(p0, index, value)
    else if prefixCount >= 2 then
        let p1 = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 1) in
        let m1 = Stdlib.FingerTree.__nodeMeasure<a>(p1) in
        if index < m0 + m1 then
            Stdlib.FingerTree.__setAtNode<a>(p1, index - m0, value)
        else if prefixCount >= 3 then
            let p2 = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 2) in
            let m2 = Stdlib.FingerTree.__nodeMeasure<a>(p2) in
            if index < m0 + m1 + m2 then
                Stdlib.FingerTree.__setAtNode<a>(p2, index - m0 - m1, value)
            else
                let p3 = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 3) in
                Stdlib.FingerTree.__setAtNode<a>(p3, index - m0 - m1 - m2, value)
        else
            Stdlib.FingerTree.__setAtNode<a>(p1, index - m0, value)
    else
        Stdlib.FingerTree.__setAtNode<a>(p0, index, value)

// Helper: find which prefix node contains the index (returns node index 0-3)
def Stdlib.FingerTree.__findPrefixNodeIdx<a>(tree: List<a>, prefixCount: Int64, index: Int64) : Int64 =
    let p0 = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 0) in
    let m0 = Stdlib.FingerTree.__nodeMeasure<a>(p0) in
    if index < m0 then 0
    else if prefixCount >= 2 then
        let p1 = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 1) in
        let m1 = Stdlib.FingerTree.__nodeMeasure<a>(p1) in
        if index < m0 + m1 then 1
        else if prefixCount >= 3 then
            let p2 = Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 2) in
            let m2 = Stdlib.FingerTree.__nodeMeasure<a>(p2) in
            if index < m0 + m1 + m2 then 2
            else 3
        else 1
    else 0

// Helper: find which suffix node contains the index (returns node index 0-3)
def Stdlib.FingerTree.__findSuffixNodeIdx<a>(tree: List<a>, suffixCount: Int64, index: Int64) : Int64 =
    let s0 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 0) in
    let m0 = Stdlib.FingerTree.__nodeMeasure<a>(s0) in
    if index < m0 then 0
    else if suffixCount >= 2 then
        let s1 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 1) in
        let m1 = Stdlib.FingerTree.__nodeMeasure<a>(s1) in
        if index < m0 + m1 then 1
        else if suffixCount >= 3 then
            let s2 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 2) in
            let m2 = Stdlib.FingerTree.__nodeMeasure<a>(s2) in
            if index < m0 + m1 + m2 then 2
            else 3
        else 1
    else 0

// Helper: set element at index within suffix, returning the updated TreeNode
def Stdlib.FingerTree.__setAtSuffixGetNode<a>(tree: List<a>, suffixCount: Int64, index: Int64, value: a) : List<a> =
    let s0 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 0) in
    let m0 = Stdlib.FingerTree.__nodeMeasure<a>(s0) in
    if index < m0 then
        Stdlib.FingerTree.__setAtNode<a>(s0, index, value)
    else if suffixCount >= 2 then
        let s1 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 1) in
        let m1 = Stdlib.FingerTree.__nodeMeasure<a>(s1) in
        if index < m0 + m1 then
            Stdlib.FingerTree.__setAtNode<a>(s1, index - m0, value)
        else if suffixCount >= 3 then
            let s2 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 2) in
            let m2 = Stdlib.FingerTree.__nodeMeasure<a>(s2) in
            if index < m0 + m1 + m2 then
                Stdlib.FingerTree.__setAtNode<a>(s2, index - m0 - m1, value)
            else
                let s3 = Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 3) in
                Stdlib.FingerTree.__setAtNode<a>(s3, index - m0 - m1 - m2, value)
        else
            Stdlib.FingerTree.__setAtNode<a>(s1, index - m0, value)
    else
        Stdlib.FingerTree.__setAtNode<a>(s0, index, value)

// Internal: set element in Deep node at index
def Stdlib.FingerTree.__setAtDeep<a>(tree: List<a>, index: Int64, value: a) : List<a> =
    let prefixCount = Stdlib.FingerTree.__getDeepPrefixCount<a>(tree) in
    let suffixCount = Stdlib.FingerTree.__getDeepSuffixCount<a>(tree) in
    let measure = Stdlib.FingerTree.__getDeepMeasure<a>(tree) in
    let prefixMeasure = Stdlib.FingerTree.__prefixMeasure<a>(tree, prefixCount) in
    if index < prefixMeasure then
        // Element is in prefix - find node, update it, rebuild tree
        let nodeIdx = Stdlib.FingerTree.__findPrefixNodeIdx<a>(tree, prefixCount, index) in
        let newNode = Stdlib.FingerTree.__setAtPrefixGetNode<a>(tree, prefixCount, index, value) in
        let ptr = Stdlib.FingerTree.__allocDeep<a>(measure, prefixCount, suffixCount) in
        // Copy prefix with the updated node at nodeIdx
        let _ = if prefixCount >= 1 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 0, if nodeIdx == 0 then newNode else Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 0)) else () in
        let _ = if prefixCount >= 2 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 1, if nodeIdx == 1 then newNode else Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 1)) else () in
        let _ = if prefixCount >= 3 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 2, if nodeIdx == 2 then newNode else Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 2)) else () in
        let _ = if prefixCount >= 4 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 3, if nodeIdx == 3 then newNode else Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 3)) else () in
        // Copy suffix unchanged
        let _ = if suffixCount >= 1 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 0, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 0)) else () in
        let _ = if suffixCount >= 2 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 1, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 1)) else () in
        let _ = if suffixCount >= 3 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 2, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 2)) else () in
        let _ = if suffixCount >= 4 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 3, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 3)) else () in
        // Copy middle unchanged
        let _ = Stdlib.FingerTree.__setDeepMiddle<a>(ptr, Stdlib.FingerTree.__getDeepMiddle<a>(tree)) in
        Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_DEEP())
    else
        let middle = Stdlib.FingerTree.__getDeepMiddle<a>(tree) in
        let middleMeasure = Stdlib.FingerTree.length<a>(middle) in
        if index < prefixMeasure + middleMeasure then
            // Element is in middle - recursively update middle
            let newMiddle = Stdlib.FingerTree.setAt<a>(middle, index - prefixMeasure, value) in
            let ptr = Stdlib.FingerTree.__allocDeep<a>(measure, prefixCount, suffixCount) in
            // Copy prefix unchanged
            let _ = if prefixCount >= 1 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 0, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 0)) else () in
            let _ = if prefixCount >= 2 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 1, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 1)) else () in
            let _ = if prefixCount >= 3 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 2, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 2)) else () in
            let _ = if prefixCount >= 4 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 3, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 3)) else () in
            // Copy suffix unchanged
            let _ = if suffixCount >= 1 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 0, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 0)) else () in
            let _ = if suffixCount >= 2 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 1, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 1)) else () in
            let _ = if suffixCount >= 3 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 2, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 2)) else () in
            let _ = if suffixCount >= 4 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 3, Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 3)) else () in
            // Set updated middle
            let _ = Stdlib.FingerTree.__setDeepMiddle<a>(ptr, newMiddle) in
            Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_DEEP())
        else
            // Element is in suffix
            let indexInSuffix = index - prefixMeasure - middleMeasure in
            let nodeIdx = Stdlib.FingerTree.__findSuffixNodeIdx<a>(tree, suffixCount, indexInSuffix) in
            let newNode = Stdlib.FingerTree.__setAtSuffixGetNode<a>(tree, suffixCount, indexInSuffix, value) in
            let ptr = Stdlib.FingerTree.__allocDeep<a>(measure, prefixCount, suffixCount) in
            // Copy prefix unchanged
            let _ = if prefixCount >= 1 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 0, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 0)) else () in
            let _ = if prefixCount >= 2 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 1, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 1)) else () in
            let _ = if prefixCount >= 3 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 2, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 2)) else () in
            let _ = if prefixCount >= 4 then Stdlib.FingerTree.__setDeepPrefixAt<a>(ptr, 3, Stdlib.FingerTree.__getDeepPrefixAt<a>(tree, 3)) else () in
            // Copy suffix with the updated node at nodeIdx
            let _ = if suffixCount >= 1 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 0, if nodeIdx == 0 then newNode else Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 0)) else () in
            let _ = if suffixCount >= 2 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 1, if nodeIdx == 1 then newNode else Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 1)) else () in
            let _ = if suffixCount >= 3 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 2, if nodeIdx == 2 then newNode else Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 2)) else () in
            let _ = if suffixCount >= 4 then Stdlib.FingerTree.__setDeepSuffixAt<a>(ptr, 3, if nodeIdx == 3 then newNode else Stdlib.FingerTree.__getDeepSuffixAt<a>(tree, 3)) else () in
            // Copy middle unchanged
            let _ = Stdlib.FingerTree.__setDeepMiddle<a>(ptr, Stdlib.FingerTree.__getDeepMiddle<a>(tree)) in
            Stdlib.FingerTree.__fromRawPtr<a>(ptr, Stdlib.FingerTree.__TAG_DEEP())

// Convert list to FingerTree
def Stdlib.FingerTree.fromList<a>(list: List<a>) : List<a> =
    Stdlib.FingerTree.__fromListHelper<a>(list, Stdlib.FingerTree.empty<a>())

def Stdlib.FingerTree.__fromListHelper<a>(list: List<a>, acc: List<a>) : List<a> =
    match list with
    | [] -> acc
    | [h, ...t] -> Stdlib.FingerTree.__fromListHelper<a>(t, Stdlib.FingerTree.pushBack<a>(acc, h))
