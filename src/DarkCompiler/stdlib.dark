// Stdlib.dark - Standard Library Functions
//
// These functions are automatically included in all Dark programs.
// They provide the built-in Stdlib modules.

// Stdlib.Int64 - Integer operations

def Stdlib.Int64.add(a: Int64, b: Int64) : Int64 = a + b

def Stdlib.Int64.sub(a: Int64, b: Int64) : Int64 = a - b

def Stdlib.Int64.mul(a: Int64, b: Int64) : Int64 = a * b

def Stdlib.Int64.div(a: Int64, b: Int64) : Int64 = a / b

def Stdlib.Int64.max(a: Int64, b: Int64) : Int64 = if a > b then a else b

def Stdlib.Int64.min(a: Int64, b: Int64) : Int64 = if a < b then a else b

def Stdlib.Int64.mod(a: Int64, b: Int64) : Int64 = a % b

def Stdlib.Int64.absoluteValue(a: Int64) : Int64 = if a < 0 then 0 - a else a

def Stdlib.Int64.negate(a: Int64) : Int64 = 0 - a

def Stdlib.Int64.power(base: Int64, exponent: Int64) : Int64 =
    if exponent == 0 then 1
    else if exponent == 1 then base
    else base * Stdlib.Int64.power(base, exponent - 1)

def Stdlib.Int64.clamp(value: Int64, limitA: Int64, limitB: Int64) : Int64 =
    let lower = Stdlib.Int64.min(limitA, limitB) in
    let upper = Stdlib.Int64.max(limitA, limitB) in
    Stdlib.Int64.max(lower, Stdlib.Int64.min(upper, value))

def Stdlib.Int64.greaterThan(a: Int64, b: Int64) : Bool = a > b

def Stdlib.Int64.greaterThanOrEqualTo(a: Int64, b: Int64) : Bool = a >= b

def Stdlib.Int64.lessThan(a: Int64, b: Int64) : Bool = a < b

def Stdlib.Int64.lessThanOrEqualTo(a: Int64, b: Int64) : Bool = a <= b

// Bitwise operations
def Stdlib.Int64.bitwiseAnd(a: Int64, b: Int64) : Int64 = a & b

def Stdlib.Int64.bitwiseXor(a: Int64, b: Int64) : Int64 = a ^ b

def Stdlib.Int64.shiftLeft(a: Int64, shift: Int64) : Int64 = a << shift

def Stdlib.Int64.shiftRight(a: Int64, shift: Int64) : Int64 = a >> shift

// Count number of set bits (population count)
// Uses parallel bit counting algorithm (Brian Kernighan / SWAR)
def Stdlib.Int64.popcount(x: Int64) : Int64 =
    // Constants (in decimal):
    // 0x5555555555555555 = 6148914691236517205
    // 0x3333333333333333 = 3689348814741910323
    // 0x0F0F0F0F0F0F0F0F = 1085102592571150095
    // 0x0101010101010101 = 72340172838076673
    let mask1 = 6148914691236517205 in
    let mask2 = 3689348814741910323 in
    let mask3 = 1085102592571150095 in
    let mult = 72340172838076673 in
    let x = x - ((x >> 1) & mask1) in
    let x = (x & mask2) + ((x >> 2) & mask2) in
    let x = (x + (x >> 4)) & mask3 in
    (x * mult) >> 56

// Convert a single digit (0-9) to its string representation
def Stdlib.Int64.digitToString(n: Int64) : String =
    match n with
    | 0 -> "0"
    | 1 -> "1"
    | 2 -> "2"
    | 3 -> "3"
    | 4 -> "4"
    | 5 -> "5"
    | 6 -> "6"
    | 7 -> "7"
    | 8 -> "8"
    | 9 -> "9"
    | _ -> "?"

// Convert an integer to its string representation
def Stdlib.Int64.toString(n: Int64) : String =
    if n < 0 then "-" ++ Stdlib.Int64.toString(0 - n)
    else if n < 10 then Stdlib.Int64.digitToString(n)
    else Stdlib.Int64.toString(n / 10) ++ Stdlib.Int64.digitToString(n % 10)

// Stdlib.Bool - Boolean operations

def Stdlib.Bool.not(b: Bool) : Bool = !b

def Stdlib.Bool.and(a: Bool, b: Bool) : Bool = a && b

def Stdlib.Bool.or(a: Bool, b: Bool) : Bool = a || b

def Stdlib.Bool.xor(a: Bool, b: Bool) : Bool = if a then !b else b

def Stdlib.Bool.toString(b: Bool) : String = if b then "true" else "false"

// Stdlib.Tuple2 - 2-tuple operations

def Stdlib.Tuple2.create<a, b>(first: a, second: b) : (a, b) = (first, second)

def Stdlib.Tuple2.first<a, b>(t: (a, b)) : a = match t with | (x, y) -> x

def Stdlib.Tuple2.second<a, b>(t: (a, b)) : b = match t with | (x, y) -> y

def Stdlib.Tuple2.swap<a, b>(t: (a, b)) : (b, a) = match t with | (x, y) -> (y, x)

def Stdlib.Tuple2.mapFirst<a, b, c>(fn: (a) -> c, t: (a, b)) : (c, b) =
    match t with | (x, y) -> (fn(x), y)

def Stdlib.Tuple2.mapSecond<a, b, c>(fn: (b) -> c, t: (a, b)) : (a, c) =
    match t with | (x, y) -> (x, fn(y))

def Stdlib.Tuple2.mapBoth<a, b, c, d>(fnFirst: (a) -> c, fnSecond: (b) -> d, t: (a, b)) : (c, d) =
    match t with | (x, y) -> (fnFirst(x), fnSecond(y))

// Stdlib.Tuple3 - 3-tuple operations

def Stdlib.Tuple3.create<a, b, c>(first: a, second: b, third: c) : (a, b, c) = (first, second, third)

def Stdlib.Tuple3.first<a, b, c>(t: (a, b, c)) : a = match t with | (x, y, z) -> x

def Stdlib.Tuple3.second<a, b, c>(t: (a, b, c)) : b = match t with | (x, y, z) -> y

def Stdlib.Tuple3.third<a, b, c>(t: (a, b, c)) : c = match t with | (x, y, z) -> z

def Stdlib.Tuple3.mapFirst<a, b, c, d>(fn: (a) -> d, t: (a, b, c)) : (d, b, c) =
    match t with | (x, y, z) -> (fn(x), y, z)

def Stdlib.Tuple3.mapSecond<a, b, c, d>(fn: (b) -> d, t: (a, b, c)) : (a, d, c) =
    match t with | (x, y, z) -> (x, fn(y), z)

def Stdlib.Tuple3.mapThird<a, b, c, d>(fn: (c) -> d, t: (a, b, c)) : (a, b, d) =
    match t with | (x, y, z) -> (x, y, fn(z))

def Stdlib.Tuple3.mapAllThree<a, b, c, d, e, f>(fnFirst: (a) -> d, fnSecond: (b) -> e, fnThird: (c) -> f, t: (a, b, c)) : (d, e, f) =
    match t with | (x, y, z) -> (fnFirst(x), fnSecond(y), fnThird(z))

// Stdlib.Result - Result type for error handling
type Stdlib.Result.Result<t, e> = Ok of t | Error of e

// Stdlib.Option - Optional values
type Stdlib.Option.Option<t> = Some of t | None

// Stdlib.List - List operations
// Lists are represented as: Nil = 0, Cons = [tag=1, head, tail]

// Check if list is empty
def Stdlib.List.isEmpty<t>(list: List<t>) : Bool =
    match list with
    | [] -> true
    | _ -> false

// Get the length of a list
def Stdlib.List.length<t>(list: List<t>) : Int64 =
    match list with
    | [] -> 0
    | [h, ...rest] -> 1 + Stdlib.List.length<t>(rest)

// Create a single-element list
def Stdlib.List.singleton<t>(value: t) : List<t> = [value]

// Prepend an element to a list
def Stdlib.List.push<t>(list: List<t>, value: t) : List<t> = [value, ...list]

// TODO: Many List functions are blocked by type checker bug with generic recursion.
// The type checker doesn't properly handle recursive calls that return generic List<t>.
// push, pushBack, append, reverse, filter, map, fold, take, drop all hit this bug.
// These functions compile with list spread syntax but fail type checking.
// This is related to Bug 1 (generic enum pattern matching).

// TODO: Functions that require Option/Result return types are blocked by type checker bug
// head, tail, last, getAt, findFirst - require Stdlib.Option.Option<t> returns

// Stdlib.String - String operations

// Newline constant (nullary function)
def Stdlib.String.newline() : String = "\n"

// Append two strings
def Stdlib.String.append(s1: String, s2: String) : String = s1 ++ s2

// Prepend first string to second
def Stdlib.String.prepend(s2: String, s1: String) : String = s1 ++ s2

// TODO: Most String functions require runtime builtins that don't exist yet
// length, isEmpty, toUppercase, toLowercase, contains, startsWith, endsWith,
// trim, slice, first, last, reverse, replaceAll, etc.

// =============================================================================
// Stdlib.Dict - Immutable Dictionary using HAMT (Hash Array Mapped Trie)
// =============================================================================

// HAMT internal helper functions for working with bitmaps
// These are the building blocks for the Dict implementation

// Get 6-bit chunk of hash at given level (0-10)
// For a 64-bit hash, there are up to 11 levels (6 bits per level)
def Stdlib.Dict.hashChunk(hash: Int64, level: Int64) : Int64 =
    (hash >> (level * 6)) & 63

// Check if bit is set in bitmap
def Stdlib.Dict.hasBit(bitmap: Int64, bit: Int64) : Bool =
    ((bitmap >> bit) & 1) == 1

// Count bits below position in bitmap (for compressed array index)
def Stdlib.Dict.childIndex(bitmap: Int64, bit: Int64) : Int64 =
    Stdlib.Int64.popcount(bitmap & ((1 << bit) - 1))

// Set a bit in bitmap
def Stdlib.Dict.setBit(bitmap: Int64, bit: Int64) : Int64 =
    bitmap ^ (1 << bit)

// Clear a bit in bitmap (for remove)
// Note: ~x = (-1) ^ x (XOR with all ones)
def Stdlib.Dict.clearBit(bitmap: Int64, bit: Int64) : Int64 =
    bitmap & (((0 - 1)) ^ (1 << bit))

// =============================================================================
// Pointer tagging helpers
// =============================================================================
// We use the low 2 bits of pointers for tags (since 8-byte alignment gives us 3 free bits)
// Tag 0: Empty (NULL)
// Tag 1: Internal node (bitmap + children)
// Tag 2: Leaf node (key + value)
// Tag 3: Collision node (multiple entries with same hash prefix) - not yet implemented

// Get tag from a tagged pointer
def Stdlib.Dict.__getTag(ptr: Int64) : Int64 =
    ptr & 3

// Clear tag bits to get actual pointer
// Note: ~3 = -4 (all bits set except lowest 2)
def Stdlib.Dict.__clearTag(ptr: Int64) : Int64 =
    ptr & (0 - 4)

// Set tag on a pointer (assumes ptr has no existing tag)
def Stdlib.Dict.__setTag(ptr: Int64, tag: Int64) : Int64 =
    ptr ^ tag

// Allocate a leaf node: [key:8][value:8] = 16 bytes
def Stdlib.Dict.__allocLeaf(key: Int64, value: Int64) : Int64 =
    let ptr = __raw_alloc(16) in
    let _ = __raw_set(ptr, 0, key) in
    let _ = __raw_set(ptr, 8, value) in
    Stdlib.Dict.__setTag(__rawptr_to_int64(ptr), 2)

// Allocate an internal node: [bitmap:8][children...] = 8 + 8*numChildren bytes
def Stdlib.Dict.__allocInternal(bitmap: Int64, numChildren: Int64) : RawPtr =
    let ptr = __raw_alloc(8 + (numChildren * 8)) in
    let _ = __raw_set(ptr, 0, bitmap) in
    ptr

// =============================================================================
// Dict.empty - returns an empty dictionary
// =============================================================================
// Empty is represented as 0 (NULL with tag 0)
def Stdlib.Dict.empty() : Int64 = 0

// =============================================================================
// Dict.get - lookup a key in the dictionary
// =============================================================================
// Returns the value if found (as Int64), or -1 if not found
// TODO: Should return Option<V> once we have proper Option support

// Get helper - recursive lookup
def Stdlib.Dict.__getHelper(node: Int64, key: Int64, level: Int64) : Int64 =
    if node == 0 then
        // Empty - key not found
        0 - 1
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            // Leaf node
            let storedKey = __raw_get(ptr, 0) in
            if storedKey == key then
                __raw_get(ptr, 8)
            else
                0 - 1
        else if tag == 1 then
            // Internal node
            let chunk = Stdlib.Dict.hashChunk(key, level) in
            let bitmap = __raw_get(ptr, 0) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
                let child = __raw_get(ptr, 8 + (idx * 8)) in
                Stdlib.Dict.__getHelper(child, key, level + 1)
            else
                0 - 1
        else
            // Unknown tag (collision node not yet implemented)
            0 - 1

def Stdlib.Dict.get(dict: Int64, key: Int64) : Int64 =
    Stdlib.Dict.__getHelper(dict, key, 0)

// =============================================================================
// Dict.set - insert or update a key-value pair
// =============================================================================
// Returns a new dictionary with the key-value pair added/updated

// Set helper - recursive insert
def Stdlib.Dict.__setHelper(node: Int64, key: Int64, value: Int64, level: Int64) : Int64 =
    if node == 0 then
        // Empty - create a new leaf
        Stdlib.Dict.__allocLeaf(key, value)
    else
        let tag = Stdlib.Dict.__getTag(node) in
        let ptr = __int64_to_rawptr(Stdlib.Dict.__clearTag(node)) in
        if tag == 2 then
            // Leaf node - check if same key or need to expand
            let storedKey = __raw_get(ptr, 0) in
            if storedKey == key then
                // Same key - replace value (create new leaf)
                Stdlib.Dict.__allocLeaf(key, value)
            else
                // Different key - need to expand to internal node
                let storedValue = __raw_get(ptr, 8) in
                Stdlib.Dict.__expandLeaf(storedKey, storedValue, key, value, level)
        else if tag == 1 then
            // Internal node - recurse into appropriate child
            let chunk = Stdlib.Dict.hashChunk(key, level) in
            let bitmap = __raw_get(ptr, 0) in
            let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                // Child exists - update it
                let oldChild = __raw_get(ptr, 8 + (idx * 8)) in
                let newChild = Stdlib.Dict.__setHelper(oldChild, key, value, level + 1) in
                Stdlib.Dict.__copyInternalWithUpdate(ptr, bitmap, idx, newChild)
            else
                // No child at this position - insert new leaf
                let newLeaf = Stdlib.Dict.__allocLeaf(key, value) in
                let newBitmap = Stdlib.Dict.setBit(bitmap, chunk) in
                Stdlib.Dict.__copyInternalWithInsert(ptr, bitmap, newBitmap, idx, newLeaf)
        else
            // Unknown tag - return node unchanged
            node

// Expand a leaf to an internal node when two keys collide
def Stdlib.Dict.__expandLeaf(key1: Int64, val1: Int64, key2: Int64, val2: Int64, level: Int64) : Int64 =
    let chunk1 = Stdlib.Dict.hashChunk(key1, level) in
    let chunk2 = Stdlib.Dict.hashChunk(key2, level) in
    if chunk1 == chunk2 then
        // Same chunk - need to go deeper
        if level >= 10 then
            // Max depth reached - just keep key2 (overwrites key1)
            // TODO: Implement collision nodes
            Stdlib.Dict.__allocLeaf(key2, val2)
        else
            // Create internal node with single child (recursive case)
            let child = Stdlib.Dict.__expandLeaf(key1, val1, key2, val2, level + 1) in
            let bitmap = Stdlib.Dict.setBit(0, chunk1) in
            let newNode = Stdlib.Dict.__allocInternal(bitmap, 1) in
            let _ = __raw_set(newNode, 8, child) in
            Stdlib.Dict.__setTag(__rawptr_to_int64(newNode), 1)
    else
        // Different chunks - create internal node with both leaves
        let leaf1 = Stdlib.Dict.__allocLeaf(key1, val1) in
        let leaf2 = Stdlib.Dict.__allocLeaf(key2, val2) in
        let bitmap = Stdlib.Dict.setBit(Stdlib.Dict.setBit(0, chunk1), chunk2) in
        let newNode = Stdlib.Dict.__allocInternal(bitmap, 2) in
        // Store children in order of their chunks
        if chunk1 < chunk2 then
            let _ = __raw_set(newNode, 8, leaf1) in
            let _ = __raw_set(newNode, 16, leaf2) in
            Stdlib.Dict.__setTag(__rawptr_to_int64(newNode), 1)
        else
            let _ = __raw_set(newNode, 8, leaf2) in
            let _ = __raw_set(newNode, 16, leaf1) in
            Stdlib.Dict.__setTag(__rawptr_to_int64(newNode), 1)

// Copy internal node with one child updated
def Stdlib.Dict.__copyInternalWithUpdate(oldPtr: RawPtr, bitmap: Int64, updateIdx: Int64, newChild: Int64) : Int64 =
    let numChildren = Stdlib.Int64.popcount(bitmap) in
    let newNode = Stdlib.Dict.__allocInternal(bitmap, numChildren) in
    // Copy all children, replacing the one at updateIdx
    Stdlib.Dict.__copyChildren(oldPtr, newNode, numChildren, updateIdx, newChild, 0)

// Copy children from old node to new node, updating one
def Stdlib.Dict.__copyChildren(oldPtr: RawPtr, newPtr: RawPtr, numChildren: Int64, updateIdx: Int64, newChild: Int64, i: Int64) : Int64 =
    if i >= numChildren then
        Stdlib.Dict.__setTag(__rawptr_to_int64(newPtr), 1)
    else
        let offset = 8 + (i * 8) in
        if i == updateIdx then
            let _ = __raw_set(newPtr, offset, newChild) in
            Stdlib.Dict.__copyChildren(oldPtr, newPtr, numChildren, updateIdx, newChild, i + 1)
        else
            let child = __raw_get(oldPtr, offset) in
            let _ = __raw_set(newPtr, offset, child) in
            Stdlib.Dict.__copyChildren(oldPtr, newPtr, numChildren, updateIdx, newChild, i + 1)

// Copy internal node with a new child inserted at position
def Stdlib.Dict.__copyInternalWithInsert(oldPtr: RawPtr, oldBitmap: Int64, newBitmap: Int64, insertIdx: Int64, newChild: Int64) : Int64 =
    let oldNumChildren = Stdlib.Int64.popcount(oldBitmap) in
    let newNumChildren = oldNumChildren + 1 in
    let newNode = Stdlib.Dict.__allocInternal(newBitmap, newNumChildren) in
    // Copy children, inserting new one at insertIdx
    Stdlib.Dict.__copyChildrenWithInsert(oldPtr, newNode, oldNumChildren, insertIdx, newChild, 0, 0)

// Copy children from old node to new node, inserting one
def Stdlib.Dict.__copyChildrenWithInsert(oldPtr: RawPtr, newPtr: RawPtr, oldNumChildren: Int64, insertIdx: Int64, newChild: Int64, oldI: Int64, newI: Int64) : Int64 =
    if newI == insertIdx then
        // Insert the new child here
        let offset = 8 + (newI * 8) in
        let _ = __raw_set(newPtr, offset, newChild) in
        Stdlib.Dict.__copyChildrenWithInsert(oldPtr, newPtr, oldNumChildren, insertIdx, newChild, oldI, newI + 1)
    else if oldI >= oldNumChildren then
        Stdlib.Dict.__setTag(__rawptr_to_int64(newPtr), 1)
    else
        // Copy from old node
        let oldOffset = 8 + (oldI * 8) in
        let newOffset = 8 + (newI * 8) in
        let child = __raw_get(oldPtr, oldOffset) in
        let _ = __raw_set(newPtr, newOffset, child) in
        Stdlib.Dict.__copyChildrenWithInsert(oldPtr, newPtr, oldNumChildren, insertIdx, newChild, oldI + 1, newI + 1)

def Stdlib.Dict.set(dict: Int64, key: Int64, value: Int64) : Int64 =
    Stdlib.Dict.__setHelper(dict, key, value, 0)
