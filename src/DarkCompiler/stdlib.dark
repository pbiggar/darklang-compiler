// Stdlib.dark - Standard Library Functions
//
// These functions are automatically included in all Dark programs.
// They provide the built-in Stdlib modules.

// Stdlib.Int64 - Integer operations

def Stdlib.Int64.add(a: Int64, b: Int64) : Int64 = a + b

def Stdlib.Int64.sub(a: Int64, b: Int64) : Int64 = a - b

def Stdlib.Int64.mul(a: Int64, b: Int64) : Int64 = a * b

def Stdlib.Int64.div(a: Int64, b: Int64) : Int64 = a / b

def Stdlib.Int64.max(a: Int64, b: Int64) : Int64 = if a > b then a else b

def Stdlib.Int64.min(a: Int64, b: Int64) : Int64 = if a < b then a else b

def Stdlib.Int64.mod(a: Int64, b: Int64) : Int64 = a % b

def Stdlib.Int64.absoluteValue(a: Int64) : Int64 = if a < 0 then 0 - a else a

def Stdlib.Int64.negate(a: Int64) : Int64 = 0 - a

def Stdlib.Int64.power(base: Int64, exponent: Int64) : Int64 =
    if exponent == 0 then 1
    else if exponent == 1 then base
    else base * Stdlib.Int64.power(base, exponent - 1)

def Stdlib.Int64.clamp(value: Int64, limitA: Int64, limitB: Int64) : Int64 =
    let lower = Stdlib.Int64.min(limitA, limitB) in
    let upper = Stdlib.Int64.max(limitA, limitB) in
    Stdlib.Int64.max(lower, Stdlib.Int64.min(upper, value))

def Stdlib.Int64.greaterThan(a: Int64, b: Int64) : Bool = a > b

def Stdlib.Int64.greaterThanOrEqualTo(a: Int64, b: Int64) : Bool = a >= b

def Stdlib.Int64.lessThan(a: Int64, b: Int64) : Bool = a < b

def Stdlib.Int64.lessThanOrEqualTo(a: Int64, b: Int64) : Bool = a <= b

// Bitwise operations
def Stdlib.Int64.bitwiseAnd(a: Int64, b: Int64) : Int64 = a & b

def Stdlib.Int64.bitwiseXor(a: Int64, b: Int64) : Int64 = a ^ b

def Stdlib.Int64.shiftLeft(a: Int64, shift: Int64) : Int64 = a << shift

def Stdlib.Int64.shiftRight(a: Int64, shift: Int64) : Int64 = a >> shift

// Count number of set bits (population count)
// Uses parallel bit counting algorithm (Brian Kernighan / SWAR)
def Stdlib.Int64.popcount(x: Int64) : Int64 =
    // Constants (in decimal):
    // 0x5555555555555555 = 6148914691236517205
    // 0x3333333333333333 = 3689348814741910323
    // 0x0F0F0F0F0F0F0F0F = 1085102592571150095
    // 0x0101010101010101 = 72340172838076673
    let mask1 = 6148914691236517205 in
    let mask2 = 3689348814741910323 in
    let mask3 = 1085102592571150095 in
    let mult = 72340172838076673 in
    let x = x - ((x >> 1) & mask1) in
    let x = (x & mask2) + ((x >> 2) & mask2) in
    let x = (x + (x >> 4)) & mask3 in
    (x * mult) >> 56

// Convert a single digit (0-9) to its string representation
def Stdlib.Int64.digitToString(n: Int64) : String =
    match n with
    | 0 -> "0"
    | 1 -> "1"
    | 2 -> "2"
    | 3 -> "3"
    | 4 -> "4"
    | 5 -> "5"
    | 6 -> "6"
    | 7 -> "7"
    | 8 -> "8"
    | 9 -> "9"
    | _ -> "?"

// Convert an integer to its string representation
def Stdlib.Int64.toString(n: Int64) : String =
    if n < 0 then "-" ++ Stdlib.Int64.toString(0 - n)
    else if n < 10 then Stdlib.Int64.digitToString(n)
    else Stdlib.Int64.toString(n / 10) ++ Stdlib.Int64.digitToString(n % 10)

// Stdlib.Bool - Boolean operations

def Stdlib.Bool.not(b: Bool) : Bool = !b

def Stdlib.Bool.and(a: Bool, b: Bool) : Bool = a && b

def Stdlib.Bool.or(a: Bool, b: Bool) : Bool = a || b

def Stdlib.Bool.xor(a: Bool, b: Bool) : Bool = if a then !b else b

def Stdlib.Bool.toString(b: Bool) : String = if b then "true" else "false"

// Stdlib.Tuple2 - 2-tuple operations

def Stdlib.Tuple2.create<a, b>(first: a, second: b) : (a, b) = (first, second)

def Stdlib.Tuple2.first<a, b>(t: (a, b)) : a = match t with | (x, y) -> x

def Stdlib.Tuple2.second<a, b>(t: (a, b)) : b = match t with | (x, y) -> y

def Stdlib.Tuple2.swap<a, b>(t: (a, b)) : (b, a) = match t with | (x, y) -> (y, x)

def Stdlib.Tuple2.mapFirst<a, b, c>(fn: (a) -> c, t: (a, b)) : (c, b) =
    match t with | (x, y) -> (fn(x), y)

def Stdlib.Tuple2.mapSecond<a, b, c>(fn: (b) -> c, t: (a, b)) : (a, c) =
    match t with | (x, y) -> (x, fn(y))

def Stdlib.Tuple2.mapBoth<a, b, c, d>(fnFirst: (a) -> c, fnSecond: (b) -> d, t: (a, b)) : (c, d) =
    match t with | (x, y) -> (fnFirst(x), fnSecond(y))

// Stdlib.Tuple3 - 3-tuple operations

def Stdlib.Tuple3.create<a, b, c>(first: a, second: b, third: c) : (a, b, c) = (first, second, third)

def Stdlib.Tuple3.first<a, b, c>(t: (a, b, c)) : a = match t with | (x, y, z) -> x

def Stdlib.Tuple3.second<a, b, c>(t: (a, b, c)) : b = match t with | (x, y, z) -> y

def Stdlib.Tuple3.third<a, b, c>(t: (a, b, c)) : c = match t with | (x, y, z) -> z

def Stdlib.Tuple3.mapFirst<a, b, c, d>(fn: (a) -> d, t: (a, b, c)) : (d, b, c) =
    match t with | (x, y, z) -> (fn(x), y, z)

def Stdlib.Tuple3.mapSecond<a, b, c, d>(fn: (b) -> d, t: (a, b, c)) : (a, d, c) =
    match t with | (x, y, z) -> (x, fn(y), z)

def Stdlib.Tuple3.mapThird<a, b, c, d>(fn: (c) -> d, t: (a, b, c)) : (a, b, d) =
    match t with | (x, y, z) -> (x, y, fn(z))

def Stdlib.Tuple3.mapAllThree<a, b, c, d, e, f>(fnFirst: (a) -> d, fnSecond: (b) -> e, fnThird: (c) -> f, t: (a, b, c)) : (d, e, f) =
    match t with | (x, y, z) -> (fnFirst(x), fnSecond(y), fnThird(z))

// Stdlib.Result - Result type for error handling
type Stdlib.Result.Result<t, e> = Ok of t | Error of e

// Check if result is Ok
def Stdlib.Result.isOk<t, e>(result: Stdlib.Result.Result<t, e>) : Bool =
    match result with
    | Ok(_) -> true
    | Error(_) -> false

// Check if result is Error
def Stdlib.Result.isError<t, e>(result: Stdlib.Result.Result<t, e>) : Bool =
    match result with
    | Ok(_) -> false
    | Error(_) -> true

// Get the Ok value or return a default
def Stdlib.Result.withDefault<t, e>(result: Stdlib.Result.Result<t, e>, default: t) : t =
    match result with
    | Ok(v) -> v
    | Error(_) -> default

// Transform the Ok value with a function
def Stdlib.Result.map<t, u, e>(result: Stdlib.Result.Result<t, e>, fn: (t) -> u) : Stdlib.Result.Result<u, e> =
    match result with
    | Ok(v) -> Ok(fn(v))
    | Error(err) -> Error(err)

// Transform the Error value with a function
// TODO: Blocked - constructor type inference doesn't use return type annotation
// The Error(fn(err)) gets type Result<t,e> from input, not Result<t,f> from return
// def Stdlib.Result.mapError<t, e, f>(fn: (e) -> f, result: Stdlib.Result.Result<t, e>) : Stdlib.Result.Result<t, f> =
//     match result with
//     | Ok(v) -> Ok(v)
//     | Error(err) -> Error(fn(err))

// Chain Result computations
def Stdlib.Result.andThen<t, u, e>(result: Stdlib.Result.Result<t, e>, fn: (t) -> Stdlib.Result.Result<u, e>) : Stdlib.Result.Result<u, e> =
    match result with
    | Ok(v) -> fn(v)
    | Error(err) -> Error(err)

// Stdlib.Option - Optional values
type Stdlib.Option.Option<t> = Some of t | None

// Check if option has a value
def Stdlib.Option.isSome<t>(opt: Stdlib.Option.Option<t>) : Bool =
    match opt with
    | Some(_) -> true
    | None -> false

// Check if option is empty
def Stdlib.Option.isNone<t>(opt: Stdlib.Option.Option<t>) : Bool =
    match opt with
    | Some(_) -> false
    | None -> true

// Get the value or return a default
def Stdlib.Option.withDefault<t>(opt: Stdlib.Option.Option<t>, default: t) : t =
    match opt with
    | Some(v) -> v
    | None -> default

// Transform the value with a function if present
def Stdlib.Option.map<t, u>(opt: Stdlib.Option.Option<t>, fn: (t) -> u) : Stdlib.Option.Option<u> =
    match opt with
    | Some(v) -> Some(fn(v))
    | None -> None

// Chain Option computations
def Stdlib.Option.andThen<t, u>(opt: Stdlib.Option.Option<t>, fn: (t) -> Stdlib.Option.Option<u>) : Stdlib.Option.Option<u> =
    match opt with
    | Some(v) -> fn(v)
    | None -> None

// Convert Option to a single-element or empty list
def Stdlib.Option.toList<t>(opt: Stdlib.Option.Option<t>) : List<t> =
    match opt with
    | Some(v) -> [v]
    | None -> []

// Stdlib.List - List operations
// Lists are represented as: Nil = 0, Cons = [tag=1, head, tail]

// Check if list is empty
def Stdlib.List.isEmpty<t>(list: List<t>) : Bool =
    match list with
    | [] -> true
    | _ -> false

// Get the length of a list
def Stdlib.List.length<t>(list: List<t>) : Int64 =
    match list with
    | [] -> 0
    | [h, ...rest] -> 1 + Stdlib.List.length<t>(rest)

// Create a single-element list
def Stdlib.List.singleton<t>(value: t) : List<t> = [value]

// Prepend an element to a list
def Stdlib.List.push<t>(list: List<t>, value: t) : List<t> = [value, ...list]

// Apply a function to each element of a list
def Stdlib.List.map<a, b>(list: List<a>, fn: (a) -> b) : List<b> =
    match list with
    | [] -> []
    | [h, ...t] -> [fn(h), ...Stdlib.List.map<a, b>(t, fn)]

// Keep only elements that satisfy a predicate
def Stdlib.List.filter<a>(list: List<a>, fn: (a) -> Bool) : List<a> =
    match list with
    | [] -> []
    | [h, ...t] ->
        if fn(h) then [h, ...Stdlib.List.filter<a>(t, fn)]
        else Stdlib.List.filter<a>(t, fn)

// Append an element to the end of a list
def Stdlib.List.pushBack<a>(list: List<a>, value: a) : List<a> =
    match list with
    | [] -> [value]
    | [h, ...t] -> [h, ...Stdlib.List.pushBack<a>(t, value)]

// Concatenate two lists
def Stdlib.List.append<a>(list1: List<a>, list2: List<a>) : List<a> =
    match list1 with
    | [] -> list2
    | [h, ...t] -> [h, ...Stdlib.List.append<a>(t, list2)]

// Reverse a list
def Stdlib.List.reverse<a>(list: List<a>) : List<a> =
    Stdlib.List.__reverseHelper<a>(list, [])

def Stdlib.List.__reverseHelper<a>(list: List<a>, acc: List<a>) : List<a> =
    match list with
    | [] -> acc
    | [h, ...t] -> Stdlib.List.__reverseHelper<a>(t, [h, ...acc])

// Fold left (reduce) over a list
def Stdlib.List.fold<a, b>(list: List<a>, init: b, fn: (b, a) -> b) : b =
    match list with
    | [] -> init
    | [h, ...t] -> Stdlib.List.fold<a, b>(t, fn(init, h), fn)

// Get head of list or return None
def Stdlib.List.head<a>(list: List<a>) : Stdlib.Option.Option<a> =
    match list with
    | [] -> None
    | [h, ...t] -> Some(h)

// Get tail of list or return None
// TODO: Blocked by parser - can't handle nested generics like Stdlib.Option.Option<List<a>>
// def Stdlib.List.tail<a>(list: List<a>) : Stdlib.Option.Option<List<a>> =
//     match list with
//     | [] -> None
//     | [h, ...t] -> Some(t)

// Get element at index (0-based)
def Stdlib.List.getAt<a>(list: List<a>, index: Int64) : Stdlib.Option.Option<a> =
    if index < 0 then None
    else match list with
    | [] -> None
    | [h, ...t] -> if index == 0 then Some(h) else Stdlib.List.getAt<a>(t, index - 1)

// Find first element satisfying a predicate
def Stdlib.List.findFirst<a>(list: List<a>, fn: (a) -> Bool) : Stdlib.Option.Option<a> =
    match list with
    | [] -> None
    | [h, ...t] -> if fn(h) then Some(h) else Stdlib.List.findFirst<a>(t, fn)

// Take first n elements
def Stdlib.List.take<a>(list: List<a>, n: Int64) : List<a> =
    if n <= 0 then []
    else match list with
    | [] -> []
    | [h, ...t] -> [h, ...Stdlib.List.take<a>(t, n - 1)]

// Drop first n elements
def Stdlib.List.drop<a>(list: List<a>, n: Int64) : List<a> =
    if n <= 0 then list
    else match list with
    | [] -> []
    | [h, ...t] -> Stdlib.List.drop<a>(t, n - 1)

// Stdlib.Path - Path operations

// Combine two path segments
def Stdlib.Path.combine(a: String, b: String) : String = a ++ "/" ++ b

// Get system temp directory (constant-folded at compile time)
// This is an intrinsic that returns "/tmp" on both macOS and Linux
// Note: The actual implementation is in the compiler, this is just type info
def Stdlib.Path.tempDir() : String = "/tmp"

// Stdlib.Platform - Platform detection (constant-folded at compile time)

// Check if running on macOS
def Stdlib.Platform.isMacOS() : Bool = false

// Check if running on Linux
def Stdlib.Platform.isLinux() : Bool = false

// Stdlib.String - String operations

// Newline constant (nullary function)
def Stdlib.String.newline() : String = "\n"

// Append two strings
def Stdlib.String.append(s1: String, s2: String) : String = s1 ++ s2

// Prepend first string to second
def Stdlib.String.prepend(s2: String, s1: String) : String = s1 ++ s2

// Get the length of a string in bytes
// String format: [len:8 bytes][data:N bytes]
def Stdlib.String.length(s: String) : Int64 =
    __raw_get<Int64>(__int64_to_rawptr(__string_to_int64(s)), 0)

// Check if string is empty
def Stdlib.String.isEmpty(s: String) : Bool =
    Stdlib.String.length(s) == 0

// TODO: Most String functions require runtime builtins that don't exist yet
// toUppercase, toLowercase, contains, startsWith, endsWith,
// trim, slice, first, last, reverse, replaceAll, etc.

// =============================================================================
// Stdlib.Dict - Immutable Dictionary using HAMT (Hash Array Mapped Trie)
// =============================================================================

// HAMT internal helper functions for working with bitmaps
// These are the building blocks for the Dict implementation

// Get 6-bit chunk of hash at given level (0-10)
// For a 64-bit hash, there are up to 11 levels (6 bits per level)
def Stdlib.Dict.hashChunk(hash: Int64, level: Int64) : Int64 =
    (hash >> (level * 6)) & 63

// Check if bit is set in bitmap
def Stdlib.Dict.hasBit(bitmap: Int64, bit: Int64) : Bool =
    ((bitmap >> bit) & 1) == 1

// Count bits below position in bitmap (for compressed array index)
def Stdlib.Dict.childIndex(bitmap: Int64, bit: Int64) : Int64 =
    Stdlib.Int64.popcount(bitmap & ((1 << bit) - 1))

// Set a bit in bitmap
def Stdlib.Dict.setBit(bitmap: Int64, bit: Int64) : Int64 =
    bitmap ^ (1 << bit)

// Clear a bit in bitmap (for remove)
// Note: ~x = (-1) ^ x (XOR with all ones)
def Stdlib.Dict.clearBit(bitmap: Int64, bit: Int64) : Int64 =
    bitmap & (((0 - 1)) ^ (1 << bit))

// =============================================================================
// Pointer tagging helpers
// =============================================================================
// We use the low 2 bits of pointers for tags (since 8-byte alignment gives us 3 free bits)
// Tag 0: Empty (NULL)
// Tag 1: Internal node (bitmap + children)
// Tag 2: Leaf node (key + value)
// Tag 3: Collision node (multiple entries with same hash prefix) - not yet implemented

// Get tag from a tagged pointer
def Stdlib.Dict.__getTag<k, v>(dict: Dict<k, v>) : Int64 =
    __dict_get_tag<k, v>(dict)

// Clear tag bits to get actual pointer (returns RawPtr)
def Stdlib.Dict.__clearTag<k, v>(dict: Dict<k, v>) : RawPtr =
    __dict_to_rawptr<k, v>(dict)

// Set tag on a pointer to create a Dict
def Stdlib.Dict.__setTag<k, v>(ptr: RawPtr, tag: Int64) : Dict<k, v> =
    __rawptr_to_dict<k, v>(ptr, tag)

// Allocate a leaf node: [key:8][value:8] = 16 bytes
def Stdlib.Dict.__allocLeaf<k, v>(key: k, value: v) : Dict<k, v> =
    let ptr = __raw_alloc(16) in
    let _ = __raw_set<k>(ptr, 0, key) in
    let _ = __raw_set<v>(ptr, 8, value) in
    Stdlib.Dict.__setTag<k, v>(ptr, 2)

// Allocate an internal node: [bitmap:8][children...] = 8 + 8*numChildren bytes
def Stdlib.Dict.__allocInternal(bitmap: Int64, numChildren: Int64) : RawPtr =
    let ptr = __raw_alloc(8 + (numChildren * 8)) in
    let _ = __raw_set<Int64>(ptr, 0, bitmap) in
    ptr

// =============================================================================
// Dict.empty - returns an empty dictionary
// =============================================================================
// Empty is represented as 0 (NULL with tag 0)
def Stdlib.Dict.empty<k, v>() : Dict<k, v> = __empty_dict<k, v>()

// =============================================================================
// Dict.get - lookup a key in the dictionary
// =============================================================================
// Returns Some(value) if found, None if not found

// Get helper - recursive lookup
// Note: keyHash is pre-computed hash of the key (for efficiency with string keys)
def Stdlib.Dict.__getHelper<k, v>(node: Dict<k, v>, key: k, keyHash: Int64, level: Int64) : Stdlib.Option.Option<v> =
    if __dict_is_null<k, v>(node) then
        None
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            // Leaf node
            let storedKey = __raw_get<k>(ptr, 0) in
            if __key_eq<k>(storedKey, key) then
                Some(__raw_get<v>(ptr, 8))
            else
                None
        else if tag == 1 then
            // Internal node
            let chunk = Stdlib.Dict.hashChunk(keyHash, level) in
            let bitmap = __raw_get<Int64>(ptr, 0) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
                let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
                Stdlib.Dict.__getHelper<k, v>(child, key, keyHash, level + 1)
            else
                None
        else
            // Unknown tag (collision node not yet implemented)
            None

def Stdlib.Dict.get<k, v>(dict: Dict<k, v>, key: k) : Stdlib.Option.Option<v> =
    Stdlib.Dict.__getHelper<k, v>(dict, key, __hash<k>(key), 0)

// =============================================================================
// Dict.set - insert or update a key-value pair
// =============================================================================
// Returns a new dictionary with the key-value pair added/updated

// Set helper - recursive insert
// Note: keyHash is pre-computed hash of the key (for efficiency with string keys)
def Stdlib.Dict.__setHelper<k, v>(node: Dict<k, v>, key: k, keyHash: Int64, value: v, level: Int64) : Dict<k, v> =
    if __dict_is_null<k, v>(node) then
        // Empty - create a new leaf
        Stdlib.Dict.__allocLeaf<k, v>(key, value)
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            // Leaf node - check if same key or need to expand
            let storedKey = __raw_get<k>(ptr, 0) in
            if __key_eq<k>(storedKey, key) then
                // Same key - replace value (create new leaf)
                Stdlib.Dict.__allocLeaf<k, v>(key, value)
            else
                // Different key - need to expand to internal node
                let storedValue = __raw_get<v>(ptr, 8) in
                let storedKeyHash = __hash<k>(storedKey) in
                Stdlib.Dict.__expandLeaf<k, v>(storedKey, storedKeyHash, storedValue, key, keyHash, value, level)
        else if tag == 1 then
            // Internal node - recurse into appropriate child
            let chunk = Stdlib.Dict.hashChunk(keyHash, level) in
            let bitmap = __raw_get<Int64>(ptr, 0) in
            let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                // Child exists - update it
                let oldChild = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
                let newChild = Stdlib.Dict.__setHelper<k, v>(oldChild, key, keyHash, value, level + 1) in
                Stdlib.Dict.__copyInternalWithUpdate<k, v>(ptr, bitmap, idx, newChild)
            else
                // No child at this position - insert new leaf
                let newLeaf = Stdlib.Dict.__allocLeaf<k, v>(key, value) in
                let newBitmap = Stdlib.Dict.setBit(bitmap, chunk) in
                Stdlib.Dict.__copyInternalWithInsert<k, v>(ptr, bitmap, newBitmap, idx, newLeaf)
        else
            // Unknown tag - return node unchanged
            node

// Expand a leaf to an internal node when two keys collide
def Stdlib.Dict.__expandLeaf<k, v>(key1: k, key1Hash: Int64, val1: v, key2: k, key2Hash: Int64, val2: v, level: Int64) : Dict<k, v> =
    let chunk1 = Stdlib.Dict.hashChunk(key1Hash, level) in
    let chunk2 = Stdlib.Dict.hashChunk(key2Hash, level) in
    if chunk1 == chunk2 then
        // Same chunk - need to go deeper
        if level >= 10 then
            // Max depth reached - just keep key2 (overwrites key1)
            // TODO: Implement collision nodes
            Stdlib.Dict.__allocLeaf<k, v>(key2, val2)
        else
            // Create internal node with single child (recursive case)
            let child = Stdlib.Dict.__expandLeaf<k, v>(key1, key1Hash, val1, key2, key2Hash, val2, level + 1) in
            let bitmap = Stdlib.Dict.setBit(0, chunk1) in
            let newNode = Stdlib.Dict.__allocInternal(bitmap, 1) in
            let _ = __raw_set<Dict<k, v>>(newNode, 8, child) in
            Stdlib.Dict.__setTag<k, v>(newNode, 1)
    else
        // Different chunks - create internal node with both leaves
        let leaf1 = Stdlib.Dict.__allocLeaf<k, v>(key1, val1) in
        let leaf2 = Stdlib.Dict.__allocLeaf<k, v>(key2, val2) in
        let bitmap = Stdlib.Dict.setBit(Stdlib.Dict.setBit(0, chunk1), chunk2) in
        let newNode = Stdlib.Dict.__allocInternal(bitmap, 2) in
        // Store children in order of their chunks
        if chunk1 < chunk2 then
            let _ = __raw_set<Dict<k, v>>(newNode, 8, leaf1) in
            let _ = __raw_set<Dict<k, v>>(newNode, 16, leaf2) in
            Stdlib.Dict.__setTag<k, v>(newNode, 1)
        else
            let _ = __raw_set<Dict<k, v>>(newNode, 8, leaf2) in
            let _ = __raw_set<Dict<k, v>>(newNode, 16, leaf1) in
            Stdlib.Dict.__setTag<k, v>(newNode, 1)

// Copy internal node with one child updated
def Stdlib.Dict.__copyInternalWithUpdate<k, v>(oldPtr: RawPtr, bitmap: Int64, updateIdx: Int64, newChild: Dict<k, v>) : Dict<k, v> =
    let numChildren = Stdlib.Int64.popcount(bitmap) in
    let newNode = Stdlib.Dict.__allocInternal(bitmap, numChildren) in
    // Copy all children, replacing the one at updateIdx
    Stdlib.Dict.__copyChildren<k, v>(oldPtr, newNode, numChildren, updateIdx, newChild, 0)

// Copy children from old node to new node, updating one
def Stdlib.Dict.__copyChildren<k, v>(oldPtr: RawPtr, newPtr: RawPtr, numChildren: Int64, updateIdx: Int64, newChild: Dict<k, v>, i: Int64) : Dict<k, v> =
    if i >= numChildren then
        Stdlib.Dict.__setTag<k, v>(newPtr, 1)
    else
        let offset = 8 + (i * 8) in
        if i == updateIdx then
            let _ = __raw_set<Dict<k, v>>(newPtr, offset, newChild) in
            Stdlib.Dict.__copyChildren<k, v>(oldPtr, newPtr, numChildren, updateIdx, newChild, i + 1)
        else
            let child = __raw_get<Dict<k, v>>(oldPtr, offset) in
            let _ = __raw_set<Dict<k, v>>(newPtr, offset, child) in
            Stdlib.Dict.__copyChildren<k, v>(oldPtr, newPtr, numChildren, updateIdx, newChild, i + 1)

// Copy internal node with a new child inserted at position
def Stdlib.Dict.__copyInternalWithInsert<k, v>(oldPtr: RawPtr, oldBitmap: Int64, newBitmap: Int64, insertIdx: Int64, newChild: Dict<k, v>) : Dict<k, v> =
    let oldNumChildren = Stdlib.Int64.popcount(oldBitmap) in
    let newNumChildren = oldNumChildren + 1 in
    let newNode = Stdlib.Dict.__allocInternal(newBitmap, newNumChildren) in
    // Copy children, inserting new one at insertIdx
    Stdlib.Dict.__copyChildrenWithInsert<k, v>(oldPtr, newNode, oldNumChildren, insertIdx, newChild, 0, 0)

// Copy children from old node to new node, inserting one
def Stdlib.Dict.__copyChildrenWithInsert<k, v>(oldPtr: RawPtr, newPtr: RawPtr, oldNumChildren: Int64, insertIdx: Int64, newChild: Dict<k, v>, oldI: Int64, newI: Int64) : Dict<k, v> =
    if newI == insertIdx then
        // Insert the new child here
        let offset = 8 + (newI * 8) in
        let _ = __raw_set<Dict<k, v>>(newPtr, offset, newChild) in
        Stdlib.Dict.__copyChildrenWithInsert<k, v>(oldPtr, newPtr, oldNumChildren, insertIdx, newChild, oldI, newI + 1)
    else if oldI >= oldNumChildren then
        Stdlib.Dict.__setTag<k, v>(newPtr, 1)
    else
        // Copy from old node
        let oldOffset = 8 + (oldI * 8) in
        let newOffset = 8 + (newI * 8) in
        let child = __raw_get<Dict<k, v>>(oldPtr, oldOffset) in
        let _ = __raw_set<Dict<k, v>>(newPtr, newOffset, child) in
        Stdlib.Dict.__copyChildrenWithInsert<k, v>(oldPtr, newPtr, oldNumChildren, insertIdx, newChild, oldI + 1, newI + 1)

def Stdlib.Dict.set<k, v>(dict: Dict<k, v>, key: k, value: v) : Dict<k, v> =
    Stdlib.Dict.__setHelper<k, v>(dict, key, __hash<k>(key), value, 0)

// =============================================================================
// Dict.remove - remove a key from the dictionary
// =============================================================================
// Returns a new dictionary without the key (or unchanged if key not present)

// Copy internal node excluding one child
def Stdlib.Dict.__copyChildrenExcluding<k, v>(oldPtr: RawPtr, newPtr: RawPtr, oldNumChildren: Int64, excludeIdx: Int64, oldI: Int64, newI: Int64) : Dict<k, v> =
    if oldI >= oldNumChildren then
        Stdlib.Dict.__setTag<k, v>(newPtr, 1)
    else if oldI == excludeIdx then
        // Skip this child
        Stdlib.Dict.__copyChildrenExcluding<k, v>(oldPtr, newPtr, oldNumChildren, excludeIdx, oldI + 1, newI)
    else
        // Copy this child
        let oldOffset = 8 + (oldI * 8) in
        let newOffset = 8 + (newI * 8) in
        let child = __raw_get<Dict<k, v>>(oldPtr, oldOffset) in
        let _ = __raw_set<Dict<k, v>>(newPtr, newOffset, child) in
        Stdlib.Dict.__copyChildrenExcluding<k, v>(oldPtr, newPtr, oldNumChildren, excludeIdx, oldI + 1, newI + 1)

// Copy internal node with one child removed
def Stdlib.Dict.__copyInternalWithRemove<k, v>(oldPtr: RawPtr, oldBitmap: Int64, newBitmap: Int64, removeIdx: Int64) : Dict<k, v> =
    let oldNumChildren = Stdlib.Int64.popcount(oldBitmap) in
    let newNumChildren = oldNumChildren - 1 in
    if newNumChildren == 0 then
        // No children left - return empty
        __empty_dict<k, v>()
    else
        let newNode = Stdlib.Dict.__allocInternal(newBitmap, newNumChildren) in
        Stdlib.Dict.__copyChildrenExcluding<k, v>(oldPtr, newNode, oldNumChildren, removeIdx, 0, 0)

// Remove helper - recursive removal
def Stdlib.Dict.__removeHelper<k, v>(node: Dict<k, v>, key: k, keyHash: Int64, level: Int64) : Dict<k, v> =
    if __dict_is_null<k, v>(node) then
        // Empty - key not found, return empty
        __empty_dict<k, v>()
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            // Leaf node
            let storedKey = __raw_get<k>(ptr, 0) in
            if __key_eq<k>(storedKey, key) then
                // Found the key - return empty to remove it
                __empty_dict<k, v>()
            else
                // Different key - not found, return unchanged
                node
        else if tag == 1 then
            // Internal node
            let chunk = Stdlib.Dict.hashChunk(keyHash, level) in
            let bitmap = __raw_get<Int64>(ptr, 0) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
                let oldChild = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
                let newChild = Stdlib.Dict.__removeHelper<k, v>(oldChild, key, keyHash, level + 1) in
                if __dict_is_null<k, v>(newChild) then
                    // Child was removed - need to update this node
                    let numChildren = Stdlib.Int64.popcount(bitmap) in
                    if numChildren == 1 then
                        // This was the only child - return empty
                        __empty_dict<k, v>()
                    else if numChildren == 2 then
                        // Two children, one being removed - check if we can collapse
                        // Get the other child index (0 if we're removing 1, 1 if removing 0)
                        let otherIdx = 1 - idx in
                        let otherChild = __raw_get<Dict<k, v>>(ptr, 8 + (otherIdx * 8)) in
                        let otherTag = Stdlib.Dict.__getTag<k, v>(otherChild) in
                        if otherTag == 2 then
                            // Other child is a leaf - collapse to it
                            otherChild
                        else
                            // Other child is internal - can't collapse, create new node
                            let newBitmap = Stdlib.Dict.clearBit(bitmap, chunk) in
                            Stdlib.Dict.__copyInternalWithRemove<k, v>(ptr, bitmap, newBitmap, idx)
                    else
                        // More than 2 children - create new node without removed child
                        let newBitmap = Stdlib.Dict.clearBit(bitmap, chunk) in
                        Stdlib.Dict.__copyInternalWithRemove<k, v>(ptr, bitmap, newBitmap, idx)
                else
                    // Child was modified (but not removed) - update
                    Stdlib.Dict.__copyInternalWithUpdate<k, v>(ptr, bitmap, idx, newChild)
            else
                // Bit not set - key not in this subtree
                node
        else
            // Unknown tag - return unchanged
            node

def Stdlib.Dict.remove<k, v>(dict: Dict<k, v>, key: k) : Dict<k, v> =
    Stdlib.Dict.__removeHelper<k, v>(dict, key, __hash<k>(key), 0)


// =============================================================================
// Dict Utility Functions (Generic)
// =============================================================================

// Check if dict is empty
def Stdlib.Dict.isEmpty<k, v>(dict: Dict<k, v>) : Bool =
    __dict_is_null<k, v>(dict)

// Check if dict contains a key
def Stdlib.Dict.contains<k, v>(dict: Dict<k, v>, key: k) : Bool =
    Stdlib.Dict.__containsHelper<k, v>(dict, key, __hash<k>(key), 0)

def Stdlib.Dict.__containsHelper<k, v>(node: Dict<k, v>, key: k, keyHash: Int64, level: Int64) : Bool =
    if __dict_is_null<k, v>(node) then
        false
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            // Leaf node
            let storedKey = __raw_get<k>(ptr, 0) in
            __key_eq<k>(storedKey, key)
        else if tag == 1 then
            // Internal node
            let chunk = Stdlib.Dict.hashChunk(keyHash, level) in
            let bitmap = __raw_get<Int64>(ptr, 0) in
            if Stdlib.Dict.hasBit(bitmap, chunk) then
                let idx = Stdlib.Dict.childIndex(bitmap, chunk) in
                let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
                Stdlib.Dict.__containsHelper<k, v>(child, key, keyHash, level + 1)
            else
                false
        else
            false

// Count entries in dict
def Stdlib.Dict.size<k, v>(dict: Dict<k, v>) : Int64 =
    Stdlib.Dict.__sizeHelper<k, v>(dict)

def Stdlib.Dict.__sizeHelper<k, v>(node: Dict<k, v>) : Int64 =
    if __dict_is_null<k, v>(node) then
        0
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            1
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__countChildren<k, v>(ptr, bitmap, 0)
        else
            0

def Stdlib.Dict.__countChildren<k, v>(ptr: RawPtr, bitmap: Int64, bit: Int64) : Int64 =
    if bit >= 64 then
        0
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        Stdlib.Dict.__sizeHelper<k, v>(child) + Stdlib.Dict.__countChildren<k, v>(ptr, bitmap, bit + 1)
    else
        Stdlib.Dict.__countChildren<k, v>(ptr, bitmap, bit + 1)

// =============================================================================
// Dict Enumeration (Generic)
// =============================================================================

// Get all keys from dict
def Stdlib.Dict.keys<k, v>(dict: Dict<k, v>) : List<k> =
    Stdlib.Dict.__keysHelper<k, v>(dict, [])

def Stdlib.Dict.__keysHelper<k, v>(node: Dict<k, v>, acc: List<k>) : List<k> =
    if __dict_is_null<k, v>(node) then
        acc
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            [key, ...acc]
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__collectKeysFromChildren<k, v>(ptr, bitmap, 0, acc)
        else
            acc

def Stdlib.Dict.__collectKeysFromChildren<k, v>(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: List<k>) : List<k> =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__keysHelper<k, v>(child, acc) in
        Stdlib.Dict.__collectKeysFromChildren<k, v>(ptr, bitmap, bit + 1, newAcc)
    else
        Stdlib.Dict.__collectKeysFromChildren<k, v>(ptr, bitmap, bit + 1, acc)

// Get all values from dict
def Stdlib.Dict.values<k, v>(dict: Dict<k, v>) : List<v> =
    Stdlib.Dict.__valuesHelper<k, v>(dict, [])

def Stdlib.Dict.__valuesHelper<k, v>(node: Dict<k, v>, acc: List<v>) : List<v> =
    if __dict_is_null<k, v>(node) then
        acc
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let value = __raw_get<v>(ptr, 8) in
            [value, ...acc]
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__collectValuesFromChildren<k, v>(ptr, bitmap, 0, acc)
        else
            acc

def Stdlib.Dict.__collectValuesFromChildren<k, v>(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: List<v>) : List<v> =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__valuesHelper<k, v>(child, acc) in
        Stdlib.Dict.__collectValuesFromChildren<k, v>(ptr, bitmap, bit + 1, newAcc)
    else
        Stdlib.Dict.__collectValuesFromChildren<k, v>(ptr, bitmap, bit + 1, acc)

// Get all entries from dict as key-value tuples
def Stdlib.Dict.entries<k, v>(dict: Dict<k, v>) : List<(k, v)> =
    Stdlib.Dict.__entriesHelper<k, v>(dict, [])

def Stdlib.Dict.__entriesHelper<k, v>(node: Dict<k, v>, acc: List<(k, v)>) : List<(k, v)> =
    if __dict_is_null<k, v>(node) then
        acc
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            let value = __raw_get<v>(ptr, 8) in
            [(key, value), ...acc]
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__collectEntriesFromChildren<k, v>(ptr, bitmap, 0, acc)
        else
            acc

def Stdlib.Dict.__collectEntriesFromChildren<k, v>(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: List<(k, v)>) : List<(k, v)> =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__entriesHelper<k, v>(child, acc) in
        Stdlib.Dict.__collectEntriesFromChildren<k, v>(ptr, bitmap, bit + 1, newAcc)
    else
        Stdlib.Dict.__collectEntriesFromChildren<k, v>(ptr, bitmap, bit + 1, acc)

// Fold over all entries in the dictionary
def Stdlib.Dict.fold<k, v, a>(dict: Dict<k, v>, init: a, f: (a, k, v) -> a) : a =
    Stdlib.Dict.__foldHelper<k, v, a>(dict, init, f)

def Stdlib.Dict.__foldHelper<k, v, a>(node: Dict<k, v>, acc: a, f: (a, k, v) -> a) : a =
    if __dict_is_null<k, v>(node) then
        acc
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            let value = __raw_get<v>(ptr, 8) in
            f(acc, key, value)
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__foldChildren<k, v, a>(ptr, bitmap, 0, acc, f)
        else
            acc

def Stdlib.Dict.__foldChildren<k, v, a>(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: a, f: (a, k, v) -> a) : a =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__foldHelper<k, v, a>(child, acc, f) in
        Stdlib.Dict.__foldChildren<k, v, a>(ptr, bitmap, bit + 1, newAcc, f)
    else
        Stdlib.Dict.__foldChildren<k, v, a>(ptr, bitmap, bit + 1, acc, f)

// Map over all values in the dictionary
def Stdlib.Dict.map<k, v, w>(dict: Dict<k, v>, f: (k, v) -> w) : Dict<k, w> =
    Stdlib.Dict.__mapHelper<k, v, w>(dict, f)

def Stdlib.Dict.__mapHelper<k, v, w>(node: Dict<k, v>, f: (k, v) -> w) : Dict<k, w> =
    if __dict_is_null<k, v>(node) then
        __empty_dict<k, w>()
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            let value = __raw_get<v>(ptr, 8) in
            let newValue = f(key, value) in
            Stdlib.Dict.__allocLeaf<k, w>(key, newValue)
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            let numChildren = Stdlib.Int64.popcount(bitmap) in
            let newPtr = Stdlib.Dict.__allocInternal(bitmap, numChildren) in
            Stdlib.Dict.__mapChildren<k, v, w>(ptr, newPtr, bitmap, 0, numChildren, f)
        else
            __empty_dict<k, w>()

def Stdlib.Dict.__mapChildren<k, v, w>(oldPtr: RawPtr, newPtr: RawPtr, bitmap: Int64, idx: Int64, numChildren: Int64, f: (k, v) -> w) : Dict<k, w> =
    if idx >= numChildren then
        Stdlib.Dict.__setTag<k, w>(newPtr, 1)
    else
        let child = __raw_get<Dict<k, v>>(oldPtr, 8 + (idx * 8)) in
        let mappedChild = Stdlib.Dict.__mapHelper<k, v, w>(child, f) in
        let _ = __raw_set<Dict<k, w>>(newPtr, 8 + (idx * 8), mappedChild) in
        Stdlib.Dict.__mapChildren<k, v, w>(oldPtr, newPtr, bitmap, idx + 1, numChildren, f)

// Filter entries in the dictionary
def Stdlib.Dict.filter<k, v>(dict: Dict<k, v>, f: (k, v) -> Bool) : Dict<k, v> =
    Stdlib.Dict.__filterHelper<k, v>(dict, Stdlib.Dict.empty<k, v>(), f)

def Stdlib.Dict.__filterHelper<k, v>(node: Dict<k, v>, acc: Dict<k, v>, f: (k, v) -> Bool) : Dict<k, v> =
    if __dict_is_null<k, v>(node) then
        acc
    else
        let tag = Stdlib.Dict.__getTag<k, v>(node) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(node) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            let value = __raw_get<v>(ptr, 8) in
            if f(key, value) then Stdlib.Dict.set<k, v>(acc, key, value) else acc
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__filterChildren<k, v>(ptr, bitmap, 0, acc, f)
        else
            acc

def Stdlib.Dict.__filterChildren<k, v>(ptr: RawPtr, bitmap: Int64, bit: Int64, acc: Dict<k, v>, f: (k, v) -> Bool) : Dict<k, v> =
    if bit >= 64 then
        acc
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newAcc = Stdlib.Dict.__filterHelper<k, v>(child, acc, f) in
        Stdlib.Dict.__filterChildren<k, v>(ptr, bitmap, bit + 1, newAcc, f)
    else
        Stdlib.Dict.__filterChildren<k, v>(ptr, bitmap, bit + 1, acc, f)

// =============================================================================
// Dict.merge - Combine two dictionaries
// =============================================================================
// Second dictionary's values win on key conflicts

def Stdlib.Dict.merge<k, v>(dict1: Dict<k, v>, dict2: Dict<k, v>) : Dict<k, v> =
    Stdlib.Dict.__mergeHelper<k, v>(dict2, dict1)

def Stdlib.Dict.__mergeHelper<k, v>(source: Dict<k, v>, target: Dict<k, v>) : Dict<k, v> =
    if __dict_is_null<k, v>(source) then
        target
    else
        let tag = Stdlib.Dict.__getTag<k, v>(source) in
        let ptr = Stdlib.Dict.__clearTag<k, v>(source) in
        if tag == 2 then
            let key = __raw_get<k>(ptr, 0) in
            let value = __raw_get<v>(ptr, 8) in
            Stdlib.Dict.set<k, v>(target, key, value)
        else if tag == 1 then
            let bitmap = __raw_get<Int64>(ptr, 0) in
            Stdlib.Dict.__mergeChildren<k, v>(ptr, bitmap, 0, target)
        else
            target

def Stdlib.Dict.__mergeChildren<k, v>(ptr: RawPtr, bitmap: Int64, bit: Int64, target: Dict<k, v>) : Dict<k, v> =
    if bit >= 64 then
        target
    else if Stdlib.Dict.hasBit(bitmap, bit) then
        let idx = Stdlib.Dict.childIndex(bitmap, bit) in
        let child = __raw_get<Dict<k, v>>(ptr, 8 + (idx * 8)) in
        let newTarget = Stdlib.Dict.__mergeHelper<k, v>(child, target) in
        Stdlib.Dict.__mergeChildren<k, v>(ptr, bitmap, bit + 1, newTarget)
    else
        Stdlib.Dict.__mergeChildren<k, v>(ptr, bitmap, bit + 1, target)

// =============================================================================
// Dict.fromList - Construct dictionary from list of pairs
// =============================================================================

def Stdlib.Dict.fromList<k, v>(pairs: List<(k, v)>) : Dict<k, v> =
    Stdlib.Dict.__fromListHelper<k, v>(pairs, Stdlib.Dict.empty<k, v>())

def Stdlib.Dict.__fromListHelper<k, v>(pairs: List<(k, v)>, acc: Dict<k, v>) : Dict<k, v> =
    match pairs with
    | [] -> acc
    | [pair, ...rest] ->
        let key = Stdlib.Tuple2.first<k, v>(pair) in
        let value = Stdlib.Tuple2.second<k, v>(pair) in
        Stdlib.Dict.__fromListHelper<k, v>(rest, Stdlib.Dict.set<k, v>(acc, key, value))

// =============================================================================
// Dict.getOrDefault - Get value with fallback
// =============================================================================

def Stdlib.Dict.getOrDefault<k, v>(dict: Dict<k, v>, key: k, default: v) : v =
    Stdlib.Option.withDefault<v>(Stdlib.Dict.get<k, v>(dict, key), default)

// ============================================================================
// Stdlib.Uuid - UUID v4 generation
// ============================================================================

// Helper: convert nibble (0-15) to hex char
def Stdlib.Uuid.__nibbleToHex(n: Int64) : String =
    match n with
    | 0 -> "0" | 1 -> "1" | 2 -> "2" | 3 -> "3"
    | 4 -> "4" | 5 -> "5" | 6 -> "6" | 7 -> "7"
    | 8 -> "8" | 9 -> "9" | 10 -> "a" | 11 -> "b"
    | 12 -> "c" | 13 -> "d" | 14 -> "e" | 15 -> "f"
    | _ -> "?"

// Helper: convert byte (from int64 at shift position) to 2 hex chars
def Stdlib.Uuid.__byteToHex(value: Int64, shift: Int64) : String =
    let byte = (value >> shift) & 255 in
    let hi = (byte >> 4) & 15 in
    let lo = byte & 15 in
    Stdlib.Uuid.__nibbleToHex(hi) ++ Stdlib.Uuid.__nibbleToHex(lo)

// Generate UUID v4: xxxxxxxx-xxxx-4xxx-Nxxx-xxxxxxxxxxxx
// where N is 8, 9, a, or b (variant bits)
def Stdlib.Uuid.generate() : String =
    let high = Stdlib.Random.int64() in
    let low = Stdlib.Random.int64() in
    // Set version (4) in byte 6: clear upper nibble, set to 4
    // Using XOR since we cleared the bits first with AND
    // Mask -61441 = 0xFFFFFFFFFFFF0FFF (clears bits 12-15)
    // Version 16384 = 0x4000 (sets bit 14 for version 4)
    let highWithVersion = (high & (-61441)) ^ 16384 in
    // Set variant (10xx) in byte 8: clear upper 2 bits, set to 10
    // Mask 4611686018427387903 = 0x3FFFFFFFFFFFFFFF (clears top 2 bits)
    // Variant -9223372036854775808 = 0x8000000000000000 (sets top bit)
    let lowWithVariant = (low & 4611686018427387903) ^ (-9223372036854775808) in
    // Format: 8-4-4-4-12 hex chars
    // bytes 0-3 (bits 32-63 of high)
    Stdlib.Uuid.__byteToHex(highWithVersion, 56) ++
    Stdlib.Uuid.__byteToHex(highWithVersion, 48) ++
    Stdlib.Uuid.__byteToHex(highWithVersion, 40) ++
    Stdlib.Uuid.__byteToHex(highWithVersion, 32) ++ "-" ++
    // bytes 4-5 (bits 16-31 of high)
    Stdlib.Uuid.__byteToHex(highWithVersion, 24) ++
    Stdlib.Uuid.__byteToHex(highWithVersion, 16) ++ "-" ++
    // bytes 6-7 (bits 0-15 of high) - contains version
    Stdlib.Uuid.__byteToHex(highWithVersion, 8) ++
    Stdlib.Uuid.__byteToHex(highWithVersion, 0) ++ "-" ++
    // bytes 8-9 (bits 48-63 of low) - contains variant
    Stdlib.Uuid.__byteToHex(lowWithVariant, 56) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 48) ++ "-" ++
    // bytes 10-15 (bits 0-47 of low)
    Stdlib.Uuid.__byteToHex(lowWithVariant, 40) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 32) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 24) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 16) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 8) ++
    Stdlib.Uuid.__byteToHex(lowWithVariant, 0)
