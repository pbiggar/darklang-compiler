// Binary Trees Benchmark
// Adapted from the Computer Language Benchmarks Game
//
// Creates complete binary trees using tuples and counts nodes.
// Tests heap allocation, recursion, and memory management.
//
// Tree representation: (isLeaf, leftPtr, rightPtr)
// - isLeaf=1: leaf node, leftPtr and rightPtr are unused
// - isLeaf=0: internal node with children

def makeTree(depth: Int64) : (Int64, Int64, Int64) =
    if depth <= 0 then (1, 0, 0)
    else
        let left = makeTree(depth - 1) in
        let right = makeTree(depth - 1) in
        // Encode tree as tuple - we use first element as discriminant
        (0, left.0 + left.1 + left.2, right.0 + right.1 + right.2)

// Since we can't store actual tree pointers in tuples, we count during construction
def countTree(depth: Int64) : Int64 =
    if depth <= 0 then 1
    else 1 + countTree(depth - 1) + countTree(depth - 1)

def stressTest(depth: Int64, iterations: Int64, acc: Int64) : Int64 =
    if iterations <= 0 then acc
    else
        let count = countTree(depth) in
        stressTest(depth, iterations - 1, acc + count)

// Run stress test: create many trees of depth 15
// Each complete binary tree of depth 15 has 2^16 - 1 = 65535 nodes
// Do 100 iterations
stressTest(15, 100, 0)
