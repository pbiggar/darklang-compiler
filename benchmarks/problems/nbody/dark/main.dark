// N-Body Benchmark
// Simulates gravitational interaction between planets
// From: Computer Language Benchmarks Game
//
// This benchmark tests:
// - Floating point arithmetic
// - Tuple operations
// - List traversal and transformation
// - Recursive algorithms

// Constants
// PI = 3.141592653589793
// SOLAR_MASS = 4 * PI * PI = 39.4784176043574
// DAYS_PER_YEAR = 365.24

// Body represented as tuple: (x, y, z, vx, vy, vz, mass)
// Using 7-tuple for each body

// Helper to get body components
def getX(b: (Float, Float, Float, Float, Float, Float, Float)) : Float = b.0
def getY(b: (Float, Float, Float, Float, Float, Float, Float)) : Float = b.1
def getZ(b: (Float, Float, Float, Float, Float, Float, Float)) : Float = b.2
def getVX(b: (Float, Float, Float, Float, Float, Float, Float)) : Float = b.3
def getVY(b: (Float, Float, Float, Float, Float, Float, Float)) : Float = b.4
def getVZ(b: (Float, Float, Float, Float, Float, Float, Float)) : Float = b.5
def getMass(b: (Float, Float, Float, Float, Float, Float, Float)) : Float = b.6

// Create a body with updated velocity
def updateVelocity(b: (Float, Float, Float, Float, Float, Float, Float),
                   dvx: Float, dvy: Float, dvz: Float) : (Float, Float, Float, Float, Float, Float, Float) =
    (b.0, b.1, b.2, b.3 + dvx, b.4 + dvy, b.5 + dvz, b.6)

// Update position based on velocity
def updatePosition(b: (Float, Float, Float, Float, Float, Float, Float),
                   dt: Float) : (Float, Float, Float, Float, Float, Float, Float) =
    (b.0 + dt * b.3, b.1 + dt * b.4, b.2 + dt * b.5, b.3, b.4, b.5, b.6)

// Apply velocity changes from interaction between body i and body j
// Returns (dvi_x, dvi_y, dvi_z, dvj_x, dvj_y, dvj_z)
def computeInteraction(bi: (Float, Float, Float, Float, Float, Float, Float),
                       bj: (Float, Float, Float, Float, Float, Float, Float),
                       dt: Float) : (Float, Float, Float, Float, Float, Float) =
    let dx = bi.0 - bj.0 in
    let dy = bi.1 - bj.1 in
    let dz = bi.2 - bj.2 in
    let distSq = dx * dx + dy * dy + dz * dz in
    let dist = Stdlib.Float.sqrt(distSq) in
    let mag = dt / (distSq * dist) in
    let massj = bj.6 in
    let massi = bi.6 in
    (Stdlib.Float.negate(dx * massj * mag),
     Stdlib.Float.negate(dy * massj * mag),
     Stdlib.Float.negate(dz * massj * mag),
     dx * massi * mag,
     dy * massi * mag,
     dz * massi * mag)

// For a simplified version, we'll work with just 2 bodies (Sun and Jupiter)
// to avoid complex list indexing

// Single step: update velocities from interaction, then update positions
def step2Bodies(sun: (Float, Float, Float, Float, Float, Float, Float),
                jupiter: (Float, Float, Float, Float, Float, Float, Float),
                dt: Float) : ((Float, Float, Float, Float, Float, Float, Float), (Float, Float, Float, Float, Float, Float, Float)) =
    let interaction = computeInteraction(sun, jupiter, dt) in
    let sun2 = updateVelocity(sun, interaction.0, interaction.1, interaction.2) in
    let jupiter2 = updateVelocity(jupiter, interaction.3, interaction.4, interaction.5) in
    let sun3 = updatePosition(sun2, dt) in
    let jupiter3 = updatePosition(jupiter2, dt) in
    (sun3, jupiter3)

// Run n steps
def advance2Bodies(sun: (Float, Float, Float, Float, Float, Float, Float),
                   jupiter: (Float, Float, Float, Float, Float, Float, Float),
                   dt: Float, n: Int64) : ((Float, Float, Float, Float, Float, Float, Float), (Float, Float, Float, Float, Float, Float, Float)) =
    if n <= 0 then (sun, jupiter)
    else
        let result = step2Bodies(sun, jupiter, dt) in
        advance2Bodies(result.0, result.1, dt, n - 1)

// Compute energy of 2-body system
def energy2Bodies(sun: (Float, Float, Float, Float, Float, Float, Float),
                  jupiter: (Float, Float, Float, Float, Float, Float, Float)) : Float =
    // Kinetic energy
    let ke_sun = 0.5 * sun.6 * (sun.3 * sun.3 + sun.4 * sun.4 + sun.5 * sun.5) in
    let ke_jupiter = 0.5 * jupiter.6 * (jupiter.3 * jupiter.3 + jupiter.4 * jupiter.4 + jupiter.5 * jupiter.5) in
    // Potential energy
    let dx = sun.0 - jupiter.0 in
    let dy = sun.1 - jupiter.1 in
    let dz = sun.2 - jupiter.2 in
    let dist = Stdlib.Float.sqrt(dx * dx + dy * dy + dz * dz) in
    let pe = Stdlib.Float.negate((sun.6 * jupiter.6) / dist) in
    ke_sun + ke_jupiter + pe

// Initial conditions (pre-computed constants)
// SOLAR_MASS = 39.4784176043574
// DAYS_PER_YEAR = 365.24

// Sun: at origin, no velocity, mass = SOLAR_MASS
def makeSun() : (Float, Float, Float, Float, Float, Float, Float) =
    (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 39.4784176043574)

// Jupiter with offset momentum already applied
// Original vx = 1.66007664274403694e-03 * 365.24 = 0.606326...
// We apply offset_momentum: sun.vx = -jupiter.vx * jupiter.mass / SOLAR_MASS
def makeJupiter() : (Float, Float, Float, Float, Float, Float, Float) =
    let dpy = 365.24 in
    let sm = 39.4784176043574 in
    let jmass = 0.000954791938424326609 * sm in  // Jupiter mass
    (4.84143144246472090,
     Stdlib.Float.negate(1.16032004402742839),
     Stdlib.Float.negate(0.103622044471123109),
     0.00166007664274403694 * dpy,
     0.00769901118419740425 * dpy,
     Stdlib.Float.negate(0.0000690460016972063023) * dpy,
     jmass)

// Offset momentum: adjust sun's velocity so total momentum is zero
def offsetMomentum(sun: (Float, Float, Float, Float, Float, Float, Float),
                   jupiter: (Float, Float, Float, Float, Float, Float, Float)) : (Float, Float, Float, Float, Float, Float, Float) =
    let sm = 39.4784176043574 in
    let px = Stdlib.Float.negate(jupiter.3 * jupiter.6) in
    let py = Stdlib.Float.negate(jupiter.4 * jupiter.6) in
    let pz = Stdlib.Float.negate(jupiter.5 * jupiter.6) in
    (sun.0, sun.1, sun.2, px / sm, py / sm, pz / sm, sun.6)

// Main benchmark
let sun0 = makeSun() in
let jupiter0 = makeJupiter() in
let sun1 = offsetMomentum(sun0, jupiter0) in
let result = advance2Bodies(sun1, jupiter0, 0.01, 500000) in
let e = energy2Bodies(result.0, result.1) in
Stdlib.Float.toInt(e * 1000000.0)
